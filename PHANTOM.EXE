do local Luna=loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua",true))();local player=game.Players.LocalPlayer;local character=player.Character or player.CharacterAdded:Wait() ;local humanoid=character:WaitForChild("Humanoid");local hrp=character:WaitForChild("HumanoidRootPart");local pathfindingService=game:GetService("PathfindingService");local tweenService=game:GetService("TweenService");local runService=game:GetService("RunService");local userInputService=game:GetService("UserInputService");local Window=Luna:CreateWindow({Name="Phantom.exe",Subtitle=nil,LogoID="82795327169782",LoadingEnabled=true,LoadingTitle="Phantom.exe",LoadingSubtitle="By Phantom",ConfigSettings={RootFolder=nil,ConfigFolder="Big Hub"},KeySystem=false,KeySettings={Title="Phantom Key.exe",Subtitle="Key System",Note="Best Key System Ever! Also, Please Use A HWID Keysystem like Pelican, Luarmor etc. that provide key strings based on your HWID since putting a simple string is very easy to bypass",SaveInRoot=true,SaveKey=true,Key={"Phantom"},SecondAction={Enabled=false,Type="Link",Parameter=""}}});local Player=Window:CreateTab({Name="Player",Icon="person",ImageSource="Material",ShowTitle=true});local Aimbot=Window:CreateTab({Name="Aimbot",Icon="gps_fixed",ImageSource="Material",ShowTitle=true});local Visuals=Window:CreateTab({Name="Visuals",Icon="visibility",ImageSource="Material",ShowTitle=true});local Combat=Window:CreateTab({Name="Combat",Icon="gavel",ImageSource="Material",ShowTitle=true});local Weapon=Window:CreateTab({Name="Weapon",Icon="shield",ImageSource="Material",ShowTitle=true});local Vehicle=Window:CreateTab({Name="Vehicle",Icon="directions_car",ImageSource="Material",ShowTitle=true});local JobAutoFarm=Window:CreateTab({Name="Job AutoFarm",Icon="euro_symbol",ImageSource="Material",ShowTitle=true});local Paragraph=JobAutoFarm:CreateParagraph({Title="Job AutoFarm Info",Text="BETA!"});local scriptRunning=false;local connections={};local currentTween=nil;local jobLocation=Vector3.new(134.032,255.467,208.614);local function getCharacterReferences() local char=player.Character;if  not char then return nil,nil,nil;end local hum=char:FindFirstChild("Humanoid");local root=char:FindFirstChild("HumanoidRootPart");return char,hum,root;end local function waitForCharacter() local char=player.Character or player.CharacterAdded:Wait() ;local hum=char:WaitForChild("Humanoid",10);local root=char:WaitForChild("HumanoidRootPart",10);if ( not hum or  not root) then warn("Failed to get character references");return nil,nil,nil;end return char,hum,root;end local path=pathfindingService:CreatePath({AgentRadius=2,AgentHeight=5,AgentCanJump=true});local function cleanup() print("Cleaning up auto farm script...");if currentTween then currentTween:Cancel();currentTween=nil;end for _,connection in pairs(connections) do if connection then connection:Disconnect();end end connections={};print("Auto farm script stopped and cleaned up.");end local function onCharacterDied() print("Character died. Waiting for respawn...");if scriptRunning then print("Waiting for character to respawn...");local char,hum,root=waitForCharacter();if (char and hum and root and scriptRunning) then print("Character respawned! Continuing auto farm...");end end end local function tweenToPosition(position) if  not scriptRunning then return false;end local char,hum,root=getCharacterReferences();if  not root then print("No character found, waiting for respawn...");char,hum,root=waitForCharacter();if ( not root or  not scriptRunning) then return false;end end local fixedPosition=Vector3.new(position.X,255,position.Z);local distance=(root.Position-fixedPosition).Magnitude;local tweenInfo=TweenInfo.new(distance/17 ,Enum.EasingStyle.Linear,Enum.EasingDirection.Out);currentTween=tweenService:Create(root,tweenInfo,{CFrame=CFrame.new(fixedPosition)});currentTween:Play();local completed=false;local connection;connection=currentTween.Completed:Connect(function() completed=true;if connection then connection:Disconnect();end end);local startTime=tick();local timeout=(distance/17) + 5 ;while  not completed and scriptRunning and ((tick() -startTime)<timeout)  do wait(0.1);end if  not scriptRunning then if currentTween then currentTween:Cancel();end return false;end currentTween=nil;return true;end local function followPathTo(targetPosition) if  not scriptRunning then return false;end local char,hum,root=getCharacterReferences();if  not root then print("No character found, waiting for respawn...");char,hum,root=waitForCharacter();if ( not root or  not scriptRunning) then return false;end end root.CFrame=CFrame.new(root.Position.X,255.3,root.Position.Z);wait(0.1);if  not scriptRunning then return false;end local success,errorMessage=pcall(function() path:ComputeAsync(root.Position,targetPosition);end);if (success and (path.Status==Enum.PathStatus.Success) and scriptRunning) then local waypoints=path:GetWaypoints();for i,waypoint in ipairs(waypoints) do if  not scriptRunning then return false;end local tweenSuccess=tweenToPosition(waypoint.Position);if  not tweenSuccess then return false;end if ((i== #waypoints) and scriptRunning) then print("Reached destination!");end end else if  not scriptRunning then return false;end warn("Path computation failed:",errorMessage);print("Using direct tween to target instead...");local tweenSuccess=tweenToPosition(targetPosition);if  not tweenSuccess then return false;end end if  not scriptRunning then return false;end local char,hum,root=getCharacterReferences();if root then root.CFrame=CFrame.new(targetPosition.X,255,targetPosition.Z);end return true;end local function applyForJob() if  not scriptRunning then return false;end local char,hum,root=getCharacterReferences();if  not root then print("No character found, waiting for respawn...");char,hum,root=waitForCharacter();if ( not root or  not scriptRunning) then return false;end end print("Triggering job application UI...");local touchPart=workspace.Map.Tiles.GasStationTile.Quick11.Interior.Quick11Beacon.TouchPart;firetouchinterest(root,touchPart,0);wait(0.1);firetouchinterest(root,touchPart,1);print("Job UI triggered! Please click the Apply button manually.");print("Waiting for you to click the Apply button...");local waitStart=tick();while scriptRunning and ((tick() -waitStart)<8)  do wait(0.1);end if  not scriptRunning then return false;end print("Continuing with shelf stocking work...");return true;end local function pickUpBox() if  not scriptRunning then return false;end print("Now firing proximity prompt for shelf stocking box...");local boxPrompt=workspace.Map.Tiles.GasStationTile.Quick11.Interior.ShelfStockingJob.NormalBox.ProximityPrompt;fireproximityprompt(boxPrompt);print("Fired proximity prompt for the shelf stocking box!");local waitStart=tick();while scriptRunning and ((tick() -waitStart)<2)  do wait(0.1);end return scriptRunning;end local function moveToBeaconAndDeliver() if  not scriptRunning then return false;end print("Searching for beacon.base...");local beaconBase=nil;local success=pcall(function() beaconBase=workspace.Beacon.Base;end);if  not scriptRunning then return false;end if ( not success or  not beaconBase) then print("Beacon.Base not found! Box may have already been delivered or there's an issue.");return false;end print("Found Beacon.Base, moving to it now...");local beaconPosition=beaconBase.Position;local moveSuccess=followPathTo(beaconPosition);if  not moveSuccess then return false;end print("Reached the beacon!");if  not scriptRunning then return false;end local maxWaitTime=10;local deliveryComplete=false;local waitStart=tick();while scriptRunning and ((tick() -waitStart)<maxWaitTime)  do local beaconStillExists=pcall(function() return workspace.Beacon.Base~=nil ;end);if  not beaconStillExists then print("Box successfully delivered! Beacon no longer exists.");deliveryComplete=true;break;end wait(0.5);end return deliveryComplete and scriptRunning ;end local function startAutoFarm() while scriptRunning do local char,hum,root=getCharacterReferences();if ( not char or  not hum or  not root) then print("Waiting for character...");char,hum,root=waitForCharacter();if ( not char or  not hum or  not root or  not scriptRunning) then break;end end local deathConnection=hum.Died:Connect(onCharacterDied);table.insert(connections,deathConnection);local pathSuccess=followPathTo(jobLocation);if  not pathSuccess then if scriptRunning then print("Failed to reach job location, retrying...");wait(2);continue;else break;end end local applySuccess=applyForJob();if  not applySuccess then if scriptRunning then print("Failed to apply for job, retrying...");wait(2);continue;else break;end end local boxCount=0;while scriptRunning do local currentChar,currentHum,currentRoot=getCharacterReferences();if ( not currentChar or  not currentHum or  not currentRoot) then print("Character lost, waiting for respawn...");break;end print("--- Starting box #"   .. (boxCount + 1)   .. " ---" );print("Moving to box pickup location...");local moveSuccess=followPathTo(jobLocation);if  not moveSuccess then if scriptRunning then print("Failed to move to pickup location, retrying...");wait(2);continue;else break;end end local boxPickedUp=pickUpBox();if boxPickedUp then boxCount=boxCount + 1 ;print("Box #"   .. boxCount   .. " picked up successfully" );local delivered=moveToBeaconAndDeliver();if delivered then print("Box #"   .. boxCount   .. " delivered successfully!" );else if  not scriptRunning then break;end print("Issue with delivery for box #"   .. boxCount   .. ", continuing anyway..." );end if  not scriptRunning then break;end wait(1);else if  not scriptRunning then break;end print("Failed to pick up box, retrying...");wait(2);end if  not scriptRunning then break;end print("--- Completed cycle #"   .. boxCount   .. " ---" );end if scriptRunning then print("Restarting due to character issue...");wait(1);end end print("Auto farm execution terminated.");cleanup();end local Toggle=JobAutoFarm:CreateToggle({Name="Quick-11 AutoFarm",Description="",CurrentValue=false,Callback=function(Value) scriptRunning=Value;if scriptRunning then print("Auto farm started!");spawn(function() startAutoFarm();end);else print("Auto farm stopped!");cleanup();end end},"Quick11Toggle");local janitorRunning=false;local janitorConnections={};local janitorCurrentTween=nil;local yPositionMaintenance=nil;local janitorTargetPart=workspace.BurgePlaceBeacon.TouchPart;local fixedYPosition=255.4;local tweenSpeed=0.3;local waitTimePerPuddle=5;local loopWaitTime=0;local function getJanitorCharacterReferences() local char=player.Character;if  not char then return nil,nil,nil;end local hum=char:FindFirstChild("Humanoid");local root=char:FindFirstChild("HumanoidRootPart");return char,hum,root;end local function waitForJanitorCharacter() local char=player.Character or player.CharacterAdded:Wait() ;local hum=char:WaitForChild("Humanoid",10);local root=char:WaitForChild("HumanoidRootPart",10);if ( not hum or  not root) then warn("Failed to get janitor character references");return nil,nil,nil;end return char,hum,root;end local function janitorCleanup() print("Cleaning up janitor farm script...");if janitorCurrentTween then janitorCurrentTween:Cancel();janitorCurrentTween=nil;end if yPositionMaintenance then yPositionMaintenance=false;end for _,connection in pairs(janitorConnections) do if connection then connection:Disconnect();end end janitorConnections={};print("Janitor farm script stopped and cleaned up.");end local function onJanitorCharacterDied() print("Character died. Waiting for respawn...");if janitorRunning then print("Waiting for character to respawn...");local char,hum,root=waitForJanitorCharacter();if (char and hum and root and janitorRunning) then print("Character respawned! Continuing janitor farm...");end end end local function moveToJanitorLocation(target) if  not janitorRunning then return false;end local char,hum,root=getJanitorCharacterReferences();if  not root then print("No character found, waiting for respawn...");char,hum,root=waitForJanitorCharacter();if ( not root or  not janitorRunning) then return false;end end local path=pathfindingService:CreatePath({AgentRadius=2,AgentHeight=5,AgentCanJump=true});local targetPosition;if (typeof(target)=="Vector3") then targetPosition=target;else targetPosition=target.Position;end local success,errorMessage=pcall(function() path:ComputeAsync(root.Position,targetPosition);end);if  not success then print("Failed to compute path:",errorMessage);return false;end local waypoints=path:GetWaypoints();for i,waypoint in ipairs(waypoints) do if  not janitorRunning then return false;end local currentChar,currentHum,currentRoot=getJanitorCharacterReferences();if  not currentRoot then print("Character lost during movement, waiting for respawn...");currentChar,currentHum,currentRoot=waitForJanitorCharacter();if ( not currentRoot or  not janitorRunning) then return false;end end local tweenInfo=TweenInfo.new(tweenSpeed,Enum.EasingStyle.Linear,Enum.EasingDirection.Out);local waypointPos=waypoint.Position;local modifiedPos=Vector3.new(waypointPos.X,fixedYPosition,waypointPos.Z);local tweenGoal={CFrame=CFrame.new(modifiedPos)};janitorCurrentTween=tweenService:Create(currentRoot,tweenInfo,tweenGoal);janitorCurrentTween:Play();local completed=false;local connection;connection=janitorCurrentTween.Completed:Connect(function() completed=true;if connection then connection:Disconnect();end end);while  not completed and janitorRunning  do wait(0.1);end if  not janitorRunning then if janitorCurrentTween then janitorCurrentTween:Cancel();end return false;end end if  not janitorRunning then return false;end local char,hum,root=getJanitorCharacterReferences();if  not root then print("Character lost during final movement, waiting for respawn...");char,hum,root=waitForJanitorCharacter();if ( not root or  not janitorRunning) then return false;end end local finalPos=Vector3.new(targetPosition.X,fixedYPosition,targetPosition.Z);janitorCurrentTween=tweenService:Create(root,TweenInfo.new(tweenSpeed,Enum.EasingStyle.Linear),{CFrame=CFrame.new(finalPos)});janitorCurrentTween:Play();local completed=false;local connection;connection=janitorCurrentTween.Completed:Connect(function() completed=true;if connection then connection:Disconnect();end end);while  not completed and janitorRunning  do wait(0.1);end if  not janitorRunning then if janitorCurrentTween then janitorCurrentTween:Cancel();end return false;end janitorCurrentTween=nil;print("Reached destination");return true;end local function fireJanitorTouch() if  not janitorRunning then return false;end local char,hum,root=getJanitorCharacterReferences();if  not root then print("No character found for touch interaction, waiting for respawn...");char,hum,root=waitForJanitorCharacter();if ( not root or  not janitorRunning) then return false;end end local touchInterest=janitorTargetPart:FindFirstChild("TouchInterest");if touchInterest then firetouchinterest(root,janitorTargetPart,0);wait(0.1);firetouchinterest(root,janitorTargetPart,1);print("Fired touch event");return true;else print("TouchInterest not found");return false;end end local function clickJanitorApplyButton() if  not janitorRunning then return false;end print("Looking for Apply button...");wait(1);if  not janitorRunning then return false;end local jobDialog=nil;local applyButton=nil;for _,gui in pairs(player.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then for _,desc in pairs(gui:GetDescendants()) do if (desc:IsA("TextLabel") and string.find(desc.Text,"Apply to Janitor")) then print("Found job dialog with text: "   .. desc.Text );jobDialog=desc.Parent;break;end end if jobDialog then break;end end end if jobDialog then print("Found job dialog, searching for Apply button...");for _,desc in pairs(jobDialog:GetDescendants()) do if (desc:IsA("TextButton") and (desc.Text=="Apply")) then applyButton=desc;print("Found Apply button!");break;end end if  not applyButton then for _,desc in pairs(jobDialog:GetDescendants()) do if desc:IsA("TextButton") then local color=desc.BackgroundColor3;if ((color.G>0.5) and (color.R<0.5) and (color.B<0.5)) then applyButton=desc;print("Found green button that might be the Apply button!");break;end end end end if  not applyButton then for _,desc in pairs(jobDialog:GetDescendants()) do if desc:IsA("TextButton") then applyButton=desc;print("Found a button in the dialog: "   .. desc.Name );break;end end end else print("Could not find job dialog. Looking for any visible Apply button...");for _,gui in pairs(player.PlayerGui:GetChildren()) do if gui:IsA("ScreenGui") then for _,desc in pairs(gui:GetDescendants()) do if (desc:IsA("TextButton") and (desc.Text=="Apply") and desc.Visible) then applyButton=desc;print("Found Apply button outside of dialog!");break;end end if applyButton then break;end end end end if applyButton then print("Attempting to click Apply button: "   .. applyButton.Name );local clicked=false;pcall(function() applyButton.MouseButton1Click:Fire();clicked=true;print("Method 1: Direct MouseButton1Click fire succeeded");end);wait(0.2);if  not clicked then pcall(function() for _,connection in pairs(getconnections(applyButton.MouseButton1Click)) do connection:Fire();clicked=true;print("Method 2: getconnections fire succeeded");break;end end);end wait(0.2);if clicked then print("Successfully clicked Apply button!");return true;else print("Failed to click Apply button despite finding it");end else print("Could not find Apply button in any GUI");end return false;end local function maintainJanitorYPosition() local originalY=fixedYPosition;yPositionMaintenance=true;spawn(function() while yPositionMaintenance and janitorRunning  do local char,hum,root=getJanitorCharacterReferences();if root then local currentPos=root.Position;if (currentPos.Y~=originalY) then root.CFrame=CFrame.new(currentPos.X,originalY,currentPos.Z);end end wait(0.1);end end);end local function getPuddleWaitTime(puddle) local waitTime=waitTimePerPuddle;print("Cleaning a small puddle: "   .. puddle.Name );return waitTime;end local function getPuddlesInOrder() if  not janitorRunning then return {};end local char,hum,root=getJanitorCharacterReferences();if  not root then return {};end local puddlesContainer=workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace.Interior.Puddles;local allPuddles=puddlesContainer:GetChildren();local smallPuddle=puddlesContainer:FindFirstChild("SmallPuddle");print("Searching for small puddles only...");local puddles={};if smallPuddle then table.insert(puddles,smallPuddle);print("Found named SmallPuddle");end for _,puddle in pairs(allPuddles) do if (puddle and puddle.Name:find("Small") and (puddle~=smallPuddle)) then table.insert(puddles,puddle);print("Found puddle with Small in name: "   .. puddle.Name );end end local validPuddles={};for _,puddle in pairs(puddles) do if puddle then local isExcluded=false;for _,child in pairs(puddlesContainer:GetChildren()) do if ((child==puddle) and ((child==puddlesContainer:GetChildren()[4]) or (child==puddlesContainer:GetChildren()[5]))) then isExcluded=true;print("Excluding puddle at index 4 or 5");break;end end if  not isExcluded then table.insert(validPuddles,puddle);end end end local puddlesWithDistance={};for _,puddle in pairs(validPuddles) do local distance=(puddle.Position-root.Position).Magnitude;table.insert(puddlesWithDistance,{puddle=puddle,distance=distance});end table.sort(puddlesWithDistance,function(a,b) return a.distance<b.distance ;end);local sortedPuddles={};for _,item in ipairs(puddlesWithDistance) do table.insert(sortedPuddles,item.puddle);end return sortedPuddles;end local function cleanPuddle(puddle) if  not janitorRunning then return false;end local char,hum,root=getJanitorCharacterReferences();if  not root then print("No character found for puddle cleaning, waiting for respawn...");char,hum,root=waitForJanitorCharacter();if ( not root or  not janitorRunning) then return false;end end print("Cleaning puddle: "   .. puddle.Name );local waitTime=getPuddleWaitTime(puddle);local touchInterest=puddle:FindFirstChild("TouchInterest");if touchInterest then print("Touching puddle to start cleaning...");firetouchinterest(root,puddle,0);print("Waiting "   .. waitTime   .. " seconds to clean puddle..." );local startTime=tick();while janitorRunning and ((tick() -startTime)<waitTime)  do wait(0.1);end if  not janitorRunning then return false;end firetouchinterest(root,puddle,1);print("Puddle cleaning completed");return true;else local proximityPrompt=puddle:FindFirstChild("ProximityPrompt");if proximityPrompt then print("Activating proximity prompt on puddle...");fireproximityprompt(proximityPrompt);local startTime=tick();while janitorRunning and ((tick() -startTime)<waitTime)  do wait(0.1);end if  not janitorRunning then return false;end print("Puddle cleaning completed");return true;else print("No direct interaction method found, waiting at puddle...");local startTime=tick();while janitorRunning and ((tick() -startTime)<waitTime)  do wait(0.1);end if  not janitorRunning then return false;end print("Puddle cleaning completed");return true;end end return false;end local function visitAllPuddlesLoop() print("Starting continuous puddle cleaning loop...");while janitorRunning do local char,hum,root=getJanitorCharacterReferences();if ( not char or  not hum or  not root) then print("Character lost during puddle loop, waiting for respawn...");char,hum,root=waitForJanitorCharacter();if ( not char or  not hum or  not root or  not janitorRunning) then break;end end local sortedPuddles=getPuddlesInOrder();print("Found "   ..  #sortedPuddles   .. " puddles to visit" );if ( #sortedPuddles==0) then if  not janitorRunning then break;end print("No puddles found, waiting before retrying...");local startTime=tick();while janitorRunning and ((tick() -startTime)<(loopWaitTime * 2))  do wait(0.1);end else for i,puddle in ipairs(sortedPuddles) do if  not janitorRunning then break;end local currentChar,currentHum,currentRoot=getJanitorCharacterReferences();if ( not currentChar or  not currentHum or  not currentRoot) then print("Character lost before puddle "   .. i   .. ", breaking loop..." );break;end print("Moving to puddle "   .. i   .. "/"   ..  #sortedPuddles   .. " - "   .. puddle.Name );local puddle_position=puddle.Position;local success=moveToJanitorLocation(puddle_position);if  not janitorRunning then break;end if success then cleanPuddle(puddle);if  not janitorRunning then break;end local startTime=tick();while janitorRunning and ((tick() -startTime)<0.5)  do wait(0.1);end else print("Failed to reach puddle "   .. i );break;end end if  not janitorRunning then break;end print("Completed one cleaning cycle, waiting before starting the next cycle...");local startTime=tick();while janitorRunning and ((tick() -startTime)<loopWaitTime)  do wait(0.1);end end end end local function startJanitorFarm() while janitorRunning do local char,hum,root=getJanitorCharacterReferences();if ( not char or  not hum or  not root) then print("Waiting for character...");char,hum,root=waitForJanitorCharacter();if ( not char or  not hum or  not root or  not janitorRunning) then break;end end local deathConnection=hum.Died:Connect(onJanitorCharacterDied);table.insert(janitorConnections,deathConnection);print("Starting janitor job application sequence");print("- Fixed Y position: "   .. fixedYPosition );print("- Tween speed: "   .. tweenSpeed   .. " (lower = faster)" );print("- Base wait time per puddle: "   .. waitTimePerPuddle   .. " seconds" );print("- Loop wait time: "   .. loopWaitTime   .. " seconds" );print("- CLEANING SMALL PUDDLES ONLY");maintainJanitorYPosition();local reachedTarget=moveToJanitorLocation(janitorTargetPart);if (reachedTarget and janitorRunning) then local touchSuccess=fireJanitorTouch();if (touchSuccess and janitorRunning) then local startTime=tick();while janitorRunning and ((tick() -startTime)<1.5)  do wait(0.1);end if  not janitorRunning then break;end local applySuccess=clickJanitorApplyButton();if (applySuccess and janitorRunning) then print("Successfully applied for janitor job!");local startTime=tick();while janitorRunning and ((tick() -startTime)<2)  do wait(0.1);end if  not janitorRunning then break;end visitAllPuddlesLoop();else if  not janitorRunning then break;end print("Failed to click Apply button. Trying to start puddle cleaning anyway...");local startTime=tick();while janitorRunning and ((tick() -startTime)<2)  do wait(0.1);end if janitorRunning then visitAllPuddlesLoop();end end else print("Failed to interact with the TouchPart, retrying...");if janitorRunning then wait(2);continue;end end else print("Failed to reach target location, retrying...");if janitorRunning then wait(2);continue;end end if janitorRunning then print("Restarting due to character issue...");wait(1);end end janitorCleanup();end local JanitorToggle=JobAutoFarm:CreateToggle({Name="Burger Place AutoFarm",Description="",CurrentValue=false,Callback=function(Value) janitorRunning=Value;if janitorRunning then print("Janitor farm started!");spawn(function() startJanitorFarm();end);else print("Janitor farm stopped!");janitorCleanup();end end},"JanitorToggle");JobAutoFarm:CreateDivider();local atmHackRunning=false;local atmHackLoop=nil;local SliderMinigame=require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame);local function modifiedNeedlePositionCalculation() local v23=(tick() * 2)%3 ;if (v23>1.5) then v23=3 -v23 ;elseif (v23< -0.5) then v23= -v23-0.5 ;end SliderMinigame.needle_pos.set(v23);end local function isNeedleInTargetZone() local needlePos=SliderMinigame.needle_pos.get();local targetPos=SliderMinigame.target_pos.get();local targetSize=SliderMinigame.target_size.get();local lowerBound=(targetPos-(targetSize/2)) -0.1 ;local upperBound=targetPos + (targetSize/2) + 0.1 ;return (needlePos>=lowerBound) and (needlePos<=upperBound) ;end local function autoClickIfInTargetZone() if isNeedleInTargetZone() then local currentLevel=SliderMinigame.level.get();SliderMinigame.level.set(currentLevel + 1 );local v16=require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame.play_audio);v16("3450794184",0.1,(math.min(2,1.25 + (0.25 * currentLevel) )));end end local function autoWinATMHack() if  not SliderMinigame.enabled.get() then return;end local targetLevels=SliderMinigame.levels.get();modifiedNeedlePositionCalculation();for _=1,3 do autoClickIfInTargetZone();end if (SliderMinigame.level.get()>=targetLevels) then SliderMinigame.win:Fire(true);end end local function atmHackCleanup() print("Cleaning up ATM hack script...");atmHackRunning=false;if atmHackLoop then atmHackLoop=nil;end print("ATM hack script stopped and cleaned up.");end local function startATMHack() print("ATM Hack started! The script will automatically win ATM minigames.");atmHackLoop=task.spawn(function() while atmHackRunning do task.wait(0.01);local success,err=pcall(autoWinATMHack);if  not success then warn("Auto-win error: "   .. tostring(err) );end end end);end local ATMHackToggle=JobAutoFarm:CreateToggle({Name="ATM Hack AutoWin",Description=nil,CurrentValue=false,Callback=function(Value) atmHackRunning=Value;if atmHackRunning then print("ATM Hack started!");spawn(function() startATMHack();end);else print("ATM Hack stopped!");atmHackCleanup();end end},"ATMHackToggle");local ESPObjects={};local ESP3DObjects={};local CurrentESPMode="2D Box";local ESPEnabled=false;local Config2D={BoxThickness=2,BoxTransparency=1,HealthColorGradient={{Threshold=25,Color=Color3.fromRGB(255,0,0)},{Threshold=50,Color=Color3.fromRGB(255,165,0)},{Threshold=75,Color=Color3.fromRGB(255,255,0)},{Threshold=100,Color=Color3.fromRGB(0,255,0)}},MaxDisplayDistance=1000,BoxSizeX=2,BoxSizeY=3,RefreshRate=5};local Config3D={Box_Color=Color3.fromRGB(255,0,0),Box_Thickness=2,Box_Transparency=1,Autothickness=true};local function GetHealthColor2D(health) for _,colorInfo in ipairs(Config2D.HealthColorGradient) do if (health<=colorInfo.Threshold) then return colorInfo.Color;end end return Color3.fromRGB(0,255,0);end local function GetHealthColor3D(currentHealth,maxHealth) local healthPercentage=currentHealth/maxHealth ;local red=Color3.fromRGB(227,52,52);local green=Color3.fromRGB(88,217,24);return red:Lerp(green,healthPercentage);end local function CreateESP2DForPlayer(espPlayer) if (espPlayer==player) then return;end if ESPObjects[espPlayer] then return ESPObjects[espPlayer];end ESPObjects[espPlayer]={Top=Drawing.new("Line"),Bottom=Drawing.new("Line"),Left=Drawing.new("Line"),Right=Drawing.new("Line"),LastUpdate=tick()};for _,line in pairs(ESPObjects[espPlayer]) do if (type(line)~="number") then line.Visible=false;line.Thickness=Config2D.BoxThickness;line.Transparency=Config2D.BoxTransparency;line.Color=Config2D.HealthColorGradient[1].Color;line.From=Vector2.new(0,0);line.To=Vector2.new(0,0);end end return ESPObjects[espPlayer];end local function CreateESP3DForPlayer(espPlayer) if (espPlayer==player) then return;end if ESP3DObjects[espPlayer] then return ESP3DObjects[espPlayer];end local lines={};for i=1,12 do local line=Drawing.new("Line");line.Visible=false;line.Color=Config3D.Box_Color;line.Thickness=Config3D.Box_Thickness;line.Transparency=Config3D.Box_Transparency;lines[i]=line;end ESP3DObjects[espPlayer]={lines=lines,connection=nil};return ESP3DObjects[espPlayer];end local function RemoveESPForPlayer(espPlayer) if ESPObjects[espPlayer] then for _,line in pairs(ESPObjects[espPlayer]) do if (type(line)~="number") then line:Remove();end end ESPObjects[espPlayer]=nil;end if ESP3DObjects[espPlayer] then if ESP3DObjects[espPlayer].connection then ESP3DObjects[espPlayer].connection:Disconnect();end for _,line in pairs(ESP3DObjects[espPlayer].lines) do line:Remove();end ESP3DObjects[espPlayer]=nil;end end local function Update2DESP() local currentTime=tick();for _,espPlayer in ipairs(game.Players:GetPlayers()) do if (espPlayer~=player) then local espObj=CreateESP2DForPlayer(espPlayer);if (ESPEnabled and (CurrentESPMode=="2D Box") and espPlayer.Character and espPlayer.Character:FindFirstChild("HumanoidRootPart") and espPlayer.Character:FindFirstChild("Humanoid")) then if ((currentTime-espObj.LastUpdate)>Config2D.RefreshRate) then RemoveESPForPlayer(espPlayer);espObj=CreateESP2DForPlayer(espPlayer);espObj.LastUpdate=currentTime;end local hrp=espPlayer.Character.HumanoidRootPart;local humanoid=espPlayer.Character.Humanoid;local head=espPlayer.Character:FindFirstChild("Head");local distance=(workspace.CurrentCamera.CFrame.Position-hrp.Position).Magnitude;if (distance>Config2D.MaxDisplayDistance) then for _,line in pairs(espObj) do if (type(line)~="number") then line.Visible=false;end end else local pos,onScreen=workspace.CurrentCamera:WorldToViewportPoint(hrp.Position);if onScreen then local scaleFactor=math.clamp(1 -(distance/Config2D.MaxDisplayDistance) ,0.3,1);local scale=(head and (head.Size.Y/2)) or 0.5 ;local size=Vector3.new(Config2D.BoxSizeX,Config2D.BoxSizeY,0) * scale * 2 * scaleFactor ;local TL=workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X,size.Y,0)).Position);local TR=workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new( -size.X,size.Y,0)).Position);local BL=workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, -size.Y,0)).Position);local BR=workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new( -size.X, -size.Y,0)).Position);espObj.Top.From=Vector2.new(TL.X,TL.Y);espObj.Top.To=Vector2.new(TR.X,TR.Y);espObj.Left.From=Vector2.new(TL.X,TL.Y);espObj.Left.To=Vector2.new(BL.X,BL.Y);espObj.Right.From=Vector2.new(TR.X,TR.Y);espObj.Right.To=Vector2.new(BR.X,BR.Y);espObj.Bottom.From=Vector2.new(BL.X,BL.Y);espObj.Bottom.To=Vector2.new(BR.X,BR.Y);local healthPercentage=(humanoid.Health/humanoid.MaxHealth) * 100 ;local color=GetHealthColor2D(healthPercentage);local transparency=Config2D.BoxTransparency * scaleFactor ;for _,line in pairs(espObj) do if (type(line)~="number") then line.Color=color;line.Transparency=transparency;line.Visible=true;end end else for _,line in pairs(espObj) do if (type(line)~="number") then line.Visible=false;end end end end else for _,line in pairs(espObj) do if (type(line)~="number") then line.Visible=false;end end end end end end local function Create3DESPForPlayer(espPlayer) if (espPlayer==player) then return;end local esp3DObj=CreateESP3DForPlayer(espPlayer);local function Update3DESP() if (ESPEnabled and (CurrentESPMode=="3D Box") and espPlayer.Character and espPlayer.Character:FindFirstChild("Humanoid") and espPlayer.Character:FindFirstChild("HumanoidRootPart") and (espPlayer.Character.Humanoid.Health>0)) then local pos,vis=workspace.CurrentCamera:WorldToViewportPoint(espPlayer.Character.HumanoidRootPart.Position);if vis then local Scale=espPlayer.Character.Head.Size.Y/2 ;local Size=Vector3.new(2,3,1.5) * Scale * 2 ;local Top1=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new( -Size.X,Size.Y, -Size.Z)).p);local Top2=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new( -Size.X,Size.Y,Size.Z)).p);local Top3=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X,Size.Y,Size.Z)).p);local Top4=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X,Size.Y, -Size.Z)).p);local Bottom1=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new( -Size.X, -Size.Y, -Size.Z)).p);local Bottom2=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new( -Size.X, -Size.Y,Size.Z)).p);local Bottom3=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y,Size.Z)).p);local Bottom4=workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p);local lines=esp3DObj.lines;lines[1].From=Vector2.new(Top1.X,Top1.Y);lines[1].To=Vector2.new(Top2.X,Top2.Y);lines[2].From=Vector2.new(Top2.X,Top2.Y);lines[2].To=Vector2.new(Top3.X,Top3.Y);lines[3].From=Vector2.new(Top3.X,Top3.Y);lines[3].To=Vector2.new(Top4.X,Top4.Y);lines[4].From=Vector2.new(Top4.X,Top4.Y);lines[4].To=Vector2.new(Top1.X,Top1.Y);lines[5].From=Vector2.new(Bottom1.X,Bottom1.Y);lines[5].To=Vector2.new(Bottom2.X,Bottom2.Y);lines[6].From=Vector2.new(Bottom2.X,Bottom2.Y);lines[6].To=Vector2.new(Bottom3.X,Bottom3.Y);lines[7].From=Vector2.new(Bottom3.X,Bottom3.Y);lines[7].To=Vector2.new(Bottom4.X,Bottom4.Y);lines[8].From=Vector2.new(Bottom4.X,Bottom4.Y);lines[8].To=Vector2.new(Bottom1.X,Bottom1.Y);lines[9].From=Vector2.new(Top1.X,Top1.Y);lines[9].To=Vector2.new(Bottom1.X,Bottom1.Y);lines[10].From=Vector2.new(Top2.X,Top2.Y);lines[10].To=Vector2.new(Bottom2.X,Bottom2.Y);lines[11].From=Vector2.new(Top3.X,Top3.Y);lines[11].To=Vector2.new(Bottom3.X,Bottom3.Y);lines[12].From=Vector2.new(Top4.X,Top4.Y);lines[12].To=Vector2.new(Bottom4.X,Bottom4.Y);local currentHealth=espPlayer.Character.Humanoid.Health;local maxHealth=espPlayer.Character.Humanoid.MaxHealth;local healthColor=GetHealthColor3D(currentHealth,maxHealth);local thickness=Config3D.Box_Thickness;if Config3D.Autothickness then local distance=(player.Character.HumanoidRootPart.Position-espPlayer.Character.HumanoidRootPart.Position).magnitude;thickness=math.clamp((1/distance) * 100 ,0.1,4);end for _,line in pairs(lines) do line.Color=healthColor;line.Thickness=thickness;line.Visible=true;end else for _,line in pairs(esp3DObj.lines) do line.Visible=false;end end else for _,line in pairs(esp3DObj.lines) do line.Visible=false;end if  not game.Players:FindFirstChild(espPlayer.Name) then if esp3DObj.connection then esp3DObj.connection:Disconnect();end end end end esp3DObj.connection=runService.RenderStepped:Connect(Update3DESP);end local function Initialize3DESP() for _,espPlayer in ipairs(game.Players:GetPlayers()) do if (espPlayer~=player) then Create3DESPForPlayer(espPlayer);end end end local function CleanupAllESP() for espPlayer,_ in pairs(ESPObjects) do RemoveESPForPlayer(espPlayer);end for espPlayer,_ in pairs(ESP3DObjects) do RemoveESPForPlayer(espPlayer);end end local function UpdateESPSystem() if  not ESPEnabled then CleanupAllESP();return;end if (CurrentESPMode=="2D Box") then for espPlayer,esp3DObj in pairs(ESP3DObjects) do if esp3DObj.connection then esp3DObj.connection:Disconnect();end for _,line in pairs(esp3DObj.lines) do line.Visible=false;end end elseif (CurrentESPMode=="3D Box") then for espPlayer,espObj in pairs(ESPObjects) do for _,line in pairs(espObj) do if (type(line)~="number") then line.Visible=false;end end end Initialize3DESP();end end local ESPDropdown=Visuals:CreateDropdown({Name="ESP Type",Description=nil,Options={"2D Box","3D Box"},CurrentOption={"2D Box"},MultipleOptions=false,SpecialType=nil,Callback=function(Option) CurrentESPMode=Option;UpdateESPSystem();end},"ESPDropdown");local ESPToggle=Visuals:CreateToggle({Name="Box ESP",Description=nil,CurrentValue=false,Callback=function(Value) ESPEnabled=Value;UpdateESPSystem();end},"ESPToggle");runService.RenderStepped:Connect(function() if (ESPEnabled and (CurrentESPMode=="2D Box")) then Update2DESP();end end);game.Players.PlayerAdded:Connect(function(newPlayer) if ((CurrentESPMode=="3D Box") and ESPEnabled) then Create3DESPForPlayer(newPlayer);end end);game.Players.PlayerRemoving:Connect(function(espPlayer) RemoveESPForPlayer(espPlayer);end);local nameTagsEnabled=false;local nameTagConnection=nil;local function createNameTag(namePlayer) if (namePlayer==player) then return;end local character=namePlayer.Character;if  not character then return;end local head=character:FindFirstChild("Head");if  not head then return;end local existingTag=head:FindFirstChild("NameTag");if existingTag then return;end local billboardGui=Instance.new("BillboardGui");billboardGui.Name="NameTag";billboardGui.Parent=head;billboardGui.Size=UDim2.new(0,100,0,20);billboardGui.StudsOffset=Vector3.new(0,2,0);billboardGui.AlwaysOnTop=true;billboardGui.LightInfluence=0;billboardGui.SizeOffset=Vector2.new(0,0);local nameLabel=Instance.new("TextLabel");nameLabel.Parent=billboardGui;nameLabel.Size=UDim2.new(1,0,1,0);nameLabel.BackgroundTransparency=1;nameLabel.Text=namePlayer.Name;nameLabel.TextColor3=Color3.fromRGB(255,255,255);nameLabel.TextSize=12;nameLabel.Font=Enum.Font.SourceSansBold;nameLabel.TextStrokeTransparency=0;nameLabel.TextStrokeColor3=Color3.fromRGB(0,0,0);end local function removeAllNameTags() for _,namePlayer in pairs(game.Players:GetPlayers()) do if namePlayer.Character then local head=namePlayer.Character:FindFirstChild("Head");if head then local nameTag=head:FindFirstChild("NameTag");if nameTag then nameTag:Destroy();end end end end end local function nameTagsCleanup() if nameTagConnection then nameTagConnection:Disconnect();nameTagConnection=nil;end removeAllNameTags();end local function startNameTags() nameTagConnection=runService.Heartbeat:Connect(function() if nameTagsEnabled then for _,namePlayer in pairs(game.Players:GetPlayers()) do if ((namePlayer~=player) and namePlayer.Character) then createNameTag(namePlayer);end end end end);end local NameTagsToggle=Visuals:CreateToggle({Name="Name ESP",Description=nil,CurrentValue=false,Callback=function(Value) nameTagsEnabled=Value;if nameTagsEnabled then spawn(function() startNameTags();end);else nameTagsCleanup();end end},"NameTagsToggle");getgenv().WeaponESPData=getgenv().WeaponESPData or {} ;getgenv().WeaponESPData.signatures={AK47={accuracy=0.85,automatic=true,fire_rate=600,MagSize=30,range=300,Recoil=0.4,reload_time=2.2,damage=27,Durability=720,KnockbackForce=100,RagdollChance=0.1,RarityName="Legendary",RarityPrice=70000},Anaconda={accuracy=0.95,automatic=false,fire_rate=80,MagSize=6,range=120,Recoil=0.8,reload_time=2,damage=70,Durability=120,KnockbackForce=350,RagdollChance=0.3,RarityName="Omega",RarityPrice=420000},C9={accuracy=0.7,automatic=false,fire_rate=300,MagSize=8,range=80,Recoil=0.2,reload_time=2,damage=11,Durability=120,RagdollChance=0,RarityName="Uncommon",RarityPrice=700},Crossbow={accuracy=0.95,automatic=false,fire_rate=100,MagSize=1,range=500,Recoil=0.3,reload_time=2,damage=90,Durability=120,KnockbackForce=100,RagdollChance=0.3,RarityName="Legendary",RarityPrice=60000},["Double Barrel"]={accuracy=0.5,automatic=false,fire_rate=100,MagSize=2,range=50,Recoil=2,reload_time=3,damage=16,Durability=84,KnockbackForce=300,RagdollChance=0.4,RarityName="Epic",RarityPrice=8000},Draco={accuracy=0.75,automatic=true,fire_rate=900,MagSize=25,range=250,Recoil=0.5,reload_time=2.2,damage=15,Durability=600,RagdollChance=0,RarityName="Epic",RarityPrice=19000},G3={accuracy=0.65,automatic=false,fire_rate=320,MagSize=10,range=80,Recoil=0.2,reload_time=2,damage=13,Durability=144,RagdollChance=0,RarityName="Uncommon",RarityPrice=900},Glock={accuracy=0.8,automatic=false,fire_rate=370,MagSize=15,range=80,Recoil=0.2,reload_time=2,damage=19,Durability=168,RagdollChance=0,RarityName="Rare",RarityPrice=1800},["Hunting Rifle"]={accuracy=0.93,automatic=false,fire_rate=50,MagSize=5,range=500,Recoil=0.8,reload_time=2.2,damage=35,Durability=72,KnockbackForce=200,RagdollChance=0.2,RarityName="Rare",RarityPrice=5000},M24={accuracy=0.97,automatic=false,fire_rate=50,MagSize=7,range=500,Recoil=0.8,reload_time=2,damage=50,Durability=120,KnockbackForce=200,RagdollChance=0.2,RarityName="Epic",RarityPrice=25000},MP5={accuracy=0.85,automatic=true,fire_rate=800,MagSize=30,range=200,Recoil=0.35,reload_time=2,damage=19,Durability=720,RagdollChance=0,RarityName="Legendary",RarityPrice=38000},P226={accuracy=0.75,automatic=false,fire_rate=370,MagSize=7,range=80,Recoil=0.25,reload_time=2,damage=22,Durability=180,RagdollChance=0,RarityName="Rare",RarityPrice=2200},RPG={accuracy=0.9,automatic=false,fire_rate=100,MagSize=1,range=600,Recoil=2,reload_time=2.6,explode_damage=1000,Durability=96,ExplodeKnockback=300,ExplodeRadius=12,RarityName="Legendary",RarityPrice=90000},Remington={accuracy=0.6,automatic=false,fire_rate=80,MagSize=5,range=80,Recoil=1.5,reload_time=2,damage=19,Durability=300,KnockbackForce=300,RagdollChance=0.4,RarityName="Legendary",RarityPrice=45000},Sawnoff={accuracy=0.4,automatic=false,fire_rate=150,MagSize=2,range=30,Recoil=3,reload_time=3,damage=18,Durability=240,KnockbackForce=450,RagdollChance=0.5,RarityName="Rare",RarityPrice=3500},Uzi={accuracy=0.7,automatic=true,fire_rate=1200,MagSize=20,range=150,Recoil=0.3,reload_time=1.7,damage=8,Durability=480,RagdollChance=0,RarityName="Rare",RarityPrice=3000},Axe={speed=1.4,range=6.5,cone_angle=80,damage=34,destructive=1.6,Durability=80,knockback_force=250,ragdoll_chance=0.2,RarityName="Rare",RarityPrice=3200},["Barbed Baseball Bat"]={speed=1.6,range=7.5,cone_angle=90,damage=43,destructive=1.2,Durability=100,knockback_force=300,ragdoll_chance=0.2,RarityName="Epic",RarityPrice=16000},["Baseball Bat"]={speed=1.6,range=7.5,cone_angle=90,damage=26,destructive=1.2,Durability=80,knockback_force=300,ragdoll_chance=0.2,RarityName="Uncommon",RarityPrice=900},["Bike Lock"]={speed=1.9,range=6,cone_angle=70,damage=17,destructive=1,Durability=40,knockback_force=100,ragdoll_chance=0.15,RarityName="Common",RarityPrice=90},["Bronze Mop"]={speed=1.5,range=6.5,cone_angle=70,damage=12,Durability=30,MopCashPercentageIncrease=20,MopSpeedPercentageIncrease=10,RarityName="Common",RarityPrice=100},["Chair Leg"]={speed=1.6,range=6.5,cone_angle=75,damage=21,destructive=1,Durability=50,knockback_force=100,ragdoll_chance=0.15,RarityName="Common",RarityPrice=300},["Butcher Knife"]={speed=1.6,range=6,cone_angle=75,damage=30,destructive=0.9,Durability=70,knockback_force=150,ragdoll_chance=0.1,RarityName="Rare",RarityPrice=1500},["Combat Axe"]={speed=1.6,range=6.5,cone_angle=75,damage=40,destructive=1.6,Durability=90,knockback_force=200,ragdoll_chance=0.15,RarityName="Epic",RarityPrice=14000},Crowbar={speed=1.6,range=7,cone_angle=80,damage=31,destructive=2,Durability=100,knockback_force=250,ragdoll_chance=0.15,RarityName="Rare",RarityPrice=3000},["Diamond Mop"]={speed=1.5,range=6.5,cone_angle=70,damage=12,Durability=30,MopCashPercentageIncrease=100,MopSpeedPercentageIncrease=40,RarityName="Rare",RarityPrice=1500},["Frying Pan"]={speed=1.7,range=6.5,cone_angle=90,damage=28,destructive=1,Durability=60,knockback_force=400,ragdoll_chance=0.3,RarityName="Rare",RarityPrice=2400},["Gold Mop"]={speed=1.5,range=6.5,cone_angle=70,damage=12,Durability=30,MopCashPercentageIncrease=70,MopSpeedPercentageIncrease=30,RarityName="Uncommon",RarityPrice=800},Hammer={speed=1.75,range=6,cone_angle=70,damage=23,destructive=1.5,Durability=70,knockback_force=80,ragdoll_chance=0.1,RarityName="Uncommon",RarityPrice=400},Machette={speed=1.8,range=7.25,cone_angle=85,damage=38,destructive=0.9,Durability=90,knockback_force=100,ragdoll_chance=0.15,RarityName="Epic",RarityPrice=14000},["Metal Baseball Bat"]={speed=1.6,range=7.5,cone_angle=90,damage=35,destructive=1.4,Durability=110,knockback_force=350,ragdoll_chance=0.2,RarityName="Rare",RarityPrice=4000},["Metal Pipe"]={speed=1.55,range=6.5,cone_angle=75,damage=20,destructive=1.5,Durability=60,knockback_force=150,ragdoll_chance=0.3,RarityName="Common",RarityPrice=150},Mop={speed=1.5,range=6.5,cone_angle=70,damage=12,Durability=30,MopCashPercentageIncrease=0,MopSpeedPercentageIncrease=0,RarityName="Common",RarityPrice=0},["Nailed Wooden Board"]={speed=1.4,range=6.5,cone_angle=80,damage=23,destructive=1,Durability=40,knockback_force=100,ragdoll_chance=0.1,RarityName="Uncommon",RarityPrice=350},["Pool Cue"]={speed=1.7,range=7.5,cone_angle=80,damage=15,destructive=1,Durability=30,knockback_force=80,ragdoll_chance=0.1,RarityName="Common",RarityPrice=70},["Rolling Pin"]={speed=1.75,range=6.5,cone_angle=75,damage=16,destructive=1,Durability=30,knockback_force=100,ragdoll_chance=0.1,RarityName="Common",RarityPrice=70},["Rusty Shovel"]={speed=1.2,range=7,cone_angle=75,damage=25,destructive=1.3,Durability=50,knockback_force=250,ragdoll_chance=0.15,RarityName="Uncommon",RarityPrice=600},Shank={speed=2,range=5.5,cone_angle=60,damage=20,destructive=0.7,Durability=40,knockback_force=50,ragdoll_chance=0.1,RarityName="Common",RarityPrice=300},Shovel={speed=1.2,range=7.5,cone_angle=75,damage=41,destructive=1.4,Durability=80,knockback_force=300,ragdoll_chance=0.3,RarityName="Epic",RarityPrice=9000},["Silver Mop"]={speed=1.5,range=6.5,cone_angle=70,damage=12,Durability=30,MopCashPercentageIncrease=45,MopSpeedPercentageIncrease=20,RarityName="Common",RarityPrice=300},["Sledge Hammer"]={speed=1.1,range=7.25,cone_angle=80,damage=47,destructive=3,Durability=110,knockback_force=550,ragdoll_chance=0.5,RarityName="Epic",RarityPrice=25000},Switchblade={speed=2,range=5.5,cone_angle=60,damage=29,destructive=0.7,Durability=60,knockback_force=80,ragdoll_chance=0.1,RarityName="Rare",RarityPrice=2200},["Tactical Axe"]={speed=1.75,range=6.5,cone_angle=75,damage=65,destructive=1.5,Durability=120,knockback_force=250,ragdoll_chance=0.2,RarityName="Legendary",RarityPrice=40000},["Tactical Knife"]={speed=2.2,range=5.75,cone_angle=75,damage=50,destructive=0.8,Durability=110,knockback_force=100,ragdoll_chance=0.1,RarityName="Legendary",RarityPrice=30000},["Tactical Shovel"]={speed=2,range=6.75,cone_angle=75,damage=58,destructive=1.4,Durability=130,knockback_force=150,ragdoll_chance=0.15,RarityName="Legendary",RarityPrice=35000},Taser={speed=2,range=5.25,cone_angle=60,damage=10,Durability=40,knockback_force=100,ragdoll_chance=1,RarityName="Common",RarityPrice=120},["Tire Iron"]={speed=1.6,range=6.5,cone_angle=80,damage=24,destructive=1.2,Durability=70,knockback_force=150,ragdoll_chance=0.1,RarityName="Uncommon",RarityPrice=450},["Wooden Board"]={speed=1.45,range=6.5,cone_angle=80,damage=16,destructive=1,Durability=25,knockback_force=100,ragdoll_chance=0.1,RarityName="Common",RarityPrice=50},Wrench={speed=1.5,range=6,cone_angle=80,damage=34,destructive=1.8,Durability=70,knockback_force=200,ragdoll_chance=0.15,RarityName="Rare",RarityPrice=2200}};getgenv().WeaponESPData.weaponImages={AK47="rbxassetid://124555430577178",Anaconda="rbxassetid://132781174839844",C9="rbxassetid://79659079988022",Crossbow="rbxassetid://89240642376715",["Double Barrel"]="rbxassetid://83625765638039",Draco="rbxassetid://120937616266903",G3="rbxassetid://133411291398002",Glock="rbxassetid://97846154366870",["Hunting Rifle"]="rbxassetid://81547704965153",M24="rbxassetid://73387965982603",MP5="rbxassetid://80501079489777",P226="rbxassetid://92521100297776",RPG="rbxassetid://138426000142807",Remington="rbxassetid://101271375930409",Sawnoff="rbxassetid://90588305892707",Uzi="rbxassetid://109290695652338",Axe="rbxassetid://101111222312507",["Barbed Baseball Bat"]="rbxassetid://124187547787390",["Baseball Bat"]="rbxassetid://70390201507839",["Bike Lock"]="rbxassetid://133060672669260",["Bronze Mop"]="rbxassetid://82833205175515",["Butcher Knife"]="rbxassetid://85388477314759",["Chair Leg"]="rbxassetid://114469903068875",["Combat Axe"]="rbxassetid://88977576372031",Crowbar="rbxassetid://90424115101219",["Diamond Mop"]="rbxassetid://116898350978149",["Frying Pan"]="rbxassetid://89200286532524",["Gold Mop"]="rbxassetid://126972994127039",Hammer="rbxassetid://78007467805546",Machette="rbxassetid://137560461839499",["Metal Baseball Bat"]="rbxassetid://70685459891353",["Metal Pipe"]="rbxassetid://88009218092973",Mop="rbxassetid://71489031926594",["Nailed Wooden Board"]="rbxassetid://133582084670866",["Pool Cue"]="rbxassetid://114421588409525",["Rolling Pin"]="rbxassetid://102775377780090",["Rusty Shovel"]="rbxassetid://92733711956764",Shank="rbxassetid://73963170829473",Shovel="rbxassetid://73431400264733",["Silver Mop"]="rbxassetid://80263199623205",["Sledge Hammer"]="rbxassetid://93546683073527",Switchblade="rbxassetid://93060515735865",["Tactical Axe"]="rbxassetid://128521472487967",["Tactical Knife"]="rbxassetid://138188463918911",["Tactical Shovel"]="rbxassetid://92343057781870",Taser="rbxassetid://125681892349691",["Tire Iron"]="rbxassetid://120450069729849",["Wooden Board"]="rbxassetid://73302633976873",Wrench="rbxassetid://78671837243529"};getgenv().WeaponESPData.rarityColors={Common=Color3.fromRGB(169,169,169),Uncommon=Color3.fromRGB(128,128,128),Rare=Color3.fromRGB(0,180,0),Epic=Color3.fromRGB(163,53,238),Legendary=Color3.fromRGB(255,165,0),Omega=Color3.fromRGB(255,0,0)};local espEnabled,espConnection,playerESPs=false,nil,{};local function getAttribute(obj,attr) local success,value=pcall(function() return obj:GetAttribute(attr);end);return (success and value) or nil ;end local function identifyWeapon(tool) for weaponName,signature in pairs(getgenv().WeaponESPData.signatures) do local matched,total=0,0;for attrName,expectedValue in pairs(signature) do local toolValue=getAttribute(tool,attrName);if (toolValue~=nil) then total=total + 1 ;if (type(expectedValue)=="number") then if (math.abs(toolValue-expectedValue )<=0.01) then matched=matched + 1 ;end elseif (toolValue==expectedValue) then matched=matched + 1 ;end end end if ((total>0) and ((matched/total)>=0.7)) then return {name=weaponName,rarity=signature.RarityName,price=signature.RarityPrice};end end return nil;end local function createPlayerESP(targetPlayer) if ((targetPlayer==player) or  not espEnabled) then return;end local targetCharacter=targetPlayer.Character;if  not targetCharacter then return;end local existingESP=targetCharacter:FindFirstChild("WeaponESPAdornment");if existingESP then existingESP:Destroy();end local weapons={};local function collectWeapons(container) for _,tool in ipairs(container:GetChildren()) do if tool:IsA("Tool") then local weaponInfo=identifyWeapon(tool);if weaponInfo then table.insert(weapons,weaponInfo);end end end end local backpack=targetPlayer:FindFirstChild("Backpack");if backpack then collectWeapons(backpack);end collectWeapons(targetCharacter);if ( #weapons>0) then local billboard=Instance.new("BillboardGui");billboard.Name="WeaponESPAdornment";billboard.Parent=targetCharacter;billboard.Size=UDim2.new(0, #weapons * 26 ,0,26);billboard.StudsOffset=Vector3.new(0, -5,0);billboard.AlwaysOnTop=true;billboard.LightInfluence=0;billboard.Adornee=targetCharacter:FindFirstChild("HumanoidRootPart");billboard.ClipsDescendants=false;billboard.ExtentsOffset=Vector3.new(0,0,0);billboard.ExtentsOffsetWorldSpace=Vector3.new(0,0,0);billboard.MaxDistance=math.huge;billboard.StudsOffsetWorldSpace=Vector3.new(0,0,0);local connection;connection=game:GetService("RunService").Heartbeat:Connect(function() if (billboard and billboard.Parent) then billboard.Size=UDim2.new(0, #weapons * 26 ,0,26);else connection:Disconnect();end end);playerESPs[targetPlayer]={billboard=billboard,connection=connection};local frame=Instance.new("Frame");frame.Size=UDim2.new(1,0,1,0);frame.BackgroundTransparency=1;frame.Parent=billboard;for i,weapon in ipairs(weapons) do local rarityColor=getgenv().WeaponESPData.rarityColors[weapon.rarity] or Color3.fromRGB(255,255,255) ;local weaponBox=Instance.new("Frame");weaponBox.Size=UDim2.new(0,22,0,22);weaponBox.Position=UDim2.new(0,(i-1) * 24 ,0,2);weaponBox.BackgroundColor3=rarityColor;weaponBox.BorderColor3=Color3.fromRGB(0,0,0);weaponBox.BorderSizePixel=1;weaponBox.Parent=frame;local corner=Instance.new("UICorner");corner.CornerRadius=UDim.new(0,3);corner.Parent=weaponBox;local gradient=Instance.new("UIGradient");gradient.Color=ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.fromRGB(255,255,255)),ColorSequenceKeypoint.new(0.5,rarityColor),ColorSequenceKeypoint.new(1,Color3.fromRGB(0,0,0))});gradient.Rotation= -45;gradient.Parent=weaponBox;local stroke=Instance.new("UIStroke");stroke.Color=Color3.fromRGB(255,255,255);stroke.Transparency=0.7;stroke.Thickness=1;stroke.Parent=weaponBox;local imageLabel=Instance.new("ImageLabel");imageLabel.Size=UDim2.new(0,18,0,18);imageLabel.Position=UDim2.new(0,2,0,2);imageLabel.BackgroundTransparency=1;imageLabel.Image=getgenv().WeaponESPData.weaponImages[weapon.name] or "" ;imageLabel.ScaleType=Enum.ScaleType.Fit;imageLabel.Parent=weaponBox;end end end local function removeAllESP() for targetPlayer,espData in pairs(playerESPs) do if espData then if (espData.billboard and espData.billboard.Parent) then espData.billboard:Destroy();end if espData.connection then espData.connection:Disconnect();end end end playerESPs={};for _,targetPlayer in ipairs(game.Players:GetPlayers()) do if targetPlayer.Character then local existingESP=targetPlayer.Character:FindFirstChild("WeaponESPAdornment");if existingESP then existingESP:Destroy();end end end end local function startESP() if espConnection then return;end for _,targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer);end local playerAddedConnection=game.Players.PlayerAdded:Connect(createPlayerESP);local playerRemovingConnection=game.Players.PlayerRemoving:Connect(function(targetPlayer) if playerESPs[targetPlayer] then if playerESPs[targetPlayer].billboard then playerESPs[targetPlayer].billboard:Destroy();end if playerESPs[targetPlayer].connection then playerESPs[targetPlayer].connection:Disconnect();end playerESPs[targetPlayer]=nil;end end);espConnection=coroutine.create(function() while espEnabled do wait(2);if espEnabled then for _,targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer);end end end end);coroutine.resume(espConnection);playerESPs._connections={playerAdded=playerAddedConnection,playerRemoving=playerRemovingConnection};end local function stopESP() espEnabled=false;if playerESPs._connections then if playerESPs._connections.playerAdded then playerESPs._connections.playerAdded:Disconnect();end if playerESPs._connections.playerRemoving then playerESPs._connections.playerRemoving:Disconnect();end playerESPs._connections=nil;end removeAllESP();espConnection=nil;end local Toggle=Visuals:CreateToggle({Name="Weapon ESP",Description="Shows weapons that other players are carrying",CurrentValue=false,Callback=function(Value) if Value then espEnabled=true;startESP();else stopESP();end end},"WeaponESP");local sliderValues={};local attributeConfigs={{name="acceleration",min=0,max=100,default=8,increment=1},{name="braking",min=0,max=100,default=10,increment=1},{name="deceleration",min=0,max=50,default=1,increment=1},{name="forwardMaxSpeed",min=0,max=100,default=23,increment=1},{name="handBrakeTorque",min=0,max=50000,default=20000,increment=100},{name="maxSpeedTorque",min=0,max=2000,default=500,increment=10},{name="reverseMaxSpeed",min=0,max=100,default=5,increment=1}};for _,config in ipairs(attributeConfigs) do sliderValues[config.name]=config.default;end for _,config in ipairs(attributeConfigs) do local slider=Vehicle:CreateSlider({Name=config.name,Range={config.min,config.max},Increment=config.increment,CurrentValue=config.default,Callback=function(Value) sliderValues[config.name]=Value;end},"Slider"   .. config.name );end local ApplyButton=Vehicle:CreateButton({Name="Apply Motor Changes",Description="Apply all slider values to vehicle motors",Callback=function() local function updateMotorsInObject(obj) for attributeName,value in pairs(sliderValues) do if (obj:GetAttribute(attributeName)~=nil) then obj:SetAttribute(attributeName,value);end end for _,child in pairs(obj:GetChildren()) do updateMotorsInObject(child);end end local vehiclesFolder=workspace:FindFirstChild("Vehicles");if  not vehiclesFolder then return;end local motorsChanged=0;local vehiclesProcessed=0;for _,vehicle in pairs(vehiclesFolder:GetChildren()) do if (vehicle:IsA("Model") or vehicle:IsA("Folder")) then vehiclesProcessed=vehiclesProcessed + 1 ;updateMotorsInObject(vehicle);end end local motorsFolder=vehiclesFolder:FindFirstChild("Motors");if motorsFolder then for _,motor in pairs(motorsFolder:GetChildren()) do for attributeName,value in pairs(sliderValues) do if (motor:GetAttribute(attributeName)~=nil) then motor:SetAttribute(attributeName,value);motorsChanged=motorsChanged + 1 ;end end end end for _,vehicle in pairs(vehiclesFolder:GetChildren()) do if (vehicle:IsA("Model") or vehicle:IsA("Folder")) then local function countAttributes(obj) for attributeName,value in pairs(sliderValues) do if (obj:GetAttribute(attributeName)~=nil) then motorsChanged=motorsChanged + 1 ;end end for _,child in pairs(obj:GetChildren()) do countAttributes(child);end end countAttributes(vehicle);end end end});local Players=game:GetService("Players");local RunService=game:GetService("RunService");local player=Players.LocalPlayer;local autoSprintEnabled=false;local connection;local spamConnection;local function enableAutoSprint() if  not player.Character then return;end wait(2);connection=RunService.Heartbeat:Connect(function() if  not player.Character then connection:Disconnect();return;end if autoSprintEnabled then local humanoid=player.Character:FindFirstChild("Humanoid");if (humanoid and (humanoid.MoveDirection.Magnitude>0.1)) then player:SetAttribute("SpeedMultiplier",1.3125);local success=pcall(function() local keybindModule=require(game.ReplicatedStorage.Modules.Game.Keybinds);if keybindModule.hook_action then keybindModule.hook_action("sprint",function() return true;end);end end);pcall(function() local sprintModule=require(game.ReplicatedStorage.Modules.Game.Sprint);if (sprintModule.sprinting and (sprintModule.sprinting.get()==false)) then sprintModule.sprinting.set(true);end if sprintModule.sprint_bar then sprintModule.sprint_bar.set(1);end end);else player:SetAttribute("SpeedMultiplier",1);end end end);end local function startSprintSpam() spamConnection=spawn(function() while autoSprintEnabled do wait(0.5);if (autoSprintEnabled and player.Character) then local humanoid=player.Character:FindFirstChild("Humanoid");if (humanoid and (humanoid.MoveDirection.Magnitude>0.1)) then pcall(function() local sprintModule=require(game.ReplicatedStorage.Modules.Game.Sprint);if sprintModule.sprinting then sprintModule.sprinting.set(false);wait(0.05);sprintModule.sprinting.set(true);end end);end end end end);end local function stopAutoSprint() if connection then connection:Disconnect();connection=nil;end player:SetAttribute("SpeedMultiplier",1);end local function setupCharacter() if autoSprintEnabled then enableAutoSprint();end end if player.Character then setupCharacter();end player.CharacterAdded:Connect(function() wait(3);setupCharacter();end);local Toggle=Player:CreateToggle({Name="Super Speed",Description="Speed Boost",CurrentValue=false,Callback=function(Value) autoSprintEnabled=Value;if autoSprintEnabled then if player.Character then enableAutoSprint();end startSprintSpam();else stopAutoSprint();end end},"SpeedBoostToggle");local Players=game:GetService("Players");local player=Players.LocalPlayer;local jumpBoostEnabled=false;local function updateJumpPower(character,enabled) local humanoid=character:WaitForChild("Humanoid",10);if  not humanoid then return;end if enabled then humanoid.UseJumpPower=true;humanoid.JumpPower=65;else humanoid.UseJumpPower=true;humanoid.JumpPower=23;end end local function setupCharacter(character) updateJumpPower(character,jumpBoostEnabled);end if player.Character then setupCharacter(player.Character);end player.CharacterAdded:Connect(setupCharacter);local Toggle=Player:CreateToggle({Name="Super Jump",Description="Jump Boost",CurrentValue=false,Callback=function(Value) jumpBoostEnabled=Value;if player.Character then updateJumpPower(player.Character,jumpBoostEnabled);end end},"JumpBoostToggle");Player:CreateDivider();local Players=game:GetService("Players");local RunService=game:GetService("RunService");local player=Players.LocalPlayer;local infiniteStaminaEnabled=false;local connection;local spamConnection;local function enableInfiniteStamina() if  not player.Character then return;end wait(2);connection=RunService.Heartbeat:Connect(function() if  not player.Character then connection:Disconnect();return;end if infiniteStaminaEnabled then local humanoid=player.Character:FindFirstChild("Humanoid");if (humanoid and (humanoid.MoveDirection.Magnitude>0.1)) then pcall(function() local keybindModule=require(game.ReplicatedStorage.Modules.Game.Keybinds);if keybindModule.hook_action then keybindModule.hook_action("sprint",function() return true;end);end end);pcall(function() local sprintModule=require(game.ReplicatedStorage.Modules.Game.Sprint);if (sprintModule.sprinting and (sprintModule.sprinting.get()==false)) then sprintModule.sprinting.set(true);end if sprintModule.sprint_bar then sprintModule.sprint_bar.set(1);end end);end end end);end local function startStaminaSpam() spamConnection=spawn(function() while infiniteStaminaEnabled do wait(0.5);if (infiniteStaminaEnabled and player.Character) then local humanoid=player.Character:FindFirstChild("Humanoid");if (humanoid and (humanoid.MoveDirection.Magnitude>0.1)) then pcall(function() local sprintModule=require(game.ReplicatedStorage.Modules.Game.Sprint);if sprintModule.sprinting then sprintModule.sprinting.set(false);wait(0.05);sprintModule.sprinting.set(true);end end);end end end end);end local function stopInfiniteStamina() if connection then connection:Disconnect();connection=nil;end end local function setupCharacter() if infiniteStaminaEnabled then enableInfiniteStamina();end end if player.Character then setupCharacter();end player.CharacterAdded:Connect(function() wait(3);setupCharacter();end);local Toggle=Player:CreateToggle({Name="Infinite Stamina",Description="Never run out of stamina while sprinting",CurrentValue=false,Callback=function(Value) infiniteStaminaEnabled=Value;if infiniteStaminaEnabled then if player.Character then enableInfiniteStamina();end startStaminaSpam();else stopInfiniteStamina();end end},"InfiniteStaminaToggle");local ReplicatedStorage=game:GetService("ReplicatedStorage");local Players=game:GetService("Players");local player=Players.LocalPlayer;local scriptEnabled=false;local attributeMultipliers={accuracy=1,fireRate=1,magSize=1,range=1,recoil=1,reloadTime=1};local gunConfigs={G3={modifications={{original=0.65,target=1,type="accuracy"},{original=320,target=1000,type="fireRate"},{original=10,target=1000,type="magSize"},{original=80,target=1000,type="range"},{original=0.2,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},AK47={modifications={{original=0.85,target=1,type="accuracy"},{original=600,target=1000,type="fireRate"},{original=30,target=1000,type="magSize"},{original=300,target=1000,type="range"},{original=0.4,target=0,type="recoil"},{original=2.2,target=0,type="reloadTime"}}},Anaconda={modifications={{original=0.95,target=1,type="accuracy"},{original=80,target=1000,type="fireRate"},{original=6,target=1000,type="magSize"},{original=120,target=1000,type="range"},{original=0.8,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},C9={modifications={{original=0.7,target=1,type="accuracy"},{original=300,target=1000,type="fireRate"},{original=8,target=1000,type="magSize"},{original=80,target=1000,type="range"},{original=0.2,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},Crossbow={modifications={{original=0.95,target=1,type="accuracy"},{original=100,target=1000,type="fireRate"},{original=1,target=1000,type="magSize"},{original=500,target=1000,type="range"},{original=0.3,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},["Double Barrel"]={modifications={{original=0.5,target=1,type="accuracy"},{original=100,target=1000,type="fireRate"},{original=2,target=1000,type="magSize"},{original=50,target=1000,type="range"},{original=2,target=0,type="recoil"},{original=3,target=0,type="reloadTime"}}},Draco={modifications={{original=0.75,target=1,type="accuracy"},{original=900,target=1000,type="fireRate"},{original=25,target=1000,type="magSize"},{original=250,target=1000,type="range"},{original=0.5,target=0,type="recoil"},{original=2.2,target=0,type="reloadTime"}}},["Firework Launcher"]={modifications={{original=0.8,target=1,type="accuracy"},{original=100,target=1000,type="fireRate"},{original=1,target=1000,type="magSize"},{original=500,target=1000,type="range"},{original=1,target=0,type="recoil"},{original=0.9,target=0,type="reloadTime"}}},Glock={modifications={{original=0.8,target=1,type="accuracy"},{original=370,target=1000,type="fireRate"},{original=15,target=1000,type="magSize"},{original=80,target=1000,type="range"},{original=0.2,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},["Hunting Rifle"]={modifications={{original=0.93,target=1,type="accuracy"},{original=50,target=1000,type="fireRate"},{original=5,target=1000,type="magSize"},{original=500,target=1000,type="range"},{original=0.8,target=0,type="recoil"},{original=2.2,target=0,type="reloadTime"}}},M24={modifications={{original=0.97,target=1,type="accuracy"},{original=50,target=1000,type="fireRate"},{original=7,target=1000,type="magSize"},{original=500,target=1000,type="range"},{original=0.8,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},MP5={modifications={{original=0.85,target=1,type="accuracy"},{original=800,target=1000,type="fireRate"},{original=30,target=1000,type="magSize"},{original=200,target=1000,type="range"},{original=0.35,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},P226={modifications={{original=0.75,target=1,type="accuracy"},{original=370,target=1000,type="fireRate"},{original=7,target=1000,type="magSize"},{original=80,target=1000,type="range"},{original=0.25,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},RPG={modifications={{original=0.9,target=1,type="accuracy"},{original=100,target=1000,type="fireRate"},{original=1,target=1000,type="magSize"},{original=600,target=1000,type="range"},{original=2,target=0,type="recoil"},{original=2.6,target=0,type="reloadTime"}}},Remington={modifications={{original=0.6,target=1,type="accuracy"},{original=80,target=1000,type="fireRate"},{original=5,target=1000,type="magSize"},{original=80,target=1000,type="range"},{original=1.5,target=0,type="recoil"},{original=2,target=0,type="reloadTime"}}},Sawnoff={modifications={{original=0.4,target=1,type="accuracy"},{original=150,target=1000,type="fireRate"},{original=2,target=1000,type="magSize"},{original=30,target=1000,type="range"},{original=3,target=0,type="recoil"},{original=3,target=0,type="reloadTime"}}},Uzi={modifications={{original=0.7,target=1,type="accuracy"},{original=1200,target=1000,type="fireRate"},{original=20,target=1000,type="magSize"},{original=150,target=1000,type="range"},{original=0.3,target=0,type="recoil"},{original=1.7,target=0,type="reloadTime"}}}};local function RestoreGunAttributes(tool) if  not tool then return;end local gunConfig=gunConfigs[tool.Name];if  not gunConfig then return;end wait(0.1);local attributes=tool:GetAttributes();for _,modification in ipairs(gunConfig.modifications) do for attrName,attrValue in pairs(attributes) do if (type(attrValue)=="number") then if (math.abs(attrValue-(modification.target * attributeMultipliers[modification.type]) )<0.01) then tool:SetAttribute(attrName,modification.original);end end end end end local function ModifyGunAttributes(tool) if  not tool then return;end if  not scriptEnabled then return;end local gunConfig=gunConfigs[tool.Name];if  not gunConfig then return;end wait(0.1);local attributes=tool:GetAttributes();for _,modification in ipairs(gunConfig.modifications) do for attrName,attrValue in pairs(attributes) do if (type(attrValue)=="number") then if (math.abs(attrValue-modification.original )<0.01) then local targetValue=modification.target * attributeMultipliers[modification.type] ;tool:SetAttribute(attrName,targetValue);end end end end end local function ModifyExistingGuns() local character=player.Character;if  not character then return;end for _,item in pairs(character:GetChildren()) do if item:IsA("Tool") then ModifyGunAttributes(item);end end for _,item in pairs(player.Backpack:GetChildren()) do if item:IsA("Tool") then ModifyGunAttributes(item);end end end local function RestoreExistingGuns() local character=player.Character;if  not character then return;end for _,item in pairs(character:GetChildren()) do if item:IsA("Tool") then RestoreGunAttributes(item);end end for _,item in pairs(player.Backpack:GetChildren()) do if item:IsA("Tool") then RestoreGunAttributes(item);end end end player.Backpack.ChildAdded:Connect(function(newItem) if (newItem:IsA("Tool") and scriptEnabled) then ModifyGunAttributes(newItem);end end);player.CharacterAdded:Connect(function(character) character.ChildAdded:Connect(function(newItem) if (newItem:IsA("Tool") and scriptEnabled) then ModifyGunAttributes(newItem);end end);end);if player.Character then player.Character.ChildAdded:Connect(function(newItem) if (newItem:IsA("Tool") and scriptEnabled) then ModifyGunAttributes(newItem);end end);end local AccuracySlider=Weapon:CreateSlider({Name="Accuracy Multiplier",Range={0.1,1},Increment=0.1,CurrentValue=1,Callback=function(Value) attributeMultipliers.accuracy=Value;if scriptEnabled then ModifyExistingGuns();end end},"AccuracyMultiplierSlider");local FireRateSlider=Weapon:CreateSlider({Name="Fire Rate Multiplier",Range={1,1000},Increment=10,CurrentValue=1,Callback=function(Value) attributeMultipliers.fireRate=Value;if scriptEnabled then ModifyExistingGuns();end end},"FireRateMultiplierSlider");local MagSizeSlider=Weapon:CreateSlider({Name="Magazine Size Multiplier",Range={1,1000},Increment=10,CurrentValue=1,Callback=function(Value) attributeMultipliers.magSize=Value;if scriptEnabled then ModifyExistingGuns();end end},"MagSizeMultiplierSlider");local RangeSlider=Weapon:CreateSlider({Name="Range Multiplier",Range={1,1000},Increment=10,CurrentValue=1,Callback=function(Value) attributeMultipliers.range=Value;if scriptEnabled then ModifyExistingGuns();end end},"RangeMultiplierSlider");local RecoilSlider=Weapon:CreateSlider({Name="Recoil Multiplier",Range={0,2},Increment=0.1,CurrentValue=1,Callback=function(Value) attributeMultipliers.recoil=Value;if scriptEnabled then ModifyExistingGuns();end end},"RecoilMultiplierSlider");local ReloadTimeSlider=Weapon:CreateSlider({Name="Reload Time Multiplier",Range={0,2},Increment=0.1,CurrentValue=1,Callback=function(Value) attributeMultipliers.reloadTime=Value;if scriptEnabled then ModifyExistingGuns();end end},"ReloadTimeMultiplierSlider");local Toggle=Weapon:CreateToggle({Name="Gun Modifier",Description="Enable/Disable gun modifications",CurrentValue=false,Callback=function(Value) scriptEnabled=Value;if scriptEnabled then ModifyExistingGuns();else RestoreExistingGuns();end end},"GunModifierToggle");local Players=game:GetService("Players");local RunService=game:GetService("RunService");local LocalPlayer=Players.LocalPlayer;local isAutoRespawning=false;local autoRespawnEnabled=false;local connections={};local function clickRespawnButton() if (isAutoRespawning or  not autoRespawnEnabled) then return;end isAutoRespawning=true;pcall(function() local playerGui=LocalPlayer.PlayerGui;local deathScreen=playerGui:FindFirstChild("DeathScreen");if deathScreen then local deathScreenHolder=deathScreen:FindFirstChild("DeathScreenHolder");if deathScreenHolder then local frame=deathScreenHolder:FindFirstChild("Frame");if frame then local respawnButtonFrame=frame:FindFirstChild("RespawnButtonFrame");if respawnButtonFrame then local respawnButton=respawnButtonFrame:FindFirstChild("RespawnButton");if (respawnButton and respawnButton.Visible and respawnButton.Parent.Visible) then for _,connection in pairs(getconnections(respawnButton.MouseButton1Click)) do connection:Fire();end game:GetService("GuiService"):FireClick(respawnButton);local VirtualInputManager=game:GetService("VirtualInputManager");local buttonPos=respawnButton.AbsolutePosition;local buttonSize=respawnButton.AbsoluteSize;local centerX=buttonPos.X + (buttonSize.X/2) ;local centerY=buttonPos.Y + (buttonSize.Y/2) ;VirtualInputManager:SendMouseButtonEvent(centerX,centerY,0,true,game,1);VirtualInputManager:SendMouseButtonEvent(centerX,centerY,0,false,game,1);return true;end end end end end end);isAutoRespawning=false;return false;end local function startAutoRespawn() if connections.heartbeat then connections.heartbeat:Disconnect();end connections.heartbeat=RunService.Heartbeat:Connect(function() if  not autoRespawnEnabled then return;end if ((LocalPlayer.Character==nil) or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and (LocalPlayer.Character.Humanoid.Health<=0))) then local success=clickRespawnButton();if success then wait(2);end end end);end local function monitorDeathScreen() local playerGui=LocalPlayer:WaitForChild("PlayerGui");if connections.deathScreen then connections.deathScreen:Disconnect();end connections.deathScreen=playerGui.ChildAdded:Connect(function(child) if ((child.Name=="DeathScreen") and autoRespawnEnabled) then wait(0.1);local attempts=0;local maxAttempts=50;spawn(function() while (attempts<maxAttempts) and child.Parent and autoRespawnEnabled  do if clickRespawnButton() then break;end attempts=attempts + 1 ;wait(0.1);end end);end end);end local function setupDeathMonitoring() local function connectCharacterDeath(character) local humanoid=character:WaitForChild("Humanoid");local connection=humanoid.Died:Connect(function() if  not autoRespawnEnabled then return;end wait(0.5);spawn(function() for i=1,30 do if  not autoRespawnEnabled then break;end if clickRespawnButton() then break;end wait(0.1);end end);end);table.insert(connections,connection);end if connections.characterAdded then connections.characterAdded:Disconnect();end connections.characterAdded=LocalPlayer.CharacterAdded:Connect(connectCharacterDeath);if (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")) then connectCharacterDeath(LocalPlayer.Character);end end local function enableAutoRespawn() autoRespawnEnabled=true;monitorDeathScreen();setupDeathMonitoring();startAutoRespawn();end local function disableAutoRespawn() autoRespawnEnabled=false;for _,connection in pairs(connections) do if (connection and connection.Disconnect) then connection:Disconnect();end end connections={};end local AutoRespawnToggle=Player:CreateToggle({Name="Auto Respawn",Description="Automatically respawn when you die",CurrentValue=false,Callback=function(Value) if Value then enableAutoRespawn();else disableAutoRespawn();end end},"AutoRespawnToggle");local Workspace=game:GetService("Workspace");_G.AimbotConfig={LOCK_DISTANCE=10000,CAMERA_HEIGHT_OFFSET=0.5,FOV_RADIUS=200,SHOW_FOV_CIRCLE=true,WHITELIST={},WHITELISTED_PLAYERS={},AIMBOT_ENABLED=false,wasLeftControlDown=false};local camera=workspace.CurrentCamera;local currentTarget=nil;local fovCircle=nil;local function updatePlayerList() local names={};for _,p in pairs(Players:GetPlayers()) do if (p~=player) then table.insert(names,p.Name);end end return names;end local function cleanWhitelist() local current={};for _,p in pairs(Players:GetPlayers()) do current[p.Name]=true;end for name,_ in pairs(_G.AimbotConfig.WHITELIST) do if  not current[name] then _G.AimbotConfig.WHITELIST[name]=nil;end end end local function createDrawings() if fovCircle then fovCircle:Destroy();end fovCircle=Drawing.new("Circle");fovCircle.Radius=_G.AimbotConfig.FOV_RADIUS;fovCircle.Color=Color3.new(1,1,1);fovCircle.Transparency=0.5;fovCircle.Visible=false;fovCircle.Thickness=2;fovCircle.Position=Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 );end local function updateVisuals() if fovCircle then fovCircle.Visible=_G.AimbotConfig.SHOW_FOV_CIRCLE and _G.AimbotConfig.AIMBOT_ENABLED ;fovCircle.Position=Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 );end end local function isInFOV(target) local char=player.Character;if ( not char or  not target.Character) then return false;end local head=target.Character:FindFirstChild("Head");if  not head then return false;end local center=Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 );local screen=camera:WorldToScreenPoint(head.Position);local dist=(Vector2.new(screen.X,screen.Y) -center).Magnitude;return dist<=_G.AimbotConfig.FOV_RADIUS ;end local function isVisible(char) if ( not char or  not player.Character) then return false;end local head=char:FindFirstChild("Head");local root=player.Character:FindFirstChild("HumanoidRootPart");if ( not head or  not root) then return false;end local params=RaycastParams.new();params.FilterType=Enum.RaycastFilterType.Blacklist;params.FilterDescendantsInstances={player.Character};local result=Workspace:Raycast(root.Position,(head.Position-root.Position).Unit * _G.AimbotConfig.LOCK_DISTANCE ,params);return (result==nil) or result.Instance:IsDescendantOf(char) ;end local function findTarget() local char=player.Character;if  not char then return nil;end local root=char:FindFirstChild("HumanoidRootPart");if  not root then return nil;end local closest=nil;local shortest=_G.AimbotConfig.LOCK_DISTANCE;for _,p in pairs(Players:GetPlayers()) do if ((p~=player) and  not _G.AimbotConfig.WHITELIST[p.Name]) then local pChar=p.Character;local pRoot=pChar and pChar:FindFirstChild("HumanoidRootPart") ;if pRoot then local dist=(pRoot.Position-root.Position).Magnitude;if ((dist<shortest) and isVisible(pChar) and isInFOV(p)) then closest=p;shortest=dist;end end end end return closest;end local function aimNormal(target) currentTarget=target;local conn;conn=RunService.RenderStepped:Connect(function() if ( not _G.AimbotConfig.AIMBOT_ENABLED or  not userInputService:IsKeyDown(Enum.KeyCode.LeftControl) or  not currentTarget or  not currentTarget.Character or  not currentTarget.Character:FindFirstChild("Head")) then conn:Disconnect();currentTarget=nil;return;end local head=currentTarget.Character.Head;camera.CFrame=CFrame.new(camera.CFrame.Position,head.Position + Vector3.new(0,_G.AimbotConfig.CAMERA_HEIGHT_OFFSET,0) );end);end createDrawings();local AimbotToggle=Aimbot:CreateToggle({Name="Enable Aimbot",Description="Hold Left Control to activate aimbot",CurrentValue=false,Callback=function(Value) _G.AimbotConfig.AIMBOT_ENABLED=Value;if  not Value then currentTarget=nil;end end},"AimbotToggle");local FOVSlider=Aimbot:CreateSlider({Name="FOV Radius",Range={10,1000},Increment=10,CurrentValue=200,Callback=function(Value) _G.AimbotConfig.FOV_RADIUS=Value;if fovCircle then fovCircle.Radius=Value;end end},"FOVSlider");local FOVToggle=Aimbot:CreateToggle({Name="Show FOV Circle",Description="Toggle FOV circle visibility",CurrentValue=true,Callback=function(Value) _G.AimbotConfig.SHOW_FOV_CIRCLE=Value;end},"FOVToggle");local WhitelistDropdown=Aimbot:CreateDropdown({Name="Whitelist Players",Description="Select players to ignore when aiming",Options=updatePlayerList(),CurrentOption={},MultipleOptions=true,Callback=function(Options) _G.AimbotConfig.WHITELIST={};local opts=((type(Options)=="table") and Options) or {Options} ;for _,name in pairs(opts) do _G.AimbotConfig.WHITELIST[name]=true;end _G.AimbotConfig.WHITELISTED_PLAYERS=Options;end},"WhitelistDropdown");Players.PlayerAdded:Connect(function(p) wait(1);cleanWhitelist();end);Players.PlayerRemoving:Connect(function(p) if _G.AimbotConfig.WHITELIST[p.Name] then _G.AimbotConfig.WHITELIST[p.Name]=nil;end if (currentTarget==p) then currentTarget=nil;end cleanWhitelist();end);RunService.RenderStepped:Connect(function() local ctrl=userInputService:IsKeyDown(Enum.KeyCode.LeftControl);if _G.AimbotConfig.AIMBOT_ENABLED then if (ctrl and  not _G.AimbotConfig.wasLeftControlDown) then local target=findTarget();if target then aimNormal(target);end end _G.AimbotConfig.wasLeftControlDown=ctrl;end updateVisuals();end);userInputService.InputBegan:Connect(function(input,processed) if ( not processed and (input.KeyCode==Enum.KeyCode.O)) then _G.AimbotConfig.SHOW_FOV_CIRCLE= not _G.AimbotConfig.SHOW_FOV_CIRCLE;end end);local ReplicatedStorage=game:GetService("ReplicatedStorage");local Players=game:GetService("Players");local player=Players.LocalPlayer;local meleeWeapons={Axe={speed=1.4,range=6.5},["Barbed Baseball Bat"]={speed=1.6,range=7.5},["Baseball Bat"]={speed=1.6,range=7.5},["Bike Lock"]={speed=1.9,range=6},["Bronze Mop"]={speed=1.5,range=6.5},["Chair Leg"]={speed=1.6,range=6.5},["Butcher Knife"]={speed=1.6,range=6},["Combat Axe"]={speed=1.6,range=6.5},Crowbar={speed=1.6,range=7},["Diamond Mop"]={speed=1.5,range=6.5},["Frying Pan"]={speed=1.7,range=6.5},["Gold Mop"]={speed=1.5,range=6.5},Hammer={speed=1.75,range=6},Machette={speed=1.8,range=7.25},["Metal Baseball Bat"]={speed=1.6,range=7.5},["Metal Pipe"]={speed=1.55,range=6.5},Mop={speed=1.5,range=6.5},["Nailed Wooden Board"]={speed=1.4,range=6.5},["Pool Cue"]={speed=1.7,range=7.5},["Rolling Pin"]={speed=1.75,range=6.5},["Rusty Shovel"]={speed=1.2,range=7},Shank={speed=2,range=5.5},Shovel={speed=1.2,range=67.5},["Silver Mop"]={speed=1.5,range=6.5},["Sledge Hammer"]={speed=1.1,range=7.25},Switchblade={speed=2,range=5.5},["Tactical Axe"]={speed=1.75,range=6.5},["Tactical Knife"]={speed=2.2,range=5.75},["Tactical Shovel"]={speed=2,range=6.75},Taser={speed=2,range=5.25},["Tire Iron"]={speed=1.6,range=6.5},["Wooden Board"]={speed=1.45,range=6.5},Wrench={speed=1.5,range=6},Fists={speed=1,range=5}};local isEnabled=false;local customRange=50;local originalAttributes={};local function StoreOriginalAttributes(tool) if ( not tool or originalAttributes[tool]) then return;end local weaponData=meleeWeapons[tool.Name];if  not weaponData then return;end originalAttributes[tool]={};local attributes=tool:GetAttributes();for attrName,attrValue in pairs(attributes) do if (type(attrValue)=="number") then originalAttributes[tool][attrName]=attrValue;end end end local function ModifyMeleeAttributes(tool,shouldModify) if  not tool then return;end local weaponData=meleeWeapons[tool.Name];if  not weaponData then return;end wait(0.1);StoreOriginalAttributes(tool);if shouldModify then local attributes=tool:GetAttributes();for attrName,attrValue in pairs(attributes) do if (type(attrValue)=="number") then if (math.abs(attrValue-weaponData.speed )<0.01) then tool:SetAttribute(attrName,0);end if (math.abs(attrValue-weaponData.range )<0.01) then tool:SetAttribute(attrName,customRange);end end end elseif originalAttributes[tool] then for attrName,originalValue in pairs(originalAttributes[tool]) do tool:SetAttribute(attrName,originalValue);end end end local function ProcessExistingTools(shouldModify) local character=player.Character;if  not character then return;end for _,item in pairs(character:GetChildren()) do if item:IsA("Tool") then ModifyMeleeAttributes(item,shouldModify);end end for _,item in pairs(player.Backpack:GetChildren()) do if item:IsA("Tool") then ModifyMeleeAttributes(item,shouldModify);end end end local function HandleNewTool(newItem) if (newItem:IsA("Tool") and isEnabled) then ModifyMeleeAttributes(newItem,true);end end local function SetupBackpackMonitoring() player.Backpack.ChildAdded:Connect(HandleNewTool);end local function SetupCharacterMonitoring() player.CharacterAdded:Connect(function(character) character.ChildAdded:Connect(HandleNewTool);end);if player.Character then player.Character.ChildAdded:Connect(HandleNewTool);end end SetupBackpackMonitoring();SetupCharacterMonitoring();local Toggle=Combat:CreateToggle({Name="Melee Weapon Modifier",Description="Modifies melee weapon speed and range attributes",CurrentValue=false,Callback=function(Value) isEnabled=Value;if isEnabled then ProcessExistingTools(true);else ProcessExistingTools(false);end end},"MeleeModifier");local Slider=Combat:CreateSlider({Name="Weapon Range",Range={10,50},Increment=1,CurrentValue=50,Callback=function(Value) customRange=Value;if isEnabled then ProcessExistingTools(true);end end},"WeaponRange");_G.AutoFinish={e=false,d=10,whitelist={}};local function getPlayerNames() local names={};for _,p in pairs(game.Players:GetPlayers()) do if (p~=player) then table.insert(names,p.Name);end end return names;end local function cleanWhitelist() local currentPlayers={};for _,p in pairs(game.Players:GetPlayers()) do currentPlayers[p.Name]=true;end for playerName,_ in pairs(_G.AutoFinish.whitelist) do if  not currentPlayers[playerName] then _G.AutoFinish.whitelist[playerName]=nil;end end end if  not _G.AutoFinish.toggle then _G.AutoFinish.toggle=Combat:CreateToggle({Name="Auto Finish",Description="Finish downed players (except whitelisted)",CurrentValue=false,Callback=function(v) _G.AutoFinish.e=v;end},"AutoFinishToggle");end if  not _G.AutoFinish.slider then _G.AutoFinish.slider=Combat:CreateSlider({Name="Finish Distance",Range={1,20},Increment=1,CurrentValue=10,Callback=function(v) _G.AutoFinish.d=v;end},"AutoFinishDistance");end if  not _G.AutoFinish.dropdown then _G.AutoFinish.dropdown=Combat:CreateDropdown({Name="Whitelist Players",Description="Select players to NOT auto finish",Options=getPlayerNames(),CurrentOption={},MultipleOptions=true,SpecialType=nil,Callback=function(Options) _G.AutoFinish.whitelist={};local selectedPlayers=((type(Options)=="table") and Options) or {Options} ;for _,playerName in pairs(selectedPlayers) do _G.AutoFinish.whitelist[playerName]=true;end end},"AutoFinishWhitelist");end game.Players.PlayerAdded:Connect(function(newPlayer) end);game.Players.PlayerRemoving:Connect(function(leavingPlayer) if _G.AutoFinish.whitelist[leavingPlayer.Name] then _G.AutoFinish.whitelist[leavingPlayer.Name]=nil;end end);if  not _G.AutoFinish.running then _G.AutoFinish.running=true;spawn(function() while _G.AutoFinish.running do if ((tick()%30)<0.1) then cleanWhitelist();end if _G.AutoFinish.e then for _,v in ipairs(game.Players:GetPlayers()) do if ((v~=player) and  not _G.AutoFinish.whitelist[v.Name]) then local c=v.Character;if c then local h=c:FindFirstChild("HumanoidRootPart");if h then local p=h:FindFirstChild("FinishPrompt");if (p and p:IsA("ProximityPrompt")) then p.HoldDuration=0;p.MaxActivationDistance=_G.AutoFinish.d;pcall(function() p:InputHoldBegin();p:InputHoldEnd();end);end end end end end end task.wait(0.1);end end);end return {SetMaxDistance=function(d) _G.AutoFinish.slider:Set(math.max(1,math.min(20,d)));end,Stop=function() _G.AutoFinish.running=false;end,AddToWhitelist=function(playerName) _G.AutoFinish.whitelist[playerName]=true;end,RemoveFromWhitelist=function(playerName) _G.AutoFinish.whitelist[playerName]=nil;end,RefreshWhitelist=function() cleanWhitelist();end}; end
