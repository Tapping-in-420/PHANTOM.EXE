-- Load Luna UI Library
local Luna = loadstring(game:HttpGet("https://raw.githubusercontent.com/Nebula-Softworks/Luna-Interface-Suite/refs/heads/main/source.lua", true))()

---------------------------------------------------------------------------------------------
-- BASIC LOCALS & SERVICES (Reusable for other scripts)
---------------------------------------------------------------------------------------------

-- Player & Character
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Services
local pathfindingService = game:GetService("PathfindingService")
local tweenService = game:GetService("TweenService")
local runService = game:GetService("RunService")
local userInputService = game:GetService("UserInputService")

---------------------------------------------------------------------------------------------
-- UI WINDOW & TABS
---------------------------------------------------------------------------------------------

local Window = Luna:CreateWindow({
	Name = "Phantom.exe", -- This Is Title Of Your Window
	Subtitle = nil, -- A Gray Subtitle next To the main title.
	LogoID = "82795327169782", -- The Asset ID of your logo. Set to nil if you do not have a logo for Luna to use.
	LoadingEnabled = true, -- Whether to enable the loading animation. Set to false if you do not want the loading screen or have your own custom one.
	LoadingTitle = "Phantom.exe", -- Header for loading screen
	LoadingSubtitle = "By Phantom", -- Subtitle for loading screen

	ConfigSettings = {
		RootFolder = nil, -- The Root Folder Is Only If You Have A Hub With Multiple Game Scripts and u may remove it. DO NOT ADD A SLASH
		ConfigFolder = "Big Hub" -- The Name Of The Folder Where Luna Will Store Configs For This Script. DO NOT ADD A SLASH
	},

	KeySystem = false, -- As Of Beta 6, Luna Has officially Implemented A Key System!
	KeySettings = {
		Title = "Phantom Key.exe",
		Subtitle = "Key System",
		Note = "Best Key System Ever! Also, Please Use A HWID Keysystem like Pelican, Luarmor etc. that provide key strings based on your HWID since putting a simple string is very easy to bypass",
		SaveInRoot = true, -- Enabling will save the key in your RootFolder (YOU MUST HAVE ONE BEFORE ENABLING THIS OPTION)
		SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
		Key = {"Phantom"}, -- List of keys that will be accepted by the system, please use a system like Pelican or Luarmor that provide key strings based on your HWID since putting a simple string is very easy to bypass
		SecondAction = {
			Enabled = false, -- Set to false if you do not want a second action,
			Type = "Link", -- Link / Discord.
			Parameter = "" -- If Type is Discord, then put your invite link (DO NOT PUT DISCORD.GG/). Else, put the full link of your key system here.
		}
	}
})

-- Create Tabs
local Player = Window:CreateTab({
	Name = "Player",
	Icon = "person",
	ImageSource = "Material",
	ShowTitle = true
})

local Aimbot = Window:CreateTab({
	Name = "Aimbot",
	Icon = "gps_fixed",
	ImageSource = "Material",
	ShowTitle = true
})

local Visuals = Window:CreateTab({
	Name = "Visuals",
	Icon = "visibility",
	ImageSource = "Material",
	ShowTitle = true
})

local Combat = Window:CreateTab({
	Name = "Combat",
	Icon = "gavel",
	ImageSource = "Material",
	ShowTitle = true
})

local Weapon = Window:CreateTab({
	Name = "Weapon",
	Icon = "shield",
	ImageSource = "Material",
	ShowTitle = true
})

local Vehicle = Window:CreateTab({
	Name = "Vehicle",
	Icon = "directions_car",
	ImageSource = "Material",
	ShowTitle = true
})

local JobAutoFarm = Window:CreateTab({
	Name = "Job AutoFarm",
	Icon = "euro_symbol",
	ImageSource = "Material",
	ShowTitle = true
})


local Paragraph = JobAutoFarm:CreateParagraph({
	Title = "Job AutoFarm Info",
	Text = "BETA!"
})

---------------------------------------------------------------------------------------------
-- JOB AUTOFARM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management
local JobAutoFarm_State = {
    running = false,
    connections = {},
    currentTween = nil,
    location = Vector3.new(134.032, 255.467, 208.614)
}

-- Function to get current character references
local function getCharacterReferences()
    local char = player.Character
    if not char then return nil, nil, nil end
    
    return char, char:FindFirstChild("Humanoid"), char:FindFirstChild("HumanoidRootPart")
end

-- Function to wait for character to load
local function waitForCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid", 10)
    local root = char:WaitForChild("HumanoidRootPart", 10)
    
    if not hum or not root then
        warn("Failed to get character references")
        return nil, nil, nil
    end
    
    return char, hum, root
end

-- Function to clean up all connections and tweens
local function cleanup()
    print("Cleaning up auto farm script...")
    
    -- Cancel any active tween
    if JobAutoFarm_State.currentTween then
        JobAutoFarm_State.currentTween:Cancel()
        JobAutoFarm_State.currentTween = nil
    end
    
    -- Disconnect all connections
    for _, connection in pairs(JobAutoFarm_State.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    JobAutoFarm_State.connections = {}
    
    print("Auto farm script stopped and cleaned up.")
end

-- Function to handle character death
local function onCharacterDied()
    print("Character died. Waiting for respawn...")
    
    -- Don't stop the script, just wait for respawn
    if JobAutoFarm_State.running then
        print("Waiting for character to respawn...")
        local char, hum, root = waitForCharacter()
        
        if char and hum and root and JobAutoFarm_State.running then
            print("Character respawned! Continuing auto farm...")
            -- The main loop will continue automatically
        end
    end
end

-- Function to tween to a position with fixed Y at 255
local function tweenToPosition(position)
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print("No character found, waiting for respawn...")
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    -- Keep Y fixed at 255
    local fixedPosition = Vector3.new(position.X, 255, position.Z)
    local distance = (root.Position - fixedPosition).Magnitude
    
    JobAutoFarm_State.currentTween = game:GetService("TweenService"):Create(
        root, 
        TweenInfo.new(distance / 17, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
        {CFrame = CFrame.new(fixedPosition)}
    )
    JobAutoFarm_State.currentTween:Play()
    
    -- Create a connection to check if script is still running
    local completed = false
    local connection = JobAutoFarm_State.currentTween.Completed:Connect(function()
        completed = true
    end)
    
    -- Wait for tween to complete or script to stop
    local startTime = tick()
    local timeout = distance / 17 + 5 -- Add 5 seconds buffer
    
    while not completed and JobAutoFarm_State.running and (tick() - startTime) < timeout do
        wait(0.1)
    end
    
    connection:Disconnect()
    
    if not JobAutoFarm_State.running then
        if JobAutoFarm_State.currentTween then
            JobAutoFarm_State.currentTween:Cancel()
        end
        return false
    end
    
    JobAutoFarm_State.currentTween = nil
    return true
end

-- Function to follow path to a target position
local function followPathTo(targetPosition)
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print("No character found, waiting for respawn...")
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    -- First set Y position to 255
    root.CFrame = CFrame.new(root.Position.X, 255.3, root.Position.Z)
    wait(0.1)
    
    if not JobAutoFarm_State.running then return false end
    
    -- Create and compute path
    local path = game:GetService("PathfindingService"):CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true
    })
    
    local success, errorMessage = pcall(function()
        path:ComputeAsync(root.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success and JobAutoFarm_State.running then
        for i, waypoint in ipairs(path:GetWaypoints()) do
            if not JobAutoFarm_State.running then return false end
            
            -- Move to each waypoint with fixed Y
            if not tweenToPosition(waypoint.Position) then return false end
            
            -- If we've reached the final waypoint
            if i == #path:GetWaypoints() and JobAutoFarm_State.running then
                print("Reached destination!")
            end
        end
    else
        if not JobAutoFarm_State.running then return false end
        
        warn("Path computation failed:", errorMessage)
        
        -- If path computation fails, just tween directly to target with fixed Y
        print("Using direct tween to target instead...")
        if not tweenToPosition(targetPosition) then return false end
    end
    
    if not JobAutoFarm_State.running then return false end
    
    -- Make sure we're at the exact target position with Y=255
    local char, hum, root = getCharacterReferences()
    if root then
        root.CFrame = CFrame.new(targetPosition.X, 255, targetPosition.Z)
    end
    return true
end

-- Function to trigger the job UI initially
local function applyForJob()
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print("No character found, waiting for respawn...")
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    print("Triggering job application UI...")
    local touchPart = workspace.Map.Tiles.GasStationTile.Quick11.Interior.Quick11Beacon.TouchPart
    firetouchinterest(root, touchPart, 0)
    wait(0.1)
    firetouchinterest(root, touchPart, 1)
    print("Job UI triggered! Please click the Apply button manually.")
    
    -- Wait for you to manually click Apply
    print("Waiting for you to click the Apply button...")
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 8 do
        wait(0.1)
    end
    
    if not JobAutoFarm_State.running then return false end
    
    print("Continuing with shelf stocking work...")
    return true
end

-- Function to pick up a box
local function pickUpBox()
    if not JobAutoFarm_State.running then return false end
    
    print("Now firing proximity prompt for shelf stocking box...")
    
    -- Fire the proximity prompt
    fireproximityprompt(workspace.Map.Tiles.GasStationTile.Quick11.Interior.ShelfStockingJob.NormalBox.ProximityPrompt)
    print("Fired proximity prompt for the shelf stocking box!")
    
    -- Wait a moment for the box to be picked up
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 2 do
        wait(0.1)
    end
    
    return JobAutoFarm_State.running
end

-- Function to move to beacon and wait for delivery
local function moveToBeaconAndDeliver()
    if not JobAutoFarm_State.running then return false end
    
    print("Searching for beacon.base...")
    
    -- Find the beacon base
    local success, beaconBase = pcall(function()
        return workspace.Beacon.Base
    end)
    
    if not JobAutoFarm_State.running then return false end
    
    if not success or not beaconBase then
        print("Beacon.Base not found! Box may have already been delivered or there's an issue.")
        return false
    end
    
    print("Found Beacon.Base, moving to it now...")
    
    -- Move to the beacon position
    if not followPathTo(beaconBase.Position) then return false end
    
    print("Reached the beacon!")
    
    if not JobAutoFarm_State.running then return false end
    
    -- Wait for delivery to complete - beacon should disappear
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 10 do
        -- Check if beacon still exists
        local beaconStillExists = pcall(function()
            return workspace.Beacon.Base ~= nil
        end)
        
        if not beaconStillExists then
            print("Box successfully delivered! Beacon no longer exists.")
            return true
        end
        
        wait(0.5)
    end
    
    return JobAutoFarm_State.running
end

-- Main farming function
local function startAutoFarm()
    while JobAutoFarm_State.running do
        -- Wait for character if needed
        local char, hum, root = getCharacterReferences()
        if not char or not hum or not root then
            print("Waiting for character...")
            char, hum, root = waitForCharacter()
            if not char or not hum or not root or not JobAutoFarm_State.running then
                break
            end
        end
        
        -- Set up death detection for current character
        table.insert(JobAutoFarm_State.connections, hum.Died:Connect(onCharacterDied))
        
        -- First apply for the job
        if not followPathTo(JobAutoFarm_State.location) then 
            if JobAutoFarm_State.running then
                print("Failed to reach job location, retrying...")
                wait(2)
                continue
            else
                break
            end
        end
        
        if not applyForJob() then 
            if JobAutoFarm_State.running then
                print("Failed to apply for job, retrying...")
                wait(2)
                continue
            else
                break
            end
        end
        
        -- Now start the box stocking loop
        local boxCount = 0
        
        while JobAutoFarm_State.running do
            -- Check if character still exists
            local currentChar, currentHum, currentRoot = getCharacterReferences()
            if not currentChar or not currentHum or not currentRoot then
                print("Character lost, waiting for respawn...")
                break -- Break inner loop to restart with new character
            end
            
            print("--- Starting box #" .. (boxCount + 1) .. " ---")
            
            -- Go to job location to pick up a box
            print("Moving to box pickup location...")
            if not followPathTo(JobAutoFarm_State.location) then 
                if JobAutoFarm_State.running then
                    print("Failed to move to pickup location, retrying...")
                    wait(2)
                    continue
                else
                    break
                end
            end
            
            -- Pick up a box
            if pickUpBox() then
                boxCount = boxCount + 1
                print("Box #" .. boxCount .. " picked up successfully")
                
                -- Move to beacon and deliver
                if moveToBeaconAndDeliver() then
                    print("Box #" .. boxCount .. " delivered successfully!")
                else
                    if not JobAutoFarm_State.running then break end
                    print("Issue with delivery for box #" .. boxCount .. ", continuing anyway...")
                end
                
                -- Short wait before getting the next box
                if not JobAutoFarm_State.running then break end
                wait(1)
            else
                if not JobAutoFarm_State.running then break end
                print("Failed to pick up box, retrying...")
                wait(2)
            end
            
            if not JobAutoFarm_State.running then break end
            print("--- Completed cycle #" .. boxCount .. " ---")
        end
        
        -- If we get here and script is still running, character probably died
        if JobAutoFarm_State.running then
            print("Restarting due to character issue...")
            wait(1) -- Short wait before restarting
        end
    end
    
    print("Auto farm execution terminated.")
    cleanup()
end

-- Create Toggle
local Toggle = JobAutoFarm:CreateToggle({
	Name = "Quick-11 AutoFarm",
	Description = "",
	CurrentValue = false,
    Callback = function(Value)
        JobAutoFarm_State.running = Value
        
        if JobAutoFarm_State.running then
            print("Auto farm started!")
            -- Run the farm in a separate thread so it doesn't block
            spawn(function()
                startAutoFarm()
            end)
        else
            print("Auto farm stopped!")
            cleanup()
        end
    end
}, "Quick11Toggle")
---------------------------------------------------------------------------------------------
-- JANITOR AUTOFARM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for janitor
local JanitorFarm_State = {
    running = false,
    connections = {},
    currentTween = nil,
    yPositionMaintenance = false,
    targetPart = workspace.BurgePlaceBeacon.TouchPart,
    config = {
        fixedYPosition = 255.4,
        tweenSpeed = 0.3,
        waitTimePerPuddle = 5,
        loopWaitTime = 0
    }
}

-- Function to get current character references for janitor
local function getJanitorCharacterReferences()
    local char = player.Character
    if not char then return nil, nil, nil end
    
    return char, char:FindFirstChild("Humanoid"), char:FindFirstChild("HumanoidRootPart")
end

-- Function to wait for character to load for janitor
local function waitForJanitorCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid", 10)
    local root = char:WaitForChild("HumanoidRootPart", 10)
    
    if not hum or not root then
        warn("Failed to get janitor character references")
        return nil, nil, nil
    end
    
    return char, hum, root
end

-- Function to clean up janitor connections and tweens
local function janitorCleanup()
    print("Cleaning up janitor farm script...")
    
    -- Cancel any active tween
    if JanitorFarm_State.currentTween then
        JanitorFarm_State.currentTween:Cancel()
        JanitorFarm_State.currentTween = nil
    end
    
    -- Stop Y position maintenance
    JanitorFarm_State.yPositionMaintenance = false
    
    -- Disconnect all connections
    for _, connection in pairs(JanitorFarm_State.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    JanitorFarm_State.connections = {}
    
    print("Janitor farm script stopped and cleaned up.")
end

-- Function to handle character death for janitor
local function onJanitorCharacterDied()
    print("Character died. Waiting for respawn...")
    
    -- Don't stop the script, just wait for respawn
    if JanitorFarm_State.running then
        print("Waiting for character to respawn...")
        local char, hum, root = waitForJanitorCharacter()
        
        if char and hum and root and JanitorFarm_State.running then
            print("Character respawned! Continuing janitor farm...")
            -- The main loop will continue automatically
        end
    end
end

-- Function to find path and tween to location for janitor
local function moveToJanitorLocation(target)
    if not JanitorFarm_State.running then return false end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print("No character found, waiting for respawn...")
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    -- Create path
    local path = game:GetService("PathfindingService"):CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true
    })
    
    -- Get target position
    local targetPosition = typeof(target) == "Vector3" and target or target.Position
    
    -- Compute the path
    local success, errorMessage = pcall(function()
        path:ComputeAsync(root.Position, targetPosition)
    end)
    
    if not success then
        print("Failed to compute path:", errorMessage)
        return false
    end
    
    -- Move through each waypoint using tweens
    for i, waypoint in ipairs(path:GetWaypoints()) do
        if not JanitorFarm_State.running then return false end
        
        -- Check character references again
        local currentChar, currentHum, currentRoot = getJanitorCharacterReferences()
        if not currentRoot then
            print("Character lost during movement, waiting for respawn...")
            currentChar, currentHum, currentRoot = waitForJanitorCharacter()
            if not currentRoot or not JanitorFarm_State.running then return false end
        end
        
        -- Keep y-position fixed at specified height
        JanitorFarm_State.currentTween = game:GetService("TweenService"):Create(
            currentRoot,
            TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
            {CFrame = CFrame.new(Vector3.new(waypoint.Position.X, JanitorFarm_State.config.fixedYPosition, waypoint.Position.Z))}
        )
        JanitorFarm_State.currentTween:Play()
        
        -- Wait for completion or script stop
        local completed = false
        local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
            completed = true
        end)
        
        while not completed and JanitorFarm_State.running do
            wait(0.1)
        end
        
        connection:Disconnect()
        
        if not JanitorFarm_State.running then
            if JanitorFarm_State.currentTween then
                JanitorFarm_State.currentTween:Cancel()
            end
            return false
        end
    end
    
    if not JanitorFarm_State.running then return false end
    
    -- Get character references for final movement
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print("Character lost during final movement, waiting for respawn...")
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    -- Final tween to exact position (but still keeping y fixed)
    JanitorFarm_State.currentTween = game:GetService("TweenService"):Create(
        root,
        TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear),
        {CFrame = CFrame.new(Vector3.new(targetPosition.X, JanitorFarm_State.config.fixedYPosition, targetPosition.Z))}
    )
    JanitorFarm_State.currentTween:Play()
    
    local completed = false
    local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
        completed = true
    end)
    
    while not completed and JanitorFarm_State.running do
        wait(0.1)
    end
    
    connection:Disconnect()
    
    if not JanitorFarm_State.running then
        if JanitorFarm_State.currentTween then
            JanitorFarm_State.currentTween:Cancel()
        end
        return false
    end
    
    JanitorFarm_State.currentTween = nil
    print("Reached destination")
    return true
end

-- Function to fire touch transmitters for janitor
local function fireJanitorTouch()
    if not JanitorFarm_State.running then return false end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print("No character found for touch interaction, waiting for respawn...")
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    local touchInterest = JanitorFarm_State.targetPart:FindFirstChild("TouchInterest")
    if touchInterest then
        firetouchinterest(root, JanitorFarm_State.targetPart, 0) -- Begin touch
        wait(0.1)
        firetouchinterest(root, JanitorFarm_State.targetPart, 1) -- End touch
        print("Fired touch event")
        return true
    else
        print("TouchInterest not found")
        return false
    end
end

-- Function to click the green Apply button for janitor
local function clickJanitorApplyButton()
    if not JanitorFarm_State.running then return false end
    
    print("Looking for Apply button...")
    wait(1) -- Wait for dialog to appear
    
    if not JanitorFarm_State.running then return false end
    
    -- Find all TextLabels with "Apply to Janitor job" text
    for _, gui in pairs(player.PlayerGui:GetChildren()) do
        if gui:IsA("ScreenGui") then
            -- Search for the text "Apply to Janitor job?"
            for _, desc in pairs(gui:GetDescendants()) do
                if desc:IsA("TextLabel") and string.find(desc.Text, "Apply to Janitor") then
                    print("Found job dialog with text: " .. desc.Text)
                    
                    -- Look for the green Apply button (should be a TextButton with "Apply" text)
                    for _, buttonDesc in pairs(desc.Parent:GetDescendants()) do
                        if buttonDesc:IsA("TextButton") and buttonDesc.Text == "Apply" then
                            print("Found Apply button!")
                            
                            -- Try multiple methods to click the button
                            local clicked = false
                            
                            -- Method 1: Fire MouseButton1Click directly
                            pcall(function()
                                buttonDesc.MouseButton1Click:Fire()
                                clicked = true
                                print("Method 1: Direct MouseButton1Click fire succeeded")
                            end)
                            
                            wait(0.2)
                            
                            -- Method 2: Using getconnections
                            if not clicked then
                                pcall(function()
                                    for _, connection in pairs(getconnections(buttonDesc.MouseButton1Click)) do
                                        connection:Fire()
                                        clicked = true
                                        print("Method 2: getconnections fire succeeded")
                                        break
                                    end
                                end)
                            end
                            
                            if clicked then
                                print("Successfully clicked Apply button!")
                                return true
                            end
                        end
                    end
                    break
                end
            end
        end
    end
    
    print("Could not find Apply button in any GUI")
    return false
end

-- Function to maintain Y position for janitor
local function maintainJanitorYPosition()
    JanitorFarm_State.yPositionMaintenance = true
    
    -- Create a loop that constantly sets the Y position
    spawn(function()
        while JanitorFarm_State.yPositionMaintenance and JanitorFarm_State.running do
            local char, hum, root = getJanitorCharacterReferences()
            if root then
                local currentPos = root.Position
                if currentPos.Y ~= JanitorFarm_State.config.fixedYPosition then
                    root.CFrame = CFrame.new(currentPos.X, JanitorFarm_State.config.fixedYPosition, currentPos.Z)
                end
            end
            wait(0.1)
        end
    end)
end

-- Function to get all puddle locations and sort them by distance
local function getPuddlesInOrder()
    if not JanitorFarm_State.running then return {} end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then return {} end
    
    -- Find all puddles in the container
    local puddlesContainer = workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace.Interior.Puddles
    
    print("Searching for small puddles only...")
    
    -- Create a table to hold small puddles
    local puddles = {}
    
    -- Add the specifically named SmallPuddle if it exists
    local smallPuddle = puddlesContainer:FindFirstChild("SmallPuddle")
    if smallPuddle then
        table.insert(puddles, smallPuddle)
        print("Found named SmallPuddle")
    end
    
    -- Look through all puddles and find any with "Small" in the name
    for _, puddle in pairs(puddlesContainer:GetChildren()) do
        -- Check if the puddle has "Small" in its name and isn't already in our list
        if puddle and puddle.Name:find("Small") and puddle ~= smallPuddle then
            table.insert(puddles, puddle)
            print("Found puddle with Small in name: " .. puddle.Name)
        end
    end
    
    -- Filter out nil entries and explicitly exclude puddles at indices 4 and 5
    local validPuddles = {}
    for _, puddle in pairs(puddles) do
        if puddle then
            -- Check if this puddle is one of the ones we want to exclude
            local isExcluded = false
            local allChildren = puddlesContainer:GetChildren()
            for i, child in pairs(allChildren) do
                if child == puddle and (i == 4 or i == 5) then
                    isExcluded = true
                    print("Excluding puddle at index " .. i)
                    break
                end
            end
            
            -- Only add if not excluded
            if not isExcluded then
                table.insert(validPuddles, puddle)
            end
        end
    end
    
    -- Sort by distance (closest first)
    table.sort(validPuddles, function(a, b)
        return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
    end)
    
    return validPuddles
end

-- Function to clean a puddle
local function cleanPuddle(puddle)
    if not JanitorFarm_State.running then return false end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print("No character found for puddle cleaning, waiting for respawn...")
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    print("Cleaning puddle: " .. puddle.Name)
    print("Cleaning a small puddle: " .. puddle.Name)
    
    -- Try to find TouchInterest in the puddle
    local touchInterest = puddle:FindFirstChild("TouchInterest")
    if touchInterest then
        print("Touching puddle to start cleaning...")
        firetouchinterest(root, puddle, 0) -- Begin touch
        
        -- Wait for cleaning to complete
        print("Waiting " .. JanitorFarm_State.config.waitTimePerPuddle .. " seconds to clean puddle...")
        local startTime = tick()
        while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
            wait(0.1)
        end
        
        if not JanitorFarm_State.running then return false end
        
        firetouchinterest(root, puddle, 1) -- End touch
        print("Puddle cleaning completed")
        return true
    else
        -- If no TouchInterest, try to find a ProximityPrompt or other interaction
        local proximityPrompt = puddle:FindFirstChild("ProximityPrompt")
        if proximityPrompt then
            print("Activating proximity prompt on puddle...")
            fireproximityprompt(proximityPrompt)
            
            -- Wait for cleaning to complete
            local startTime = tick()
            while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
                wait(0.1)
            end
            
            if not JanitorFarm_State.running then return false end
            
            print("Puddle cleaning completed")
            return true
        else
            -- If no direct interaction method found, just wait at the puddle
            print("No direct interaction method found, waiting at puddle...")
            local startTime = tick()
            while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
                wait(0.1)
            end
            
            if not JanitorFarm_State.running then return false end
            
            print("Puddle cleaning completed")
            return true
        end
    end
    
    return false
end

-- Function to visit all puddles in a continuous loop
local function visitAllPuddlesLoop()
    print("Starting continuous puddle cleaning loop...")
    
    -- Run while script is enabled
    while JanitorFarm_State.running do
        -- Check character references
        local char, hum, root = getJanitorCharacterReferences()
        if not char or not hum or not root then
            print("Character lost during puddle loop, waiting for respawn...")
            char, hum, root = waitForJanitorCharacter()
            if not char or not hum or not root or not JanitorFarm_State.running then
                break
            end
        end
        
        -- Get puddles sorted by distance (recalculated each loop)
        local sortedPuddles = getPuddlesInOrder()
        print("Found " .. #sortedPuddles .. " puddles to visit")
        
        -- If no puddles found, wait a bit and try again
        if #sortedPuddles == 0 then
            if not JanitorFarm_State.running then break end
            print("No puddles found, waiting before retrying...")
            local startTime = tick()
            while JanitorFarm_State.running and (tick() - startTime) < (JanitorFarm_State.config.loopWaitTime * 2) do
                wait(0.1)
            end
        else
            -- Visit each puddle
            for i, puddle in ipairs(sortedPuddles) do
                if not JanitorFarm_State.running then break end
                
                -- Check character references before each puddle
                local currentChar, currentHum, currentRoot = getJanitorCharacterReferences()
                if not currentChar or not currentHum or not currentRoot then
                    print("Character lost before puddle " .. i .. ", breaking loop...")
                    break
                end
                
                print("Moving to puddle " .. i .. "/" .. #sortedPuddles .. " - " .. puddle.Name)
                
                -- Move to the puddle
                if moveToJanitorLocation(puddle.Position) then
                    if not JanitorFarm_State.running then break end
                    
                    cleanPuddle(puddle)
                    
                    if not JanitorFarm_State.running then break end
                    
                    -- Short wait between puddles
                    local startTime = tick()
                    while JanitorFarm_State.running and (tick() - startTime) < 0.5 do
                        wait(0.1)
                    end
                else
                    print("Failed to reach puddle " .. i)
                    -- If movement failed, might be character issue - break to restart
                    break
                end
            end
            
            if not JanitorFarm_State.running then break end
            
            print("Completed one cleaning cycle, waiting before starting the next cycle...")
            local startTime = tick()
            while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.loopWaitTime do
                wait(0.1)
            end
        end
    end
end

-- Main janitor farming function
local function startJanitorFarm()
    while JanitorFarm_State.running do
        -- Wait for character if needed
        local char, hum, root = getJanitorCharacterReferences()
        if not char or not hum or not root then
            print("Waiting for character...")
            char, hum, root = waitForJanitorCharacter()
            if not char or not hum or not root or not JanitorFarm_State.running then
                break
            end
        end
        
        -- Set up death detection for current character
        table.insert(JanitorFarm_State.connections, hum.Died:Connect(onJanitorCharacterDied))
        
        print("Starting janitor job application sequence")
        print("- Fixed Y position: " .. JanitorFarm_State.config.fixedYPosition)
        print("- Tween speed: " .. JanitorFarm_State.config.tweenSpeed .. " (lower = faster)")
        print("- Base wait time per puddle: " .. JanitorFarm_State.config.waitTimePerPuddle .. " seconds")
        print("- Loop wait time: " .. JanitorFarm_State.config.loopWaitTime .. " seconds")
        print("- CLEANING SMALL PUDDLES ONLY")
        
        -- Start the Y position maintenance
        maintainJanitorYPosition()
        
        -- Step 1: Move to the target location
        if moveToJanitorLocation(JanitorFarm_State.targetPart) and JanitorFarm_State.running then
            -- Step 2: Fire touch transmitters
            if fireJanitorTouch() and JanitorFarm_State.running then
                -- Wait a moment for the dialog to appear
                local startTime = tick()
                while JanitorFarm_State.running and (tick() - startTime) < 1.5 do
                    wait(0.1)
                end
                
                if not JanitorFarm_State.running then break end
                
                -- Step 3: Click Apply button
                if clickJanitorApplyButton() and JanitorFarm_State.running then
                    print("Successfully applied for janitor job!")
                    
                    -- Wait a moment for job to be applied
                    local startTime = tick()
                    while JanitorFarm_State.running and (tick() - startTime) < 2 do
                        wait(0.1)
                    end
                    
                    if not JanitorFarm_State.running then break end
                    
                    -- Step 4: Start continuous puddle cleaning loop
                    visitAllPuddlesLoop()
                else
                    if not JanitorFarm_State.running then break end
                    
                    print("Failed to click Apply button. Trying to start puddle cleaning anyway...")
                    
                    -- Wait and try to start puddle cleaning loop anyway
                    local startTime = tick()
                    while JanitorFarm_State.running and (tick() - startTime) < 2 do
                        wait(0.1)
                    end
                    
                    if JanitorFarm_State.running then
                        visitAllPuddlesLoop()
                    end
                end
            else
                print("Failed to interact with the TouchPart, retrying...")
                if JanitorFarm_State.running then
                    wait(2)
                    continue
                end
            end
        else
            print("Failed to reach target location, retrying...")
            if JanitorFarm_State.running then
                wait(2)
                continue
            end
        end
        
        -- If we get here and script is still running, character probably died
        if JanitorFarm_State.running then
            print("Restarting due to character issue...")
            wait(1) -- Short wait before restarting
        end
    end
    
    janitorCleanup()
end

-- Create Janitor Toggle
local JanitorToggle = JobAutoFarm:CreateToggle({
	Name = "Burger Place AutoFarm",
	Description = "",
	CurrentValue = false,
    Callback = function(Value)
        JanitorFarm_State.running = Value
        
        if JanitorFarm_State.running then
            print("Janitor farm started!")
            -- Run the farm in a separate thread so it doesn't block
            spawn(function()
                startJanitorFarm()
            end)
        else
            print("Janitor farm stopped!")
            janitorCleanup()
        end
    end
}, "JanitorToggle")
-------------------------
--autocook
-------------------------
-- Optimized Steakhouse Auto Farm Script
-- Consolidated state management for maximum efficiency

-- Consolidated state management for steakhouse
local SteakhouseFarm_State = {
    enabled = false,
    autoMovement = false,
    steaksCookedCounter = 0,
    isRunning = false,
    connections = {},
    config = {
        tweenSpeed = 28,
        waitBetweenActions = 0.0,
        steakhouseBeacon = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.SteakHouseBeacon.TouchPart,
        fridgeArea = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge.Area,
        fridge = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge
    }
}

-- Initialize player references and Net module
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local hrp = character:WaitForChild("HumanoidRootPart")

-- Net module detection (exact from working script)
local Net = nil
if _G.NetBypass and _G.NetBypass.Net then
    Net = _G.NetBypass.Net
elseif _G.Net then
    Net = _G.Net
else
    local success, netModule = pcall(function()
        return require(game.ReplicatedStorage.Modules.Core.Net)
    end)
    if success and netModule then
        Net = netModule
    end
end

-- Precise timing function (exact from working script)
local function isPerfectMoment(barAmount, cookedPerfectly)
    local currentPosition = barAmount.Size.X.Scale
    local perfectStart = cookedPerfectly.Position.X.Scale
    local perfectEnd = perfectStart + cookedPerfectly.Size.X.Scale
    
    return currentPosition >= (perfectStart + 0.01) and 
           currentPosition <= (perfectEnd - 0.01)
end

-- Enhanced Auto Cook Function with Stealth Net Bypass (exact from working script)
local function autoCookSteak()
    -- Find current grill
    local currentGrill = nil
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj:FindFirstChild("GrillArea") then
            currentGrill = obj
            break
        end
    end
    
    -- Find progress bar frame
    local progressBarFrame = nil
    for _, gui in pairs(player.PlayerGui:GetChildren()) do
        if gui:IsA("ScreenGui") then
            local found = gui:FindFirstChild("ProgressBarFrame")
            if found and found.Visible then
                progressBarFrame = found
                break
            end
        end
    end
    
    if not progressBarFrame or not currentGrill then 
        return false 
    end
    
    local mainFrame = progressBarFrame:FindFirstChild("MainFrame")
    local inputFrame = progressBarFrame:FindFirstChild("InputFrame")
    
    if not mainFrame or not inputFrame then 
        return false 
    end
    
    local barAmount = mainFrame:FindFirstChild("BarAmount")
    local cookedPerfectly = mainFrame:FindFirstChild("CookedPerfectly")
    
    if not barAmount or not cookedPerfectly then 
        return false 
    end
    
    -- Check if in perfect moment
    if isPerfectMoment(barAmount, cookedPerfectly) then
        -- STEALTH METHOD: Use Net bypass with proper filtering check
        if Net and _G.NetBypass then
            local stealthEvents = {"cooking_complete", "finish_cooking", "job_task_complete"}
            
            for _, eventName in pairs(stealthEvents) do
                if _G.NetBypass.allowEvent then
                    _G.NetBypass.allowEvent(eventName)
                end
            end
            
            pcall(function()
                wait(math.random(50, 150) / 1000)
                Net.send("cooking_complete", {
                    perfect = true,
                    grill = currentGrill,
                    timestamp = tick()
                })
                
                wait(math.random(30, 80) / 1000)
                Net.send("job_task_complete", "steakhouse_cook", {
                    result = "perfect",
                    completion_time = tick()
                })
            end)
        end
        
        -- Complete the visual/client-side
        wait(math.random(100, 200) / 1000)
        
        local completionMethods = {
            function()
                local cookModule = require(game.ReplicatedStorage.Modules.Game.Cooking)
                if cookModule and cookModule.force_complete then
                    pcall(function()
                        cookModule.force_complete(currentGrill)
                    end)
                end
            end,
            function()
                local finishBar = inputFrame:FindFirstChild("FinishBar")
                if finishBar then
                    for _, connection in pairs(getconnections(finishBar.MouseButton1Click)) do
                        pcall(function() 
                            connection:Fire() 
                        end)
                    end
                end
            end
        }
        
        for i, method in ipairs(completionMethods) do
            pcall(method)
        end
        
        SteakhouseFarm_State.steaksCookedCounter = SteakhouseFarm_State.steaksCookedCounter + 1
        wait(math.random(500, 1000) / 1000)
        return true
    end
    
    return false
end

-- Helper function to wait for character respawn
local function waitForRespawn()
    if not character or not character:FindFirstChild("Humanoid") then
        character = player.CharacterAdded:Wait()
        humanoid = character:WaitForChild("Humanoid")
        hrp = character:WaitForChild("HumanoidRootPart")
    end
end

-- Movement function
local function moveToPosition(targetPosition)
    waitForRespawn()
    
    local path = game:GetService("PathfindingService"):CreatePath({
        AgentCanJump = true,
        AgentHeight = 5,
        AgentRadius = 2,
        WaypointSpacing = 4
    })
    
    local success, errorMessage = pcall(function()
        local fixedYPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
        path:ComputeAsync(hrp.Position, fixedYPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        
        for i, waypoint in ipairs(waypoints) do
            if not SteakhouseFarm_State.autoMovement then return false end
            
            waitForRespawn()
            
            local waypointPosition = Vector3.new(waypoint.Position.X, 255, waypoint.Position.Z)
            
            local tweenInfo = TweenInfo.new(
                (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - 
                Vector3.new(waypointPosition.X, 0, waypointPosition.Z)).Magnitude / SteakhouseFarm_State.config.tweenSpeed,
                Enum.EasingStyle.Linear
            )
            
            local tween = game:GetService("TweenService"):Create(hrp, tweenInfo, {
                CFrame = CFrame.new(waypointPosition)
            })
            
            tween:Play()
            
            local connection
            connection = game:GetService("RunService").Heartbeat:Connect(function()
                if not SteakhouseFarm_State.autoMovement then
                    tween:Cancel()
                    connection:Disconnect()
                end
            end)
            
            tween.Completed:Wait()
            connection:Disconnect()
            
            if not SteakhouseFarm_State.autoMovement then return false end
            wait(0.1)
        end
        return true
    else
        warn("Path computation failed:", errorMessage)
        local fixedPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
        humanoid:MoveTo(fixedPosition)
        
        local reachedDestination = false
        local startTime = tick()
        while not reachedDestination and SteakhouseFarm_State.autoMovement and (tick() - startTime) < 10 do
            if (hrp.Position - fixedPosition).Magnitude < 5 then
                reachedDestination = true
            end
            wait(0.1)
        end
        
        return reachedDestination and SteakhouseFarm_State.autoMovement
    end
end

-- Fridge interaction function
local function interactWithFridge()
    waitForRespawn()
    
    local fridgeAreaPosition = SteakhouseFarm_State.config.fridgeArea.Position
    local targetPosition = Vector3.new(fridgeAreaPosition.X, 255, fridgeAreaPosition.Z)
    local moveSuccess = moveToPosition(targetPosition)
    
    if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
    
    wait(1)
    if not SteakhouseFarm_State.autoMovement then return false end
    
    hrp.CFrame = CFrame.new(hrp.Position, 
        Vector3.new(fridgeAreaPosition.X, hrp.Position.Y, fridgeAreaPosition.Z))
    
    wait(1.5)
    if not SteakhouseFarm_State.autoMovement then return false end
    
    local maxAttempts = 5
    for attempt = 1, maxAttempts do
        if not SteakhouseFarm_State.autoMovement then return false end
        
        local proximityPrompt = nil
        
        for i, child in pairs(SteakhouseFarm_State.config.fridge:GetChildren()) do
            if i == 4 and child:FindFirstChild("Attachment") then
                proximityPrompt = child.Attachment:FindFirstChild("ProximityPrompt")
                if proximityPrompt then break end
            end
        end
        
        if not proximityPrompt then
            for _, child in pairs(SteakhouseFarm_State.config.fridge:GetDescendants()) do
                if child:IsA("ProximityPrompt") then
                    proximityPrompt = child
                    break
                end
            end
        end
        
        if proximityPrompt then
            local promptParent = proximityPrompt.Parent
            if promptParent and promptParent:IsA("BasePart") then
                hrp.CFrame = CFrame.new(promptParent.Position + Vector3.new(0, 2, 0))
            elseif promptParent and promptParent:IsA("Attachment") and promptParent.Parent:IsA("BasePart") then
                hrp.CFrame = CFrame.new(promptParent.Parent.Position + Vector3.new(0, 2, 0))
            end
            
            if not SteakhouseFarm_State.autoMovement then return false end
            
            fireproximityprompt(proximityPrompt)
            
            local waitTime = 3
            local startTime = tick()
            while SteakhouseFarm_State.autoMovement and (tick() - startTime) < waitTime do
                wait(0.1)
            end
            
            if not SteakhouseFarm_State.autoMovement then return false end
            
            return true
        end
        
        if attempt < maxAttempts and SteakhouseFarm_State.autoMovement then
            local offsetPosition = targetPosition + Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
            hrp.CFrame = CFrame.new(offsetPosition)
            if not SteakhouseFarm_State.autoMovement then return false end
            wait(1)
        end
    end
    
    return false
end

-- Beacon finding and movement function
local function findAndMoveToBeacon()
    waitForRespawn()
    
    local startTime = tick()
    local timeout = 10
    local beaconFound = false
    local targetBeacon = nil
    
    while not beaconFound and SteakhouseFarm_State.autoMovement and (tick() - startTime) < timeout do
        if workspace:FindFirstChild("Beacon") and workspace.Beacon:FindFirstChild("Base") then
            targetBeacon = workspace.Beacon.Base
            beaconFound = true
            break
        end
        wait(0.5)
    end
    
    if not beaconFound or not targetBeacon then
        return false
    end
    
    if not SteakhouseFarm_State.autoMovement then return false end
    
    local beaconPosition = targetBeacon.Position
    
    local moveSuccess = moveToPosition(beaconPosition)
    
    if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
    
    return true
end

-- Main auto farm cleanup function
local function steakhouseCleanup()
    SteakhouseFarm_State.enabled = false
    SteakhouseFarm_State.autoMovement = false
    
    for _, connection in pairs(SteakhouseFarm_State.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    SteakhouseFarm_State.connections = {}
end

-- LUNA TOGGLE SYSTEM INTEGRATION
local SteakhouseFarmToggle = JobAutoFarm:CreateToggle({
    Name = "Steakhouse Auto Farm",
    Description = "",
    CurrentValue = false,
    Callback = function(Value)
        SteakhouseFarm_State.enabled = Value
        SteakhouseFarm_State.autoMovement = Value
        
        if not Value then
            steakhouseCleanup()
        end
    end
}, "SteakhouseFarmToggle")

-- Auto Movement Loop
if not SteakhouseFarm_State.isRunning then
    SteakhouseFarm_State.isRunning = true
    
    -- Movement loop
    task.spawn(function()
        while SteakhouseFarm_State.isRunning do
            if SteakhouseFarm_State.autoMovement then
                pcall(function()
                    local fridgeSuccess = interactWithFridge()
                    
                    if not fridgeSuccess or not SteakhouseFarm_State.autoMovement then
                        wait(3)
                        return
                    end
                    
                    if not SteakhouseFarm_State.autoMovement then return end
                    wait(SteakhouseFarm_State.config.waitBetweenActions)
                    
                    local beaconSuccess = findAndMoveToBeacon()
                    
                    if not beaconSuccess or not SteakhouseFarm_State.autoMovement then
                        wait(3)
                        return
                    end
                    
                    if not SteakhouseFarm_State.autoMovement then return end
                    
                    local cookingStart = tick()
                    local cookingTimeout = 20
                    local cookingCompleted = false
                    
                    while SteakhouseFarm_State.autoMovement and (tick() - cookingStart) < cookingTimeout do
                        local progressBarFrame = nil
                        for _, gui in pairs(player.PlayerGui:GetChildren()) do
                            if gui:IsA("ScreenGui") then
                                local found = gui:FindFirstChild("ProgressBarFrame")
                                if found and found.Visible then
                                    progressBarFrame = found
                                    break
                                end
                            end
                        end
                        
                        if progressBarFrame then
                            while progressBarFrame and progressBarFrame.Visible and SteakhouseFarm_State.autoMovement do
                                wait(0.1)
                            end
                            cookingCompleted = true
                            break
                        end
                        
                        wait(0.5)
                    end
                    
                    if cookingCompleted then
                        wait(2)
                    else
                        wait(5)
                    end
                end)
            end
            
            wait(1)
        end
    end)
    
    -- Auto-cook loop (exact from working script)
    task.spawn(function()
        while SteakhouseFarm_State.isRunning do
            task.wait(0.01)
            
            if SteakhouseFarm_State.enabled then
                local success, result = pcall(autoCookSteak)
                if not success then
                    warn("Error in auto cooking: " .. tostring(result))
                end
            end
        end
    end)
end

--------------------------------------------------------------------------------------------
JobAutoFarm:CreateDivider()
---------------------------------------------------------------------------------------------
-- ATM HACK SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for ATM hack
local ATMHack_State = {
    running = false,
    loop = nil,
    SliderMinigame = require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame)
}

-- Override the needle position calculation
local function modifiedNeedlePositionCalculation()
    -- Increase speed multiplier (from 0.65 to 2)
    local v23 = tick() * 2 % 3;
    
    -- Expand range from [0, 1] to [-0.5, 1.5]
    if v23 > 1.5 then
        v23 = 3 - v23;
    elseif v23 < -0.5 then
        v23 = -v23 - 0.5;
    end
    
    ATMHack_State.SliderMinigame.needle_pos.set(v23)
end

-- Function to check if needle is in target zone
local function isNeedleInTargetZone()
    local needlePos = ATMHack_State.SliderMinigame.needle_pos.get()
    local targetPos = ATMHack_State.SliderMinigame.target_pos.get()
    local targetSize = ATMHack_State.SliderMinigame.target_size.get()
    
    -- Expand target zone slightly for more success
    local lowerBound = targetPos - (targetSize / 2) - 0.1
    local upperBound = targetPos + (targetSize / 2) + 0.1
    
    -- Check if needle is within the expanded target zone
    return needlePos >= lowerBound and needlePos <= upperBound
end

-- Function to simulate a click when in target zone
local function autoClickIfInTargetZone()
    if isNeedleInTargetZone() then
        -- Simulate clicking
        local currentLevel = ATMHack_State.SliderMinigame.level.get()
        ATMHack_State.SliderMinigame.level.set(currentLevel + 1)
        
        -- Minimal audio feedback
        require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame.play_audio)(
            "3450794184", 
            0.1, 
            (math.min(2, 1.25 + 0.25 * currentLevel))
        )
    end
end

-- Main auto-win loop
local function autoWinATMHack()
    -- Ensure the minigame is enabled
    if not ATMHack_State.SliderMinigame.enabled.get() then return end
    
    -- Modify needle position calculation
    modifiedNeedlePositionCalculation()
    
    -- Try to click in target zone multiple times
    for _ = 1, 3 do
        autoClickIfInTargetZone()
    end
    
    -- Check if we've reached target levels
    if ATMHack_State.SliderMinigame.level.get() >= ATMHack_State.SliderMinigame.levels.get() then
        ATMHack_State.SliderMinigame.win:Fire(true)
    end
end

-- ATM Hack cleanup function
local function atmHackCleanup()
    print("Cleaning up ATM hack script...")
    ATMHack_State.running = false
    if ATMHack_State.loop then
        ATMHack_State.loop = nil
    end
    print("ATM hack script stopped and cleaned up.")
end

-- Start ATM hack function
local function startATMHack()
    print("ATM Hack started! The script will automatically win ATM minigames.")
    
    -- Main loop
    ATMHack_State.loop = task.spawn(function()
        while ATMHack_State.running do
            -- Minimal wait time
            task.wait(0.01)
            
            -- Auto-win logic
            local success, err = pcall(autoWinATMHack)
            if not success then
                warn("Auto-win error: " .. tostring(err))
            end
        end
    end)
end

-- Create ATM Hack Toggle
local ATMHackToggle = JobAutoFarm:CreateToggle({
	Name = "ATM Hack AutoWin",
	Description = nil,
	CurrentValue = false,
    Callback = function(Value)
        ATMHack_State.running = Value
        
        if ATMHack_State.running then
            print("ATM Hack started!")
            -- Run the hack in a separate thread so it doesn't block
            spawn(function()
                startATMHack()
            end)
        else
            print("ATM Hack stopped!")
            atmHackCleanup()
        end
    end
}, "ATMHackToggle")

---------------------------------------------------------------------------------------------
-- ESP SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for ESP system
local ESP_State = {
    objects2D = {},
    objects3D = {},
    currentMode = "2D Box",
    enabled = false,
    config2D = {
        BoxThickness = 2,
        BoxTransparency = 1,
        HealthColorGradient = {
            {Threshold = 25, Color = Color3.fromRGB(255, 0, 0)},     -- Red at low health
            {Threshold = 50, Color = Color3.fromRGB(255, 165, 0)},   -- Orange at medium-low health
            {Threshold = 75, Color = Color3.fromRGB(255, 255, 0)},   -- Yellow at medium health
            {Threshold = 100, Color = Color3.fromRGB(0, 255, 0)}     -- Green at full health
        },
        MaxDisplayDistance = 1000,
        BoxSizeX = 2,
        BoxSizeY = 3,
        RefreshRate = 5,
    },
    config3D = {
        Box_Color = Color3.fromRGB(255, 0, 0),
        Box_Thickness = 2,
        Box_Transparency = 1,
        Autothickness = true
    }
}

-- Functions for health color (2D ESP)
local function GetHealthColor2D(health)
    for _, colorInfo in ipairs(ESP_State.config2D.HealthColorGradient) do
        if health <= colorInfo.Threshold then
            return colorInfo.Color
        end
    end
    return Color3.fromRGB(0, 255, 0)
end

-- Functions for health color (3D ESP)
local function GetHealthColor3D(currentHealth, maxHealth)
    return Color3.fromRGB(227, 52, 52):Lerp(Color3.fromRGB(88, 217, 24), currentHealth / maxHealth)
end

-- Create 2D ESP objects for a player
local function CreateESP2DForPlayer(espPlayer)
    if espPlayer == player then return end
    if ESP_State.objects2D[espPlayer] then return ESP_State.objects2D[espPlayer] end
    
    ESP_State.objects2D[espPlayer] = {
        Top = Drawing.new("Line"),
        Bottom = Drawing.new("Line"),
        Left = Drawing.new("Line"),
        Right = Drawing.new("Line"),
        LastUpdate = tick()
    }
    
    for _, line in pairs(ESP_State.objects2D[espPlayer]) do
        if type(line) ~= "number" then
            line.Visible = false
            line.Thickness = ESP_State.config2D.BoxThickness
            line.Transparency = ESP_State.config2D.BoxTransparency
            line.Color = ESP_State.config2D.HealthColorGradient[1].Color
            line.From = Vector2.new(0, 0)
            line.To = Vector2.new(0, 0)
        end
    end
    
    return ESP_State.objects2D[espPlayer]
end

-- Create 3D ESP objects for a player
local function CreateESP3DForPlayer(espPlayer)
    if espPlayer == player then return end
    if ESP_State.objects3D[espPlayer] then return ESP_State.objects3D[espPlayer] end
    
    ESP_State.objects3D[espPlayer] = {
        lines = {},
        connection = nil
    }
    
    for i = 1, 12 do
        ESP_State.objects3D[espPlayer].lines[i] = Drawing.new("Line")
        ESP_State.objects3D[espPlayer].lines[i].Visible = false
        ESP_State.objects3D[espPlayer].lines[i].Color = ESP_State.config3D.Box_Color
        ESP_State.objects3D[espPlayer].lines[i].Thickness = ESP_State.config3D.Box_Thickness
        ESP_State.objects3D[espPlayer].lines[i].Transparency = ESP_State.config3D.Box_Transparency
    end
    
    return ESP_State.objects3D[espPlayer]
end

-- Remove ESP objects for a player
local function RemoveESPForPlayer(espPlayer)
    -- Remove 2D ESP
    if ESP_State.objects2D[espPlayer] then
        for _, line in pairs(ESP_State.objects2D[espPlayer]) do
            if type(line) ~= "number" then
                line:Remove()
            end
        end
        ESP_State.objects2D[espPlayer] = nil
    end
    
    -- Remove 3D ESP
    if ESP_State.objects3D[espPlayer] then
        if ESP_State.objects3D[espPlayer].connection then
            ESP_State.objects3D[espPlayer].connection:Disconnect()
        end
        for _, line in pairs(ESP_State.objects3D[espPlayer].lines) do
            line:Remove()
        end
        ESP_State.objects3D[espPlayer] = nil
    end
end

-- Update 2D ESP for all players
local function Update2DESP()
    for _, espPlayer in ipairs(game.Players:GetPlayers()) do
        if espPlayer ~= player then
            local espObj = CreateESP2DForPlayer(espPlayer)
            
            if ESP_State.enabled and ESP_State.currentMode == "2D Box" and espPlayer.Character and 
               espPlayer.Character:FindFirstChild("HumanoidRootPart") and 
               espPlayer.Character:FindFirstChild("Humanoid") then
                
                if tick() - espObj.LastUpdate > ESP_State.config2D.RefreshRate then
                    RemoveESPForPlayer(espPlayer)
                    espObj = CreateESP2DForPlayer(espPlayer)
                    espObj.LastUpdate = tick()
                end
                
                local hrp = espPlayer.Character.HumanoidRootPart
                local humanoid = espPlayer.Character.Humanoid
                local head = espPlayer.Character:FindFirstChild("Head")
                
                local distance = (workspace.CurrentCamera.CFrame.Position - hrp.Position).Magnitude
                if distance > ESP_State.config2D.MaxDisplayDistance then
                    for _, line in pairs(espObj) do
                        if type(line) ~= "number" then
                            line.Visible = false
                        end
                    end
                else
                    local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                    
                    if onScreen then
                        local scaleFactor = math.clamp(1 - (distance / ESP_State.config2D.MaxDisplayDistance), 0.3, 1)
                        local scale = (head and head.Size.Y/2 or 0.5)
                        local size = Vector3.new(ESP_State.config2D.BoxSizeX, ESP_State.config2D.BoxSizeY, 0) * (scale * 2 * scaleFactor)
                        
                        local TL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, size.Y, 0)).Position)
                        local TR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, size.Y, 0)).Position)
                        local BL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, -size.Y, 0)).Position)
                        local BR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, -size.Y, 0)).Position)
                        
                        espObj.Top.From = Vector2.new(TL.X, TL.Y)
                        espObj.Top.To = Vector2.new(TR.X, TR.Y)
                        espObj.Left.From = Vector2.new(TL.X, TL.Y)
                        espObj.Left.To = Vector2.new(BL.X, BL.Y)
                        espObj.Right.From = Vector2.new(TR.X, TR.Y)
                        espObj.Right.To = Vector2.new(BR.X, BR.Y)
                        espObj.Bottom.From = Vector2.new(BL.X, BL.Y)
                        espObj.Bottom.To = Vector2.new(BR.X, BR.Y)
                        
                        local healthPercentage = (humanoid.Health / humanoid.MaxHealth) * 100
                        
                        for _, line in pairs(espObj) do
                            if type(line) ~= "number" then
                                line.Color = GetHealthColor2D(healthPercentage)
                                line.Transparency = ESP_State.config2D.BoxTransparency * scaleFactor
                                line.Visible = true
                            end
                        end
                    else
                        for _, line in pairs(espObj) do
                            if type(line) ~= "number" then
                                line.Visible = false
                            end
                        end
                    end
                end
            else
                for _, line in pairs(espObj) do
                    if type(line) ~= "number" then
                        line.Visible = false
                    end
                end
            end
        end
    end
end

-- Create 3D ESP for a specific player
local function Create3DESPForPlayer(espPlayer)
    if espPlayer == player then return end
    
    local esp3DObj = CreateESP3DForPlayer(espPlayer)
    
    local function Update3DESP()
        if ESP_State.enabled and ESP_State.currentMode == "3D Box" and espPlayer.Character and 
           espPlayer.Character:FindFirstChild("Humanoid") and 
           espPlayer.Character:FindFirstChild("HumanoidRootPart") and 
           espPlayer.Character.Humanoid.Health > 0 then
            
            local pos, vis = workspace.CurrentCamera:WorldToViewportPoint(espPlayer.Character.HumanoidRootPart.Position)
            if vis then
                local Scale = espPlayer.Character.Head.Size.Y/2
                local Size = Vector3.new(2, 3, 1.5) * (Scale * 2)

                local Top1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z)).p)
                local Top2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z)).p)
                local Top3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, Size.Z)).p)
                local Top4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z)).p)

                local Bottom1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, -Size.Z)).p)
                local Bottom2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, Size.Z)).p)
                local Bottom3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, Size.Z)).p)
                local Bottom4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p)

                local lines = esp3DObj.lines
                
                -- Top face
                lines[1].From = Vector2.new(Top1.X, Top1.Y); lines[1].To = Vector2.new(Top2.X, Top2.Y)
                lines[2].From = Vector2.new(Top2.X, Top2.Y); lines[2].To = Vector2.new(Top3.X, Top3.Y)
                lines[3].From = Vector2.new(Top3.X, Top3.Y); lines[3].To = Vector2.new(Top4.X, Top4.Y)
                lines[4].From = Vector2.new(Top4.X, Top4.Y); lines[4].To = Vector2.new(Top1.X, Top1.Y)
                
                -- Bottom face
                lines[5].From = Vector2.new(Bottom1.X, Bottom1.Y); lines[5].To = Vector2.new(Bottom2.X, Bottom2.Y)
                lines[6].From = Vector2.new(Bottom2.X, Bottom2.Y); lines[6].To = Vector2.new(Bottom3.X, Bottom3.Y)
                lines[7].From = Vector2.new(Bottom3.X, Bottom3.Y); lines[7].To = Vector2.new(Bottom4.X, Bottom4.Y)
                lines[8].From = Vector2.new(Bottom4.X, Bottom4.Y); lines[8].To = Vector2.new(Bottom1.X, Bottom1.Y)
                
                -- Vertical lines
                lines[9].From = Vector2.new(Top1.X, Top1.Y); lines[9].To = Vector2.new(Bottom1.X, Bottom1.Y)
                lines[10].From = Vector2.new(Top2.X, Top2.Y); lines[10].To = Vector2.new(Bottom2.X, Bottom2.Y)
                lines[11].From = Vector2.new(Top3.X, Top3.Y); lines[11].To = Vector2.new(Bottom3.X, Bottom3.Y)
                lines[12].From = Vector2.new(Top4.X, Top4.Y); lines[12].To = Vector2.new(Bottom4.X, Bottom4.Y)

                -- Health-based color and thickness
                local healthColor = GetHealthColor3D(espPlayer.Character.Humanoid.Health, espPlayer.Character.Humanoid.MaxHealth)
                local thickness = ESP_State.config3D.Box_Thickness
                if ESP_State.config3D.Autothickness then
                    thickness = math.clamp(1/(player.Character.HumanoidRootPart.Position - espPlayer.Character.HumanoidRootPart.Position).magnitude*100, 0.1, 4)
                end
                
                for _, line in pairs(lines) do
                    line.Color = healthColor
                    line.Thickness = thickness
                    line.Visible = true
                end
            else
                for _, line in pairs(esp3DObj.lines) do
                    line.Visible = false
                end
            end
        else
            for _, line in pairs(esp3DObj.lines) do
                line.Visible = false
            end
            if not game.Players:FindFirstChild(espPlayer.Name) then
                if esp3DObj.connection then
                    esp3DObj.connection:Disconnect()
                end
            end
        end
    end
    
    esp3DObj.connection = runService.RenderStepped:Connect(Update3DESP)
end

-- Initialize 3D ESP for all players
local function Initialize3DESP()
    for _, espPlayer in ipairs(game.Players:GetPlayers()) do
        if espPlayer ~= player then
            Create3DESPForPlayer(espPlayer)
        end
    end
end

-- Clean up all ESP
local function CleanupAllESP()
    for espPlayer, _ in pairs(ESP_State.objects2D) do
        RemoveESPForPlayer(espPlayer)
    end
    for espPlayer, _ in pairs(ESP_State.objects3D) do
        RemoveESPForPlayer(espPlayer)
    end
end

-- Update ESP based on current mode
local function UpdateESPSystem()
    if not ESP_State.enabled then
        CleanupAllESP()
        return
    end
    
    if ESP_State.currentMode == "2D Box" then
        -- Clean up 3D ESP
        for espPlayer, esp3DObj in pairs(ESP_State.objects3D) do
            if esp3DObj.connection then
                esp3DObj.connection:Disconnect()
            end
            for _, line in pairs(esp3DObj.lines) do
                line.Visible = false
            end
        end
    elseif ESP_State.currentMode == "3D Box" then
        -- Clean up 2D ESP
        for espPlayer, espObj in pairs(ESP_State.objects2D) do
            for _, line in pairs(espObj) do
                if type(line) ~= "number" then
                    line.Visible = false
                end
            end
        end
        Initialize3DESP()
    end
end

-- Create ESP Type Dropdown
local ESPDropdown = Visuals:CreateDropdown({
	Name = "ESP Type",
    Description = nil,
	Options = {"2D Box", "3D Box"},
    CurrentOption = {"2D Box"},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        ESP_State.currentMode = Option
        UpdateESPSystem()
    end
}, "ESPDropdown")

-- Create ESP Toggle
local ESPToggle = Visuals:CreateToggle({
	Name = "Box ESP",
	Description = nil,
	CurrentValue = false,
    Callback = function(Value)
        ESP_State.enabled = Value
        UpdateESPSystem()
    end
}, "ESPToggle")

-- Main render loop for 2D ESP
runService.RenderStepped:Connect(function()
    if ESP_State.enabled and ESP_State.currentMode == "2D Box" then
        Update2DESP()
    end
end)

-- Handle new players joining
game.Players.PlayerAdded:Connect(function(newPlayer)
    if ESP_State.currentMode == "3D Box" and ESP_State.enabled then
        Create3DESPForPlayer(newPlayer)
    end
end)

-- Handle players leaving
game.Players.PlayerRemoving:Connect(function(espPlayer)
    RemoveESPForPlayer(espPlayer)
end)
---------------------------------------------------------------------------------------------
-- NAME TAGS SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for name tags
local NameTags_State = {
    enabled = false,
    connection = nil
}

local function createNameTag(namePlayer)
    if namePlayer == player then return end
    
    local character = namePlayer.Character
    if not character then return end
    
    local head = character:FindFirstChild("Head")
    if not head then return end
    
    local existingTag = head:FindFirstChild("NameTag")
    if existingTag then return end -- Don't create if already exists
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "NameTag"
    billboardGui.Parent = head
    billboardGui.Size = UDim2.new(0, 100, 0, 20)
    billboardGui.StudsOffset = Vector3.new(0, 2, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.LightInfluence = 0
    billboardGui.SizeOffset = Vector2.new(0, 0)
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Parent = billboardGui
    nameLabel.Size = UDim2.new(1, 0, 1, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = namePlayer.Name
    nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    nameLabel.TextSize = 12
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.TextStrokeTransparency = 0
    nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
end

local function removeAllNameTags()
    for _, namePlayer in pairs(game.Players:GetPlayers()) do
        if namePlayer.Character then
            local head = namePlayer.Character:FindFirstChild("Head")
            if head then
                local nameTag = head:FindFirstChild("NameTag")
                if nameTag then
                    nameTag:Destroy()
                end
            end
        end
    end
end

-- Name tags cleanup function
local function nameTagsCleanup()
    -- Stop the connection
    if NameTags_State.connection then
        NameTags_State.connection:Disconnect()
        NameTags_State.connection = nil
    end
    
    -- Remove all existing name tags
    removeAllNameTags()
end

-- Start name tags function
local function startNameTags()
    -- Start the name tag system
    NameTags_State.connection = runService.Heartbeat:Connect(function()
        if NameTags_State.enabled then
            for _, namePlayer in pairs(game.Players:GetPlayers()) do
                if namePlayer ~= player and namePlayer.Character then
                    createNameTag(namePlayer)
                end
            end
        end
    end)
end

-- Create Name Tags Toggle
local NameTagsToggle = Visuals:CreateToggle({
	Name = "Name ESP",
	Description = nil,
	CurrentValue = false,
    Callback = function(Value)
        NameTags_State.enabled = Value
        
        if NameTags_State.enabled then
            -- Run the name tags in a separate thread so it doesn't block
            spawn(function()
                startNameTags()
            end)
        else
            nameTagsCleanup()
        end
    end
}, "NameTagsToggle")
---------------------------------------------------------------------------------------------
-- WEAPON ESP (Optimized)
---------------------------------------------------------------------------------------------

-- Move weapon data to global scope to avoid local variable limits
getgenv().WeaponESPData = getgenv().WeaponESPData or {}

-- Weapon signatures for identification
getgenv().WeaponESPData.signatures = {
    -- Firearms
    AK47 = {accuracy = 0.85, automatic = true, fire_rate = 600, MagSize = 30, range = 300, Recoil = 0.4, reload_time = 2.2, damage = 27, Durability = 720, KnockbackForce = 100, RagdollChance = 0.1, RarityName = "Legendary", RarityPrice = 70000},
    Anaconda = {accuracy = 0.95, automatic = false, fire_rate = 80, MagSize = 6, range = 120, Recoil = 0.8, reload_time = 2, damage = 70, Durability = 120, KnockbackForce = 350, RagdollChance = 0.3, RarityName = "Omega", RarityPrice = 420000},
    C9 = {accuracy = 0.7, automatic = false, fire_rate = 300, MagSize = 8, range = 80, Recoil = 0.2, reload_time = 2, damage = 11, Durability = 120, RagdollChance = 0, RarityName = "Uncommon", RarityPrice = 700},
    Crossbow = {accuracy = 0.95, automatic = false, fire_rate = 100, MagSize = 1, range = 500, Recoil = 0.3, reload_time = 2, damage = 90, Durability = 120, KnockbackForce = 100, RagdollChance = 0.3, RarityName = "Legendary", RarityPrice = 60000},
    ["Double Barrel"] = {accuracy = 0.5, automatic = false, fire_rate = 100, MagSize = 2, range = 50, Recoil = 2, reload_time = 3, damage = 16, Durability = 84, KnockbackForce = 300, RagdollChance = 0.4, RarityName = "Epic", RarityPrice = 8000},
    Draco = {accuracy = 0.75, automatic = true, fire_rate = 900, MagSize = 25, range = 250, Recoil = 0.5, reload_time = 2.2, damage = 15, Durability = 600, RagdollChance = 0, RarityName = "Epic", RarityPrice = 19000},
    G3 = {accuracy = 0.65, automatic = false, fire_rate = 320, MagSize = 10, range = 80, Recoil = 0.2, reload_time = 2, damage = 13, Durability = 144, RagdollChance = 0, RarityName = "Uncommon", RarityPrice = 900},
    Glock = {accuracy = 0.8, automatic = false, fire_rate = 370, MagSize = 15, range = 80, Recoil = 0.2, reload_time = 2, damage = 19, Durability = 168, RagdollChance = 0, RarityName = "Rare", RarityPrice = 1800},
    ["Hunting Rifle"] = {accuracy = 0.93, automatic = false, fire_rate = 50, MagSize = 5, range = 500, Recoil = 0.8, reload_time = 2.2, damage = 35, Durability = 72, KnockbackForce = 200, RagdollChance = 0.2, RarityName = "Rare", RarityPrice = 5000},
    M24 = {accuracy = 0.97, automatic = false, fire_rate = 50, MagSize = 7, range = 500, Recoil = 0.8, reload_time = 2, damage = 50, Durability = 120, KnockbackForce = 200, RagdollChance = 0.2, RarityName = "Epic", RarityPrice = 25000},
    MP5 = {accuracy = 0.85, automatic = true, fire_rate = 800, MagSize = 30, range = 200, Recoil = 0.35, reload_time = 2, damage = 19, Durability = 720, RagdollChance = 0, RarityName = "Legendary", RarityPrice = 38000},
    P226 = {accuracy = 0.75, automatic = false, fire_rate = 370, MagSize = 7, range = 80, Recoil = 0.25, reload_time = 2, damage = 22, Durability = 180, RagdollChance = 0, RarityName = "Rare", RarityPrice = 2200},
    RPG = {accuracy = 0.9, automatic = false, fire_rate = 100, MagSize = 1, range = 600, Recoil = 2, reload_time = 2.6, explode_damage = 1000, Durability = 96, ExplodeKnockback = 300, ExplodeRadius = 12, RarityName = "Legendary", RarityPrice = 90000},
    Remington = {accuracy = 0.6, automatic = false, fire_rate = 80, MagSize = 5, range = 80, Recoil = 1.5, reload_time = 2, damage = 19, Durability = 300, KnockbackForce = 300, RagdollChance = 0.4, RarityName = "Legendary", RarityPrice = 45000},
    Sawnoff = {accuracy = 0.4, automatic = false, fire_rate = 150, MagSize = 2, range = 30, Recoil = 3, reload_time = 3, damage = 18, Durability = 240, KnockbackForce = 450, RagdollChance = 0.5, RarityName = "Rare", RarityPrice = 3500},
    Uzi = {accuracy = 0.7, automatic = true, fire_rate = 1200, MagSize = 20, range = 150, Recoil = 0.3, reload_time = 1.7, damage = 8, Durability = 480, RagdollChance = 0, RarityName = "Rare", RarityPrice = 3000},
    -- Melee Weapons
    Axe = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 34, destructive = 1.6, Durability = 80, knockback_force = 250, ragdoll_chance = 0.2, RarityName = "Rare", RarityPrice = 3200},
    ["Barbed Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 43, destructive = 1.2, Durability = 100, knockback_force = 300, ragdoll_chance = 0.2, RarityName = "Epic", RarityPrice = 16000},
    ["Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 26, destructive = 1.2, Durability = 80, knockback_force = 300, ragdoll_chance = 0.2, RarityName = "Uncommon", RarityPrice = 900},
    ["Bike Lock"] = {speed = 1.9, range = 6, cone_angle = 70, damage = 17, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Common", RarityPrice = 90},
    ["Bronze Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 20, MopSpeedPercentageIncrease = 10, RarityName = "Common", RarityPrice = 100},
    ["Chair Leg"] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 21, destructive = 1, Durability = 50, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Common", RarityPrice = 300},
    ["Butcher Knife"] = {speed = 1.6, range = 6, cone_angle = 75, damage = 30, destructive = 0.9, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = "Rare", RarityPrice = 1500},
    ["Combat Axe"] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 40, destructive = 1.6, Durability = 90, knockback_force = 200, ragdoll_chance = 0.15, RarityName = "Epic", RarityPrice = 14000},
    Crowbar = {speed = 1.6, range = 7, cone_angle = 80, damage = 31, destructive = 2, Durability = 100, knockback_force = 250, ragdoll_chance = 0.15, RarityName = "Rare", RarityPrice = 3000},
    ["Diamond Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 100, MopSpeedPercentageIncrease = 40, RarityName = "Rare", RarityPrice = 1500},
    ["Frying Pan"] = {speed = 1.7, range = 6.5, cone_angle = 90, damage = 28, destructive = 1, Durability = 60, knockback_force = 400, ragdoll_chance = 0.3, RarityName = "Rare", RarityPrice = 2400},
    ["Gold Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 70, MopSpeedPercentageIncrease = 30, RarityName = "Uncommon", RarityPrice = 800},
    Hammer = {speed = 1.75, range = 6, cone_angle = 70, damage = 23, destructive = 1.5, Durability = 70, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 400},
    Machette = {speed = 1.8, range = 7.25, cone_angle = 85, damage = 38, destructive = 0.9, Durability = 90, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Epic", RarityPrice = 14000},
    ["Metal Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 35, destructive = 1.4, Durability = 110, knockback_force = 350, ragdoll_chance = 0.2, RarityName = "Rare", RarityPrice = 4000},
    ["Metal Pipe"] = {speed = 1.55, range = 6.5, cone_angle = 75, damage = 20, destructive = 1.5, Durability = 60, knockback_force = 150, ragdoll_chance = 0.3, RarityName = "Common", RarityPrice = 150},
    Mop = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 0, MopSpeedPercentageIncrease = 0, RarityName = "Common", RarityPrice = 0},
    ["Nailed Wooden Board"] = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 23, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 350},
    ["Pool Cue"] = {speed = 1.7, range = 7.5, cone_angle = 80, damage = 15, destructive = 1, Durability = 30, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 70},
    ["Rolling Pin"] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 16, destructive = 1, Durability = 30, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 70},
    ["Rusty Shovel"] = {speed = 1.2, range = 7, cone_angle = 75, damage = 25, destructive = 1.3, Durability = 50, knockback_force = 250, ragdoll_chance = 0.15, RarityName = "Uncommon", RarityPrice = 600},
    Shank = {speed = 2, range = 5.5, cone_angle = 60, damage = 20, destructive = 0.7, Durability = 40, knockback_force = 50, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 300},
    Shovel = {speed = 1.2, range = 7.5, cone_angle = 75, damage = 41, destructive = 1.4, Durability = 80, knockback_force = 300, ragdoll_chance = 0.3, RarityName = "Epic", RarityPrice = 9000},
    ["Silver Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 45, MopSpeedPercentageIncrease = 20, RarityName = "Common", RarityPrice = 300},
    ["Sledge Hammer"] = {speed = 1.1, range = 7.25, cone_angle = 80, damage = 47, destructive = 3, Durability = 110, knockback_force = 550, ragdoll_chance = 0.5, RarityName = "Epic", RarityPrice = 25000},
    Switchblade = {speed = 2, range = 5.5, cone_angle = 60, damage = 29, destructive = 0.7, Durability = 60, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Rare", RarityPrice = 2200},
    ["Tactical Axe"] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 65, destructive = 1.5, Durability = 120, knockback_force = 250, ragdoll_chance = 0.2, RarityName = "Legendary", RarityPrice = 40000},
    ["Tactical Knife"] = {speed = 2.2, range = 5.75, cone_angle = 75, damage = 50, destructive = 0.8, Durability = 110, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Legendary", RarityPrice = 30000},
    ["Tactical Shovel"] = {speed = 2, range = 6.75, cone_angle = 75, damage = 58, destructive = 1.4, Durability = 130, knockback_force = 150, ragdoll_chance = 0.15, RarityName = "Legendary", RarityPrice = 35000},
    Taser = {speed = 2, range = 5.25, cone_angle = 60, damage = 10, Durability = 40, knockback_force = 100, ragdoll_chance = 1, RarityName = "Common", RarityPrice = 120},
    ["Tire Iron"] = {speed = 1.6, range = 6.5, cone_angle = 80, damage = 24, destructive = 1.2, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 450},
    ["Wooden Board"] = {speed = 1.45, range = 6.5, cone_angle = 80, damage = 16, destructive = 1, Durability = 25, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 50},
    Wrench = {speed = 1.5, range = 6, cone_angle = 80, damage = 34, destructive = 1.8, Durability = 70, knockback_force = 200, ragdoll_chance = 0.15, RarityName = "Rare", RarityPrice = 2200}
}

-- Weapon images
getgenv().WeaponESPData.weaponImages = {
    AK47 = "rbxassetid://124555430577178",
    Anaconda = "rbxassetid://132781174839844",
    C9 = "rbxassetid://79659079988022",
    Crossbow = "rbxassetid://89240642376715",
    ["Double Barrel"] = "rbxassetid://83625765638039",
    Draco = "rbxassetid://120937616266903",
    G3 = "rbxassetid://133411291398002",
    Glock = "rbxassetid://97846154366870",
    ["Hunting Rifle"] = "rbxassetid://81547704965153",
    M24 = "rbxassetid://73387965982603",
    MP5 = "rbxassetid://80501079489777",
    P226 = "rbxassetid://92521100297776",
    RPG = "rbxassetid://138426000142807",
    Remington = "rbxassetid://101271375930409",
    Sawnoff = "rbxassetid://90588305892707",
    Uzi = "rbxassetid://109290695652338",
    Axe = "rbxassetid://101111222312507",
    ["Barbed Baseball Bat"] = "rbxassetid://124187547787390",
    ["Baseball Bat"] = "rbxassetid://70390201507839",
    ["Bike Lock"] = "rbxassetid://133060672669260",
    ["Bronze Mop"] = "rbxassetid://82833205175515",
    ["Butcher Knife"] = "rbxassetid://85388477314759",
    ["Chair Leg"] = "rbxassetid://114469903068875",
    ["Combat Axe"] = "rbxassetid://88977576372031",
    Crowbar = "rbxassetid://90424115101219",
    ["Diamond Mop"] = "rbxassetid://116898350978149",
    ["Frying Pan"] = "rbxassetid://89200286532524",
    ["Gold Mop"] = "rbxassetid://126972994127039",
    Hammer = "rbxassetid://78007467805546",
    Machette = "rbxassetid://137560461839499",
    ["Metal Baseball Bat"] = "rbxassetid://70685459891353",
    ["Metal Pipe"] = "rbxassetid://88009218092973",
    Mop = "rbxassetid://71489031926594",
    ["Nailed Wooden Board"] = "rbxassetid://133582084670866",
    ["Pool Cue"] = "rbxassetid://114421588409525",
    ["Rolling Pin"] = "rbxassetid://102775377780090",
    ["Rusty Shovel"] = "rbxassetid://92733711956764",
    Shank = "rbxassetid://73963170829473",
    Shovel = "rbxassetid://73431400264733",
    ["Silver Mop"] = "rbxassetid://80263199623205",
    ["Sledge Hammer"] = "rbxassetid://93546683073527",
    Switchblade = "rbxassetid://93060515735865",
    ["Tactical Axe"] = "rbxassetid://128521472487967",
    ["Tactical Knife"] = "rbxassetid://138188463918911",
    ["Tactical Shovel"] = "rbxassetid://92343057781870",
    Taser = "rbxassetid://125681892349691",
    ["Tire Iron"] = "rbxassetid://120450069729849",
    ["Wooden Board"] = "rbxassetid://73302633976873",
    Wrench = "rbxassetid://78671837243529"
}

-- Rarity colors for weapon boxes
getgenv().WeaponESPData.rarityColors = {
    Common = Color3.fromRGB(169, 169, 169),
    Uncommon = Color3.fromRGB(128, 128, 128),
    Rare = Color3.fromRGB(0, 180, 0),
    Epic = Color3.fromRGB(163, 53, 238),
    Legendary = Color3.fromRGB(255, 165, 0),
    Omega = Color3.fromRGB(255, 0, 0)
}

-- Consolidated state management for weapon ESP
local WeaponESP_State = {
    enabled = false,
    connection = nil,
    playerESPs = {}
}

-- Utility functions
local function getAttribute(obj, attr)
    local success, value = pcall(function() return obj:GetAttribute(attr) end)
    return success and value or nil
end

local function identifyWeapon(tool)
    for weaponName, signature in pairs(getgenv().WeaponESPData.signatures) do
        local matched, total = 0, 0
        for attrName, expectedValue in pairs(signature) do
            local toolValue = getAttribute(tool, attrName)
            if toolValue ~= nil then
                total = total + 1
                if type(expectedValue) == "number" then
                    if math.abs(toolValue - expectedValue) <= 0.01 then matched = matched + 1 end
                elseif toolValue == expectedValue then matched = matched + 1 end
            end
        end
        if total > 0 and matched / total >= 0.7 then
            return {name = weaponName, rarity = signature.RarityName, price = signature.RarityPrice}
        end
    end
    return nil
end

local function createPlayerESP(targetPlayer)
    if targetPlayer == player or not WeaponESP_State.enabled then return end
    
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return end
    
    local existingESP = targetCharacter:FindFirstChild("WeaponESPAdornment")
    if existingESP then existingESP:Destroy() end
    
    local weapons = {}
    local function collectWeapons(container)
        for _, tool in ipairs(container:GetChildren()) do
            if tool:IsA("Tool") then
                local weaponInfo = identifyWeapon(tool)
                if weaponInfo then table.insert(weapons, weaponInfo) end
            end
        end
    end
    
    local backpack = targetPlayer:FindFirstChild("Backpack")
    if backpack then collectWeapons(backpack) end
    collectWeapons(targetCharacter)
    
    if #weapons > 0 then
        local billboard = Instance.new("BillboardGui")
        billboard.Name = "WeaponESPAdornment"
        billboard.Parent = targetCharacter
        billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
        billboard.StudsOffset = Vector3.new(0, -5, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.Adornee = targetCharacter:FindFirstChild("HumanoidRootPart")
        billboard.ClipsDescendants = false
        billboard.ExtentsOffset = Vector3.new(0, 0, 0)
        billboard.ExtentsOffsetWorldSpace = Vector3.new(0, 0, 0)
        billboard.MaxDistance = math.huge
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
        
        -- Force consistent size regardless of distance
        local connection = game:GetService("RunService").Heartbeat:Connect(function()
            if billboard and billboard.Parent then
                billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
            else
                connection:Disconnect()
            end
        end)
        
        WeaponESP_State.playerESPs[targetPlayer] = {billboard = billboard, connection = connection}
        
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1
        frame.Parent = billboard
        
        for i, weapon in ipairs(weapons) do
            -- Get rarity color for this weapon
            local rarityColor = getgenv().WeaponESPData.rarityColors[weapon.rarity] or Color3.fromRGB(255, 255, 255)
            
            -- Create individual box for each weapon
            local weaponBox = Instance.new("Frame")
            weaponBox.Size = UDim2.new(0, 22, 0, 22)
            weaponBox.Position = UDim2.new(0, (i-1) * 24, 0, 2)
            weaponBox.BackgroundColor3 = rarityColor
            weaponBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
            weaponBox.BorderSizePixel = 1
            weaponBox.Parent = frame
            
            -- Add corner rounding
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0, 3)
            corner.Parent = weaponBox
            
            -- Add glossy gradient effect
            local gradient = Instance.new("UIGradient")
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                ColorSequenceKeypoint.new(0.5, rarityColor),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
            }
            gradient.Rotation = -45
            gradient.Parent = weaponBox
            
            -- Add subtle stroke for extra definition
            local stroke = Instance.new("UIStroke")
            stroke.Color = Color3.fromRGB(255, 255, 255)
            stroke.Transparency = 0.7
            stroke.Thickness = 1
            stroke.Parent = weaponBox
            
            -- Add weapon image inside the box
            local imageLabel = Instance.new("ImageLabel")
            imageLabel.Size = UDim2.new(0, 18, 0, 18)
            imageLabel.Position = UDim2.new(0, 2, 0, 2)
            imageLabel.BackgroundTransparency = 1
            imageLabel.Image = getgenv().WeaponESPData.weaponImages[weapon.name] or ""
            imageLabel.ScaleType = Enum.ScaleType.Fit
            imageLabel.Parent = weaponBox
        end
    end
end

local function removeAllESP()
    for targetPlayer, espData in pairs(WeaponESP_State.playerESPs) do
        if espData then
            if espData.billboard and espData.billboard.Parent then 
                espData.billboard:Destroy() 
            end
            if espData.connection then
                espData.connection:Disconnect()
            end
        end
    end
    WeaponESP_State.playerESPs = {}
    
    for _, targetPlayer in ipairs(game.Players:GetPlayers()) do
        if targetPlayer.Character then
            local existingESP = targetPlayer.Character:FindFirstChild("WeaponESPAdornment")
            if existingESP then existingESP:Destroy() end
        end
    end
end

local function startESP()
    if WeaponESP_State.connection then return end
    
    for _, targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer) end
    
    local playerAddedConnection = game.Players.PlayerAdded:Connect(createPlayerESP)
    local playerRemovingConnection = game.Players.PlayerRemoving:Connect(function(targetPlayer)
        if WeaponESP_State.playerESPs[targetPlayer] then
            if WeaponESP_State.playerESPs[targetPlayer].billboard then
                WeaponESP_State.playerESPs[targetPlayer].billboard:Destroy()
            end
            if WeaponESP_State.playerESPs[targetPlayer].connection then
                WeaponESP_State.playerESPs[targetPlayer].connection:Disconnect()
            end
            WeaponESP_State.playerESPs[targetPlayer] = nil
        end
    end)
    
    WeaponESP_State.connection = coroutine.create(function()
        while WeaponESP_State.enabled do
            wait(2)
            if WeaponESP_State.enabled then
                for _, targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer) end
            end
        end
    end)
    
    coroutine.resume(WeaponESP_State.connection)
    WeaponESP_State.playerESPs._connections = {playerAdded = playerAddedConnection, playerRemoving = playerRemovingConnection}
end

local function stopESP()
    WeaponESP_State.enabled = false
    if WeaponESP_State.playerESPs._connections then
        if WeaponESP_State.playerESPs._connections.playerAdded then WeaponESP_State.playerESPs._connections.playerAdded:Disconnect() end
        if WeaponESP_State.playerESPs._connections.playerRemoving then WeaponESP_State.playerESPs._connections.playerRemoving:Disconnect() end
        WeaponESP_State.playerESPs._connections = nil
    end
    removeAllESP()
    WeaponESP_State.connection = nil
end

-- Luna Toggle Integration
local Toggle = Visuals:CreateToggle({
    Name = "Weapon ESP",
    Description = "Shows weapons that other players are carrying",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            WeaponESP_State.enabled = true
            startESP()
        else
            stopESP()
        end
    end
}, "WeaponESP")
---------------------------------------------------------------------------------------------
-- VEHICLE MODIFICATION SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for vehicle modification
local VehicleMod_State = {
    sliderValues = {},
    attributeConfigs = {
        {name = "acceleration", min = 0, max = 100, default = 8, increment = 1},
        {name = "braking", min = 0, max = 100, default = 10, increment = 1},
        {name = "deceleration", min = 0, max = 50, default = 1, increment = 1},
        {name = "forwardMaxSpeed", min = 0, max = 100, default = 23, increment = 1},
        {name = "handBrakeTorque", min = 0, max = 50000, default = 20000, increment = 100},
        {name = "maxSpeedTorque", min = 0, max = 2000, default = 500, increment = 10},
        {name = "reverseMaxSpeed", min = 0, max = 100, default = 5, increment = 1}
    }
}

-- Initialize slider values with defaults
for _, config in ipairs(VehicleMod_State.attributeConfigs) do
    VehicleMod_State.sliderValues[config.name] = config.default
end

-- Create sliders for each attribute using Luna system
for _, config in ipairs(VehicleMod_State.attributeConfigs) do
    Vehicle:CreateSlider({
        Name = config.name,
        Range = {config.min, config.max},
        Increment = config.increment,
        CurrentValue = config.default,
        Callback = function(Value)
            VehicleMod_State.sliderValues[config.name] = Value
        end
    }, "Slider" .. config.name)
end

-- Apply Changes Button using Luna system
local ApplyButton = Vehicle:CreateButton({
    Name = "Apply Motor Changes",
    Description = "Apply all slider values to vehicle motors",
    Callback = function()
        -- Function to recursively find and update motors
        local function updateMotorsInObject(obj)
            -- Check if this object has motor attributes
            for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                if obj:GetAttribute(attributeName) ~= nil then
                    obj:SetAttribute(attributeName, value)
                end
            end
            
            -- Recursively check children
            for _, child in pairs(obj:GetChildren()) do
                updateMotorsInObject(child)
            end
        end
        
        -- Find all vehicles and their motors
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if not vehiclesFolder then
            return
        end
        
        local motorsChanged = 0
        
        -- Process all vehicles in the Vehicles folder
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA("Model") or vehicle:IsA("Folder") then
                updateMotorsInObject(vehicle)
            end
        end
        
        -- Also check for a direct Motors folder (backward compatibility)
        local motorsFolder = vehiclesFolder:FindFirstChild("Motors")
        if motorsFolder then
            for _, motor in pairs(motorsFolder:GetChildren()) do
                for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                    if motor:GetAttribute(attributeName) ~= nil then
                        motor:SetAttribute(attributeName, value)
                        motorsChanged = motorsChanged + 1
                    end
                end
            end
        end
        
        -- Count total attributes changed
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA("Model") or vehicle:IsA("Folder") then
                local function countAttributes(obj)
                    for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                        if obj:GetAttribute(attributeName) ~= nil then
                            motorsChanged = motorsChanged + 1
                        end
                    end
                    for _, child in pairs(obj:GetChildren()) do
                        countAttributes(child)
                    end
                end
                countAttributes(vehicle)
            end
        end
    end
})
---------------------------------------------------------------------------------------
--SPEED BOOST RUNNING (Fixed Optimized)
---------------------------------------------------------------------------------------

-- Consolidated state management for speed boost
local SpeedBoost_State = {
    enabled = false,
    connection = nil,
    spamConnection = nil
}

local function enableAutoSprint()
    if not player.Character then return end
    
    -- Wait for game systems to fully load
    wait(2)
    
    SpeedBoost_State.connection = game:GetService("RunService").Heartbeat:Connect(function()
        if not player.Character then
            if SpeedBoost_State.connection then
                SpeedBoost_State.connection:Disconnect()
                SpeedBoost_State.connection = nil
            end
            return
        end
        
        if SpeedBoost_State.enabled then
            -- Check if player is moving
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                
                -- Set speed multiplier for 21 speed (16 * 1.3125 = 21)
                player:SetAttribute("SpeedMultiplier", 1.3125)
                
                -- Try to access the keybind system to simulate sprint key press
                local success = pcall(function()
                    local keybindModule = require(game.ReplicatedStorage.Modules.Game.Keybinds)
                    
                    -- Simulate holding the sprint key
                    if keybindModule.hook_action then
                        -- Force the sprint action to be active
                        keybindModule.hook_action("sprint", function()
                            return true -- Always return true (sprint key pressed)
                        end)
                    end
                end)
                
                -- Also try to maintain the sprint state directly
                pcall(function()
                    local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                    if sprintModule.sprinting and sprintModule.sprinting.get() == false then
                        sprintModule.sprinting.set(true)
                    end
                    
                    -- Keep stamina topped up
                    if sprintModule.sprint_bar then
                        sprintModule.sprint_bar.set(1)
                    end
                end)
            else
                -- Reset speed multiplier when not moving
                player:SetAttribute("SpeedMultiplier", 1)
            end
        end
    end)
end

local function startSprintSpam()
    -- The working shift spam exploit - every 0.5 seconds
    SpeedBoost_State.spamConnection = spawn(function()
        while SpeedBoost_State.enabled do
            wait(0.5) -- Every 0.5 seconds
            
            if SpeedBoost_State.enabled and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                    pcall(function()
                        local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                        
                        -- Directly call the sprinting state toggle like the real shift key does
                        if sprintModule.sprinting then
                            -- Simulate a quick sprint toggle (like tapping shift)
                            sprintModule.sprinting.set(false) -- Turn off
                            wait(0.05) -- Brief pause
                            sprintModule.sprinting.set(true)  -- Turn back on
                        end
                    end)
                end
            end
        end
    end)
end

local function stopAutoSprint()
    if SpeedBoost_State.connection then
        SpeedBoost_State.connection:Disconnect()
        SpeedBoost_State.connection = nil
    end
    -- spamConnection doesn't need to be disconnected since it's a spawn() thread
    SpeedBoost_State.spamConnection = nil
    -- Reset speed when disabled
    if player then
        player:SetAttribute("SpeedMultiplier", 1)
    end
end

-- Apply to current and future characters
local function setupCharacter()
    if SpeedBoost_State.enabled then
        enableAutoSprint()
    end
end

if player.Character then
    setupCharacter()
end

player.CharacterAdded:Connect(function()
    wait(3)
    setupCharacter()
end)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = "Super Speed",
    Description = "Speed Boost",
    CurrentValue = false,
    Callback = function(Value)
        SpeedBoost_State.enabled = Value
        
        if SpeedBoost_State.enabled then
            -- Start the auto sprint system
            if player.Character then
                enableAutoSprint()
            end
            startSprintSpam()
        else
            -- Stop the auto sprint system
            stopAutoSprint()
        end
    end
}, "SpeedBoostToggle") -- Unique flag for configuration saving

-------------------------------------------------------------------------------------
--SUPER JUMP (Optimized)
-------------------------------------------------------------------------------------

-- Consolidated state management for super jump
local SuperJump_State = {
    enabled = false
}

local function updateJumpPower(character, enabled)
    local humanoid = character:WaitForChild("Humanoid", 10)
    if not humanoid then
        return
    end
    
    if enabled then
        -- Enable UseJumpPower (this makes JumpPower work instead of JumpHeight)
        humanoid.UseJumpPower = true
        
        -- Set JumpPower to 65
        humanoid.JumpPower = 65
    else
        -- Reset to default values
        humanoid.UseJumpPower = true -- Keep this true but reset power
        humanoid.JumpPower = 23 -- Default jump power (changed from 50 to 23)
    end
end

local function setupCharacter(character)
    updateJumpPower(character, SuperJump_State.enabled)
end

-- Apply to current character if it exists
if player.Character then
    setupCharacter(player.Character)
end

-- Apply to future characters when they spawn
player.CharacterAdded:Connect(setupCharacter)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = "Super Jump",
    Description = "Jump Boost",
    CurrentValue = false,
    Callback = function(Value)
        SuperJump_State.enabled = Value
        
        -- Apply to current character if it exists
        if player.Character then
            updateJumpPower(player.Character, SuperJump_State.enabled)
        end
    end
}, "JumpBoostToggle") -- Unique flag for configuration saving

Player:CreateDivider()
---------------------------------------------------------------------------
--Infi Stamina (Optimized)
---------------------------------------------------------------------------

-- Consolidated state management for infinite stamina
local InfiniteStamina_State = {
    enabled = false,
    connection = nil,
    spamConnection = nil
}

local function enableInfiniteStamina()
    if not player.Character then return end
    
    -- Wait for game systems to fully load
    wait(2)
    
    InfiniteStamina_State.connection = game:GetService("RunService").Heartbeat:Connect(function()
        if not player.Character then
            if InfiniteStamina_State.connection then
                InfiniteStamina_State.connection:Disconnect()
                InfiniteStamina_State.connection = nil
            end
            return
        end
        
        if InfiniteStamina_State.enabled then
            -- Check if player is moving
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                
                -- ESSENTIAL: Hook the sprint action to enable sprinting
                pcall(function()
                    local keybindModule = require(game.ReplicatedStorage.Modules.Game.Keybinds)
                    
                    if keybindModule.hook_action then
                        keybindModule.hook_action("sprint", function()
                            return true -- Always return true (sprint key pressed)
                        end)
                    end
                end)
                
                -- ESSENTIAL: Maintain the sprint state
                pcall(function()
                    local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                    if sprintModule.sprinting and sprintModule.sprinting.get() == false then
                        sprintModule.sprinting.set(true)
                    end
                    
                    -- Keep stamina topped up
                    if sprintModule.sprint_bar then
                        sprintModule.sprint_bar.set(1)
                    end
                end)
            end
        end
    end)
end

local function startStaminaSpam()
    -- The shift spam exploit for infinite stamina
    InfiniteStamina_State.spamConnection = spawn(function()
        while InfiniteStamina_State.enabled do
            wait(0.5) -- Every 0.5 seconds
            
            if InfiniteStamina_State.enabled and player.Character then
                local humanoid = player.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                    pcall(function()
                        local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                        
                        -- Simulate the shift key spam exploit
                        if sprintModule.sprinting then
                            -- Quick sprint toggle (like manually tapping shift)
                            sprintModule.sprinting.set(false) -- Turn off
                            wait(0.05) -- Brief pause
                            sprintModule.sprinting.set(true)  -- Turn back on
                        end
                    end)
                end
            end
        end
    end)
end

local function stopInfiniteStamina()
    if InfiniteStamina_State.connection then
        InfiniteStamina_State.connection:Disconnect()
        InfiniteStamina_State.connection = nil
    end
    -- spamConnection doesn't need to be disconnected since it's a spawn() thread
    InfiniteStamina_State.spamConnection = nil
end

local function setupCharacter()
    if InfiniteStamina_State.enabled then
        enableInfiniteStamina()
    end
end

-- Apply to current and future characters
if player.Character then
    setupCharacter()
end

player.CharacterAdded:Connect(function()
    wait(3)
    setupCharacter()
end)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = "Infinite Stamina",
    Description = "Never run out of stamina while sprinting",
    CurrentValue = false,
    Callback = function(Value)
        InfiniteStamina_State.enabled = Value
        
        if InfiniteStamina_State.enabled then
            -- Start the infinite stamina system
            if player.Character then
                enableInfiniteStamina()
            end
            startStaminaSpam()
        else
            -- Stop the infinite stamina system
            stopInfiniteStamina()
        end
    end
}, "InfiniteStaminaToggle") -- Unique flag for configuration saving
------------------------------------------------------------------------------
--WEAPON (Optimized)
------------------------------------------------------------------------------

-- Consolidated state management for weapon modification
local WeaponMod_State = {
    enabled = false,
    attributeMultipliers = {
        accuracy = 1,      -- Default multiplier for accuracy (0.75  1 * multiplier)
        fireRate = 1,      -- Default multiplier for fire rate (370  1000 * multiplier)
        magSize = 1,       -- Default multiplier for magazine size (7  1000 * multiplier)
        range = 1,         -- Default multiplier for range (80  1000 * multiplier)
        recoil = 1,        -- Default multiplier for recoil (0.25  0 * multiplier)
        reloadTime = 1     -- Default multiplier for reload time (2  0 * multiplier)
    },
    gunConfigs = {
        ["G3"] = {
            modifications = {
                {original = 0.65, target = 1, type = "accuracy"},
                {original = 320, target = 1000, type = "fireRate"},
                {original = 10, target = 1000, type = "magSize"},
                {original = 80, target = 1000, type = "range"},
                {original = 0.2, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["AK47"] = {
            modifications = {
                {original = 0.85, target = 1, type = "accuracy"},
                {original = 600, target = 1000, type = "fireRate"},
                {original = 30, target = 1000, type = "magSize"},
                {original = 300, target = 1000, type = "range"},
                {original = 0.4, target = 0, type = "recoil"},
                {original = 2.2, target = 0, type = "reloadTime"}
            }
        },
        ["Anaconda"] = {
            modifications = {
                {original = 0.95, target = 1, type = "accuracy"},
                {original = 80, target = 1000, type = "fireRate"},
                {original = 6, target = 1000, type = "magSize"},
                {original = 120, target = 1000, type = "range"},
                {original = 0.8, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["C9"] = {
            modifications = {
                {original = 0.7, target = 1, type = "accuracy"},
                {original = 300, target = 1000, type = "fireRate"},
                {original = 8, target = 1000, type = "magSize"},
                {original = 80, target = 1000, type = "range"},
                {original = 0.2, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["Crossbow"] = {
            modifications = {
                {original = 0.95, target = 1, type = "accuracy"},
                {original = 100, target = 1000, type = "fireRate"},
                {original = 1, target = 1000, type = "magSize"},
                {original = 500, target = 1000, type = "range"},
                {original = 0.3, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["Double Barrel"] = {
            modifications = {
                {original = 0.5, target = 1, type = "accuracy"},
                {original = 100, target = 1000, type = "fireRate"},
                {original = 2, target = 1000, type = "magSize"},
                {original = 50, target = 1000, type = "range"},
                {original = 2, target = 0, type = "recoil"},
                {original = 3, target = 0, type = "reloadTime"}
            }
        },
        ["Draco"] = {
            modifications = {
                {original = 0.75, target = 1, type = "accuracy"},
                {original = 900, target = 1000, type = "fireRate"},
                {original = 25, target = 1000, type = "magSize"},
                {original = 250, target = 1000, type = "range"},
                {original = 0.5, target = 0, type = "recoil"},
                {original = 2.2, target = 0, type = "reloadTime"}
            }
        },
        ["Firework Launcher"] = {
            modifications = {
                {original = 0.8, target = 1, type = "accuracy"},
                {original = 100, target = 1000, type = "fireRate"},
                {original = 1, target = 1000, type = "magSize"},
                {original = 500, target = 1000, type = "range"},
                {original = 1, target = 0, type = "recoil"},
                {original = 0.9, target = 0, type = "reloadTime"}
            }
        },
        ["Glock"] = {
            modifications = {
                {original = 0.8, target = 1, type = "accuracy"},
                {original = 370, target = 1000, type = "fireRate"},
                {original = 15, target = 1000, type = "magSize"},
                {original = 80, target = 1000, type = "range"},
                {original = 0.2, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["Hunting Rifle"] = {
            modifications = {
                {original = 0.93, target = 1, type = "accuracy"},
                {original = 50, target = 1000, type = "fireRate"},
                {original = 5, target = 1000, type = "magSize"},
                {original = 500, target = 1000, type = "range"},
                {original = 0.8, target = 0, type = "recoil"},
                {original = 2.2, target = 0, type = "reloadTime"}
            }
        },
        ["M24"] = {
            modifications = {
                {original = 0.97, target = 1, type = "accuracy"},
                {original = 50, target = 1000, type = "fireRate"},
                {original = 7, target = 1000, type = "magSize"},
                {original = 500, target = 1000, type = "range"},
                {original = 0.8, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["MP5"] = {
            modifications = {
                {original = 0.85, target = 1, type = "accuracy"},
                {original = 800, target = 1000, type = "fireRate"},
                {original = 30, target = 1000, type = "magSize"},
                {original = 200, target = 1000, type = "range"},
                {original = 0.35, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["P226"] = {
            modifications = {
                {original = 0.75, target = 1, type = "accuracy"},
                {original = 370, target = 1000, type = "fireRate"},
                {original = 7, target = 1000, type = "magSize"},
                {original = 80, target = 1000, type = "range"},
                {original = 0.25, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["RPG"] = {
            modifications = {
                {original = 0.9, target = 1, type = "accuracy"},
                {original = 100, target = 1000, type = "fireRate"},
                {original = 1, target = 1000, type = "magSize"},
                {original = 600, target = 1000, type = "range"},
                {original = 2, target = 0, type = "recoil"},
                {original = 2.6, target = 0, type = "reloadTime"}
            }
        },
        ["Remington"] = {
            modifications = {
                {original = 0.6, target = 1, type = "accuracy"},
                {original = 80, target = 1000, type = "fireRate"},
                {original = 5, target = 1000, type = "magSize"},
                {original = 80, target = 1000, type = "range"},
                {original = 1.5, target = 0, type = "recoil"},
                {original = 2, target = 0, type = "reloadTime"}
            }
        },
        ["Sawnoff"] = {
            modifications = {
                {original = 0.4, target = 1, type = "accuracy"},
                {original = 150, target = 1000, type = "fireRate"},
                {original = 2, target = 1000, type = "magSize"},
                {original = 30, target = 1000, type = "range"},
                {original = 3, target = 0, type = "recoil"},
                {original = 3, target = 0, type = "reloadTime"}
            }
        },
        ["Uzi"] = {
            modifications = {
                {original = 0.7, target = 1, type = "accuracy"},
                {original = 1200, target = 1000, type = "fireRate"},
                {original = 20, target = 1000, type = "magSize"},
                {original = 150, target = 1000, type = "range"},
                {original = 0.3, target = 0, type = "recoil"},
                {original = 1.7, target = 0, type = "reloadTime"}
            }
        }
    }
}

-- Function to restore original attributes
local function RestoreGunAttributes(tool)
    if not tool then return end
    
    local gunConfig = WeaponMod_State.gunConfigs[tool.Name]
    if not gunConfig then return end
    
    wait(0.1)
    
    for _, modification in ipairs(gunConfig.modifications) do
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == "number" then
                if math.abs(attrValue - (modification.target * WeaponMod_State.attributeMultipliers[modification.type])) < 0.01 then
                    tool:SetAttribute(attrName, modification.original)
                end
            end
        end
    end
end

-- Function to modify attributes for detected guns
local function ModifyGunAttributes(tool)
    if not tool then return end
    if not WeaponMod_State.enabled then return end
    
    local gunConfig = WeaponMod_State.gunConfigs[tool.Name]
    if not gunConfig then return end
    
    wait(0.1)
    
    for _, modification in ipairs(gunConfig.modifications) do
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == "number" then
                if math.abs(attrValue - modification.original) < 0.01 then
                    -- Apply individual multiplier based on attribute type
                    tool:SetAttribute(attrName, modification.target * WeaponMod_State.attributeMultipliers[modification.type])
                end
            end
        end
    end
end

-- Function to modify existing guns
local function ModifyExistingGuns()
    if not player.Character then return end
    
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA("Tool") then
            ModifyGunAttributes(item)
        end
    end
    
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            ModifyGunAttributes(item)
        end
    end
end

-- Function to restore existing guns
local function RestoreExistingGuns()
    if not player.Character then return end
    
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA("Tool") then
            RestoreGunAttributes(item)
        end
    end
    
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            RestoreGunAttributes(item)
        end
    end
end

-- Set up monitoring
player.Backpack.ChildAdded:Connect(function(newItem)
    if newItem:IsA("Tool") and WeaponMod_State.enabled then
        ModifyGunAttributes(newItem)
    end
end)

player.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(newItem)
        if newItem:IsA("Tool") and WeaponMod_State.enabled then
            ModifyGunAttributes(newItem)
        end
    end)
end)

if player.Character then
    player.Character.ChildAdded:Connect(function(newItem)
        if newItem:IsA("Tool") and WeaponMod_State.enabled then
            ModifyGunAttributes(newItem)
        end
    end)
end

-- Luna UI Integration - Individual Sliders for Each Attribute
Weapon:CreateSlider({
    Name = "Accuracy Multiplier",
    Range = {0.1, 1}, -- 0.1x to 1x accuracy multiplier (max 100% accuracy)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.accuracy = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "AccuracyMultiplierSlider")

Weapon:CreateSlider({
    Name = "Fire Rate Multiplier",
    Range = {1, 1000}, -- 1x to 1000x fire rate multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.fireRate = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "FireRateMultiplierSlider")

Weapon:CreateSlider({
    Name = "Magazine Size Multiplier",
    Range = {1, 1000}, -- 1x to 1000x magazine size multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.magSize = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "MagSizeMultiplierSlider")

Weapon:CreateSlider({
    Name = "Range Multiplier",
    Range = {1, 1000}, -- 1x to 1000x range multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.range = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "RangeMultiplierSlider")

Weapon:CreateSlider({
    Name = "Recoil Multiplier",
    Range = {0, 2}, -- 0x to 2x recoil multiplier (0 = no recoil)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.recoil = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "RecoilMultiplierSlider")

Weapon:CreateSlider({
    Name = "Reload Time Multiplier",
    Range = {0, 2}, -- 0x to 2x reload time multiplier (0 = instant reload)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.reloadTime = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, "ReloadTimeMultiplierSlider")

-- Main Toggle (placed at the bottom as requested)
local Toggle = Weapon:CreateToggle({
    Name = "Gun Modifier",
    Description = "Enable/Disable gun modifications",
    CurrentValue = false,
    Callback = function(Value)
        WeaponMod_State.enabled = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        else
            RestoreExistingGuns()
        end
    end
}, "GunModifierToggle")

------------------------------------------------------------------------------
--AUTO RESPAWN (Optimized)
------------------------------------------------------------------------------

-- Consolidated state management for auto respawn
local AutoRespawn_State = {
    enabled = false,
    isRespawning = false,
    connections = {}
}

-- Function to find and click the respawn button
local function clickRespawnButton()
    if AutoRespawn_State.isRespawning or not AutoRespawn_State.enabled then return end
    AutoRespawn_State.isRespawning = true
    
    pcall(function()
        local playerGui = player.PlayerGui
        local deathScreen = playerGui:FindFirstChild("DeathScreen")
        
        if deathScreen then
            local deathScreenHolder = deathScreen:FindFirstChild("DeathScreenHolder")
            if deathScreenHolder then
                local frame = deathScreenHolder:FindFirstChild("Frame")
                if frame then
                    local respawnButtonFrame = frame:FindFirstChild("RespawnButtonFrame")
                    if respawnButtonFrame then
                        local respawnButton = respawnButtonFrame:FindFirstChild("RespawnButton")
                        if respawnButton and respawnButton.Visible and respawnButton.Parent.Visible then
                            -- Multiple click methods to ensure it works
                            
                            -- Method 1: Fire the click event
                            for _, connection in pairs(getconnections(respawnButton.MouseButton1Click)) do
                                connection:Fire()
                            end
                            
                            -- Method 2: Use GuiService
                            game:GetService("GuiService"):FireClick(respawnButton)
                            
                            -- Method 3: Simulate mouse click
                            local VirtualInputManager = game:GetService("VirtualInputManager")
                            local buttonPos = respawnButton.AbsolutePosition
                            local buttonSize = respawnButton.AbsoluteSize
                            local centerX = buttonPos.X + buttonSize.X/2
                            local centerY = buttonPos.Y + buttonSize.Y/2
                            
                            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                            
                            return true
                        end
                    end
                end
            end
        end
    end)
    
    AutoRespawn_State.isRespawning = false
    return false
end

-- Continuous monitoring function
local function startAutoRespawn()
    if AutoRespawn_State.connections.heartbeat then 
        AutoRespawn_State.connections.heartbeat:Disconnect() 
    end
    
    AutoRespawn_State.connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
        if not AutoRespawn_State.enabled then return end
        
        if player.Character == nil or 
           (player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health <= 0) then
            
            if clickRespawnButton() then
                wait(2) -- Wait before checking again
            end
        end
    end)
end

-- Monitor for death screen appearance
local function monitorDeathScreen()
    local playerGui = player:WaitForChild("PlayerGui")
    
    if AutoRespawn_State.connections.deathScreen then 
        AutoRespawn_State.connections.deathScreen:Disconnect() 
    end
    
    -- Watch for DeathScreen being added
    AutoRespawn_State.connections.deathScreen = playerGui.ChildAdded:Connect(function(child)
        if child.Name == "DeathScreen" and AutoRespawn_State.enabled then
            wait(0.1) -- Small delay for GUI to load
            
            spawn(function()
                for attempts = 1, 50 do -- Try for 5 seconds
                    if not (child.Parent and AutoRespawn_State.enabled) then break end
                    if clickRespawnButton() then break end
                    wait(0.1)
                end
            end)
        end
    end)
end

-- Monitor humanoid death
local function setupDeathMonitoring()
    local function connectCharacterDeath(character)
        table.insert(AutoRespawn_State.connections, character:WaitForChild("Humanoid").Died:Connect(function()
            if not AutoRespawn_State.enabled then return end
            wait(0.5) -- Wait for death screen
            
            -- Keep trying to click respawn button
            spawn(function()
                for i = 1, 30 do -- Try for 3 seconds
                    if not AutoRespawn_State.enabled then break end
                    if clickRespawnButton() then break end
                    wait(0.1)
                end
            end)
        end))
    end
    
    if AutoRespawn_State.connections.characterAdded then 
        AutoRespawn_State.connections.characterAdded:Disconnect() 
    end
    
    AutoRespawn_State.connections.characterAdded = player.CharacterAdded:Connect(connectCharacterDeath)
    
    -- Setup for current character if it exists
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        connectCharacterDeath(player.Character)
    end
end

-- Function to enable auto respawn
local function enableAutoRespawn()
    AutoRespawn_State.enabled = true
    monitorDeathScreen()
    setupDeathMonitoring()
    startAutoRespawn()
end

-- Function to disable auto respawn
local function disableAutoRespawn()
    AutoRespawn_State.enabled = false
    
    -- Disconnect all connections
    for _, connection in pairs(AutoRespawn_State.connections) do
        if connection and connection.Disconnect then
            connection:Disconnect()
        end
    end
    AutoRespawn_State.connections = {}
end

-- Luna toggle integration
local AutoRespawnToggle = Player:CreateToggle({
    Name = "Auto Respawn",
    Description = "Automatically respawn when you die",
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            enableAutoRespawn()
        else
            disableAutoRespawn()
        end
    end
}, "AutoRespawnToggle")

-------------------------------------------------------------------------------
--AIMBOT (Optimized)
-------------------------------------------------------------------------------

-- Consolidated state management for aimbot
local Aimbot_State = {
    config = {
        LOCK_DISTANCE = 10000,
        CAMERA_HEIGHT_OFFSET = 0.5,
        FOV_RADIUS = 200,
        SHOW_FOV_CIRCLE = true,
        WHITELIST = {},
        WHITELISTED_PLAYERS = {},
        AIMBOT_ENABLED = false,
        wasLeftControlDown = false
    },
    currentTarget = nil,
    fovCircle = nil,
    aimConnection = nil
}

-- Core Functions
local function updatePlayerList()
    local names = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player then table.insert(names, p.Name) end
    end
    return names
end

local function cleanWhitelist()
    local current = {}
    for _, p in pairs(game.Players:GetPlayers()) do current[p.Name] = true end
    for name, _ in pairs(Aimbot_State.config.WHITELIST) do
        if not current[name] then
            Aimbot_State.config.WHITELIST[name] = nil
        end
    end
end

local function createDrawings()
    if Aimbot_State.fovCircle then Aimbot_State.fovCircle:Destroy() end
    
    Aimbot_State.fovCircle = Drawing.new("Circle")
    Aimbot_State.fovCircle.Radius = Aimbot_State.config.FOV_RADIUS
    Aimbot_State.fovCircle.Color = Color3.new(1, 1, 1)
    Aimbot_State.fovCircle.Transparency = 0.5
    Aimbot_State.fovCircle.Visible = false
    Aimbot_State.fovCircle.Thickness = 2
    Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
end

local function updateVisuals()
    if Aimbot_State.fovCircle then
        Aimbot_State.fovCircle.Visible = Aimbot_State.config.SHOW_FOV_CIRCLE and Aimbot_State.config.AIMBOT_ENABLED
        Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    end
end

local function isInFOV(target)
    local char = player.Character
    if not char or not target.Character then return false end
    
    local head = target.Character:FindFirstChild("Head")
    if not head then return false end
    
    local center = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    local screen = workspace.CurrentCamera:WorldToScreenPoint(head.Position)
    local dist = (Vector2.new(screen.X, screen.Y) - center).Magnitude
    
    return dist <= Aimbot_State.config.FOV_RADIUS
end

local function isVisible(char)
    if not char or not player.Character then return false end
    
    local head = char:FindFirstChild("Head")
    local root = player.Character:FindFirstChild("HumanoidRootPart")
    if not head or not root then return false end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {player.Character}
    
    local result = workspace:Raycast(root.Position, 
        (head.Position - root.Position).Unit * Aimbot_State.config.LOCK_DISTANCE, params)
    
    return result == nil or result.Instance:IsDescendantOf(char)
end

local function findTarget()
    local char = player.Character
    if not char then return nil end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    
    local closest = nil
    local shortest = Aimbot_State.config.LOCK_DISTANCE
    
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player and not Aimbot_State.config.WHITELIST[p.Name] then
            local pChar = p.Character
            local pRoot = pChar and pChar:FindFirstChild("HumanoidRootPart")
            
            if pRoot then
                local dist = (pRoot.Position - root.Position).Magnitude
                if dist < shortest and isVisible(pChar) and isInFOV(p) then
                    closest = p
                    shortest = dist
                end
            end
        end
    end
    
    return closest
end

local function aimNormal(target)
    -- Clear any existing target and connection
    if Aimbot_State.currentTarget then
        Aimbot_State.currentTarget = nil
    end
    if Aimbot_State.aimConnection then
        Aimbot_State.aimConnection:Disconnect()
        Aimbot_State.aimConnection = nil
    end
    
    Aimbot_State.currentTarget = target
    
    Aimbot_State.aimConnection = game:GetService("RunService").RenderStepped:Connect(function()
        if not Aimbot_State.config.AIMBOT_ENABLED or 
           not game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftControl) or
           not Aimbot_State.currentTarget or not Aimbot_State.currentTarget.Character or
           not Aimbot_State.currentTarget.Character:FindFirstChild("Head") then
            
            if Aimbot_State.aimConnection then
                Aimbot_State.aimConnection:Disconnect()
                Aimbot_State.aimConnection = nil
            end
            Aimbot_State.currentTarget = nil
            return
        end
        
        workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, 
            Aimbot_State.currentTarget.Character.Head.Position + Vector3.new(0, Aimbot_State.config.CAMERA_HEIGHT_OFFSET, 0))
    end)
end

-- Initialize
createDrawings()

-- Luna UI Components
Aimbot:CreateToggle({
    Name = "Enable Aimbot",
    Description = "Hold Left Control to activate aimbot",
    CurrentValue = false,
    Callback = function(Value)
        Aimbot_State.config.AIMBOT_ENABLED = Value
        if not Value then 
            Aimbot_State.currentTarget = nil
            if Aimbot_State.aimConnection then
                Aimbot_State.aimConnection:Disconnect()
                Aimbot_State.aimConnection = nil
            end
        end
    end
}, "AimbotToggle")

Aimbot:CreateSlider({
    Name = "FOV Radius",
    Range = {10, 1000},
    Increment = 10,
    CurrentValue = 200,
    Callback = function(Value)
        Aimbot_State.config.FOV_RADIUS = Value
        if Aimbot_State.fovCircle then Aimbot_State.fovCircle.Radius = Value end
    end
}, "FOVSlider")

Aimbot:CreateToggle({
    Name = "Show FOV Circle",
    Description = "Toggle FOV circle visibility",
    CurrentValue = true,
    Callback = function(Value)
        Aimbot_State.config.SHOW_FOV_CIRCLE = Value
    end
}, "FOVToggle")

Aimbot:CreateDropdown({
    Name = "Whitelist Players",
    Description = "Select players to ignore when aiming",
    Options = updatePlayerList(),
    CurrentOption = {},
    MultipleOptions = true,
    Callback = function(Options)
        Aimbot_State.config.WHITELIST = {}
        local opts = type(Options) == "table" and Options or {Options}
        for _, name in pairs(opts) do
            Aimbot_State.config.WHITELIST[name] = true
        end
        Aimbot_State.config.WHITELISTED_PLAYERS = Options
    end
}, "WhitelistDropdown")

-- Event Handlers
game.Players.PlayerAdded:Connect(function(p)
    wait(1)
    cleanWhitelist()
end)

game.Players.PlayerRemoving:Connect(function(p)
    if Aimbot_State.config.WHITELIST[p.Name] then
        Aimbot_State.config.WHITELIST[p.Name] = nil
    end
    if Aimbot_State.currentTarget == p then 
        Aimbot_State.currentTarget = nil
    end
    cleanWhitelist()
end)

-- Main Loop
game:GetService("RunService").RenderStepped:Connect(function()
    local ctrl = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftControl)
    
    if Aimbot_State.config.AIMBOT_ENABLED then
        -- Check for left control activation
        if ctrl and not Aimbot_State.config.wasLeftControlDown then
            local target = findTarget()
            if target then
                aimNormal(target)
            end
        end
        
        Aimbot_State.config.wasLeftControlDown = ctrl
    end
    
    updateVisuals()
end)

-- FOV Toggle
game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.O then
        Aimbot_State.config.SHOW_FOV_CIRCLE = not Aimbot_State.config.SHOW_FOV_CIRCLE
    end
end)
----------------------------------------------------------------------------------------------------------------------------
--COMBAT (Optimized)
----------------------------------------------------------------------------------------------------------------------------

-- Consolidated state management for combat
local Combat_State = {
    enabled = false,
    customRange = 50,
    originalAttributes = {},
    meleeWeapons = {
        ["Axe"] = {speed = 1.4, range = 6.5},
        ["Barbed Baseball Bat"] = {speed = 1.6, range = 7.5},
        ["Baseball Bat"] = {speed = 1.6, range = 7.5},
        ["Bike Lock"] = {speed = 1.9, range = 6},
        ["Bronze Mop"] = {speed = 1.5, range = 6.5},
        ["Chair Leg"] = {speed = 1.6, range = 6.5},
        ["Butcher Knife"] = {speed = 1.6, range = 6},
        ["Combat Axe"] = {speed = 1.6, range = 6.5},
        ["Crowbar"] = {speed = 1.6, range = 7},
        ["Diamond Mop"] = {speed = 1.5, range = 6.5},
        ["Frying Pan"] = {speed = 1.7, range = 6.5},
        ["Gold Mop"] = {speed = 1.5, range = 6.5},
        ["Hammer"] = {speed = 1.75, range = 6},
        ["Machette"] = {speed = 1.8, range = 7.25},
        ["Metal Baseball Bat"] = {speed = 1.6, range = 7.5},
        ["Metal Pipe"] = {speed = 1.55, range = 6.5},
        ["Mop"] = {speed = 1.5, range = 6.5},
        ["Nailed Wooden Board"] = {speed = 1.4, range = 6.5},
        ["Pool Cue"] = {speed = 1.7, range = 7.5},
        ["Rolling Pin"] = {speed = 1.75, range = 6.5},
        ["Rusty Shovel"] = {speed = 1.2, range = 7},
        ["Shank"] = {speed = 2, range = 5.5},
        ["Shovel"] = {speed = 1.2, range = 67.5},
        ["Silver Mop"] = {speed = 1.5, range = 6.5},
        ["Sledge Hammer"] = {speed = 1.1, range = 7.25},
        ["Switchblade"] = {speed = 2, range = 5.5},
        ["Tactical Axe"] = {speed = 1.75, range = 6.5},
        ["Tactical Knife"] = {speed = 2.2, range = 5.75},
        ["Tactical Shovel"] = {speed = 2, range = 6.75},
        ["Taser"] = {speed = 2, range = 5.25},
        ["Tire Iron"] = {speed = 1.6, range = 6.5},
        ["Wooden Board"] = {speed = 1.45, range = 6.5},
        ["Wrench"] = {speed = 1.5, range = 6},
        ["Fists"] = {speed = 1, range = 5}
    }
}

-- Function to store original attributes of a tool
local function StoreOriginalAttributes(tool)
    if not tool or Combat_State.originalAttributes[tool] then return end
    
    local weaponData = Combat_State.meleeWeapons[tool.Name]
    if not weaponData then return end
    
    Combat_State.originalAttributes[tool] = {}
    
    for attrName, attrValue in pairs(tool:GetAttributes()) do
        if type(attrValue) == "number" then
            Combat_State.originalAttributes[tool][attrName] = attrValue
        end
    end
end

-- Function to modify or restore attributes for detected melee weapons
local function ModifyMeleeAttributes(tool, shouldModify)
    if not tool then return end
    
    -- Check if this tool is a known melee weapon
    local weaponData = Combat_State.meleeWeapons[tool.Name]
    if not weaponData then return end
    
    -- Wait a brief moment for tool to fully load
    wait(0.1)
    
    -- Store original attributes if not already stored
    StoreOriginalAttributes(tool)
    
    if shouldModify then
        -- Get all attributes
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == "number" then
                -- Check if this attribute matches the expected speed value
                if math.abs(attrValue - weaponData.speed) < 0.01 then
                    tool:SetAttribute(attrName, 0)  -- Set speed to 0
                end
                
                -- Check if this attribute matches the expected range value
                if math.abs(attrValue - weaponData.range) < 0.01 then
                    tool:SetAttribute(attrName, Combat_State.customRange)  -- Set range to custom value
                end
            end
        end
    else
        -- Restore original attributes
        if Combat_State.originalAttributes[tool] then
            for attrName, originalValue in pairs(Combat_State.originalAttributes[tool]) do
                tool:SetAttribute(attrName, originalValue)
            end
        end
    end
end

-- Function to modify/restore existing tools
local function ProcessExistingTools(shouldModify)
    if not player.Character then return end
    
    -- Check currently equipped tools
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA("Tool") then
            ModifyMeleeAttributes(item, shouldModify)
        end
    end
    
    -- Check all tools in backpack
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA("Tool") then
            ModifyMeleeAttributes(item, shouldModify)
        end
    end
end

-- Function to handle new tools being added
local function HandleNewTool(newItem)
    if newItem:IsA("Tool") and Combat_State.enabled then
        ModifyMeleeAttributes(newItem, true)
    end
end

-- Set up automatic detection for NEW tools added to backpack
player.Backpack.ChildAdded:Connect(HandleNewTool)

-- Set up automatic detection for NEW tools equipped to character
player.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(HandleNewTool)
end)

-- Also set up monitoring for current character if it exists
if player.Character then
    player.Character.ChildAdded:Connect(HandleNewTool)
end

-- Luna Toggle Implementation
Combat:CreateToggle({
    Name = "Melee Weapon Modifier",
    Description = "Modifies melee weapon speed and range attributes",
    CurrentValue = false,
    Callback = function(Value)
        Combat_State.enabled = Value
        
        if Combat_State.enabled then
            -- Enable: Modify all existing tools
            ProcessExistingTools(true)
        else
            -- Disable: Restore all existing tools to original values
            ProcessExistingTools(false)
        end
    end
}, "MeleeModifier")

-- Luna Slider Implementation for Range
Combat:CreateSlider({
    Name = "Weapon Range",
    Range = {10, 50}, -- Range from 10 to 50
    Increment = 1, -- Change by 1 unit
    CurrentValue = 50, -- Starting value
    Callback = function(Value)
        Combat_State.customRange = Value
        
        -- If modifier is currently enabled, update all existing weapons with new range
        if Combat_State.enabled then
            ProcessExistingTools(true)
        end
    end
}, "WeaponRange")
----------------------------------------------------------------------------------------------------------------------------
--AUTO FINISH (Optimized)
----------------------------------------------------------------------------------------------------------------------------

-- Consolidated state management for auto finish
local AutoFinish_State = {
    enabled = false,
    distance = 10,
    whitelist = {},
    running = false
}

-- Function to get current player names for dropdown
local function getPlayerNames()
    local names = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player then
            table.insert(names, p.Name)
        end
    end
    return names
end

-- Function to clean whitelist of players who left
local function cleanWhitelist()
    local currentPlayers = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        currentPlayers[p.Name] = true
    end
    
    -- Remove players from whitelist who are no longer in game
    for playerName, _ in pairs(AutoFinish_State.whitelist) do
        if not currentPlayers[playerName] then
            AutoFinish_State.whitelist[playerName] = nil
        end
    end
end

-- Luna UI Components
Combat:CreateToggle({
    Name = "Auto Finish",
    Description = "Finish downed players (except whitelisted)",
    CurrentValue = false,
    Callback = function(v) 
        AutoFinish_State.enabled = v 
    end
}, "AutoFinishToggle")

Combat:CreateSlider({
    Name = "Finish Distance",
    Range = {1, 20},
    Increment = 1,
    CurrentValue = 10,
    Callback = function(v) 
        AutoFinish_State.distance = v 
    end
}, "AutoFinishDistance")

Combat:CreateDropdown({
    Name = "Whitelist Players",
    Description = "Select players to NOT auto finish",
    Options = getPlayerNames(),
    CurrentOption = {},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Options)
        -- Clear current whitelist
        AutoFinish_State.whitelist = {}
        
        -- Add selected players to whitelist
        local selectedPlayers = type(Options) == "table" and Options or {Options}
        for _, playerName in pairs(selectedPlayers) do
            AutoFinish_State.whitelist[playerName] = true
        end
    end
}, "AutoFinishWhitelist")

-- Handle players leaving
game.Players.PlayerRemoving:Connect(function(leavingPlayer)
    -- Remove from whitelist if they leave
    if AutoFinish_State.whitelist[leavingPlayer.Name] then
        AutoFinish_State.whitelist[leavingPlayer.Name] = nil
    end
end)

-- Start the main loop if not already running
if not AutoFinish_State.running then
    AutoFinish_State.running = true
    spawn(function()
        while AutoFinish_State.running do
            -- Clean whitelist every 30 seconds to remove disconnected players
            if tick() % 30 < 0.1 then
                cleanWhitelist()
            end
            
            if AutoFinish_State.enabled then
                for _, v in ipairs(game.Players:GetPlayers()) do
                    -- Skip if player is whitelisted or is the local player
                    if v ~= player and not AutoFinish_State.whitelist[v.Name] then
                        local c = v.Character
                        if c then
                            local h = c:FindFirstChild("HumanoidRootPart")
                            if h then
                                local p = h:FindFirstChild("FinishPrompt")
                                if p and p:IsA("ProximityPrompt") then
                                    p.HoldDuration = 0
                                    p.MaxActivationDistance = AutoFinish_State.distance
                                    pcall(function()
                                        p:InputHoldBegin()
                                        p:InputHoldEnd()
                                    end)
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.1)
        end
    end)
end
