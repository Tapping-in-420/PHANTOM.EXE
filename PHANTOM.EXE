-- Obfuscated with Free Lua Obfuscator
-- Level: Basic | Generated: 2025-06-03T23:08:03.130Z
-- Reverse engineering prohibited


-- Obfuscated string pool
local _STR0 = "aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL05lYnVsYS1Tb2Z0d29ya3MvTHVuYS1JbnRlcmZhY2UtU3VpdGUvcmVmcy9oZWFkcy9tYWluL3NvdXJjZS5sdWE="
local _STR1 = "SHVtYW5vaWQ="
local _STR2 = "SHVtYW5vaWRSb290UGFydA=="
local _STR3 = "UGF0aGZpbmRpbmdTZXJ2aWNl"
local _STR4 = "VHdlZW5TZXJ2aWNl"
local _STR5 = "UnVuU2VydmljZQ=="
local _STR6 = "VXNlcklucHV0U2VydmljZQ=="
local _STR7 = "UGhhbnRvbS5leGU="
local _STR8 = "ODI3OTUzMjcxNjk3ODI="
local _STR9 = "QnkgUGhhbnRvbQ=="
local _STR10 = "QmlnIEh1Yg=="
local _STR11 = "UGhhbnRvbSBLZXkuZXhl"
local _STR12 = "S2V5IFN5c3RlbQ=="
local _STR13 = "QmVzdCBLZXkgU3lzdGVtIEV2ZXIhIEFsc28sIFBsZWFzZSBVc2UgQSBIV0lEIEtleXN5c3RlbSBsaWtlIFBlbGljYW4sIEx1YXJtb3IgZXRjLiB0aGF0IHByb3ZpZGUga2V5IHN0cmluZ3MgYmFzZWQgb24geW91ciBIV0lEIHNpbmNlIHB1dHRpbmcgYSBzaW1wbGUgc3RyaW5nIGlzIHZlcnkgZWFzeSB0byBieXBhc3M="
local _STR14 = "UGhhbnRvbQ=="
local _STR15 = "TGluaw=="
local _STR16 = ""
local _STR17 = "UGxheWVy"
local _STR18 = "cGVyc29u"
local _STR19 = "TWF0ZXJpYWw="
local _STR20 = "QWltYm90"
local _STR21 = "Z3BzX2ZpeGVk"
local _STR22 = "VmlzdWFscw=="
local _STR23 = "dmlzaWJpbGl0eQ=="
local _STR24 = "Q29tYmF0"
local _STR25 = "Z2F2ZWw="
local _STR26 = "V2VhcG9u"
local _STR27 = "c2hpZWxk"
local _STR28 = "VmVoaWNsZQ=="
local _STR29 = "ZGlyZWN0aW9uc19jYXI="
local _STR30 = "Sm9iIEF1dG9GYXJt"
local _STR31 = "ZXVyb19zeW1ib2w="
local _STR32 = "Sm9iIEF1dG9GYXJtIEluZm8="
local _STR33 = "QkVUQSE="
local _STR34 = "RmFpbGVkIHRvIGdldCBjaGFyYWN0ZXIgcmVmZXJlbmNlcw=="
local _STR35 = "Q2xlYW5pbmcgdXAgYXV0byBmYXJtIHNjcmlwdC4uLg=="
local _STR36 = "QXV0byBmYXJtIHNjcmlwdCBzdG9wcGVkIGFuZCBjbGVhbmVkIHVwLg=="
local _STR37 = "Q2hhcmFjdGVyIGRpZWQuIFdhaXRpbmcgZm9yIHJlc3Bhd24uLi4="
local _STR38 = "V2FpdGluZyBmb3IgY2hhcmFjdGVyIHRvIHJlc3Bhd24uLi4="
local _STR39 = "Q2hhcmFjdGVyIHJlc3Bhd25lZCEgQ29udGludWluZyBhdXRvIGZhcm0uLi4="
local _STR40 = "Tm8gY2hhcmFjdGVyIGZvdW5kLCB3YWl0aW5nIGZvciByZXNwYXduLi4u"
local _STR41 = "UmVhY2hlZCBkZXN0aW5hdGlvbiE="
local _STR42 = "UGF0aCBjb21wdXRhdGlvbiBmYWlsZWQ6"
local _STR43 = "VXNpbmcgZGlyZWN0IHR3ZWVuIHRvIHRhcmdldCBpbnN0ZWFkLi4u"
local _STR44 = "VHJpZ2dlcmluZyBqb2IgYXBwbGljYXRpb24gVUkuLi4="
local _STR45 = "Sm9iIFVJIHRyaWdnZXJlZCEgUGxlYXNlIGNsaWNrIHRoZSBBcHBseSBidXR0b24gbWFudWFsbHku"
local _STR46 = "V2FpdGluZyBmb3IgeW91IHRvIGNsaWNrIHRoZSBBcHBseSBidXR0b24uLi4="
local _STR47 = "Q29udGludWluZyB3aXRoIHNoZWxmIHN0b2NraW5nIHdvcmsuLi4="
local _STR48 = "Tm93IGZpcmluZyBwcm94aW1pdHkgcHJvbXB0IGZvciBzaGVsZiBzdG9ja2luZyBib3guLi4="
local _STR49 = "RmlyZWQgcHJveGltaXR5IHByb21wdCBmb3IgdGhlIHNoZWxmIHN0b2NraW5nIGJveCE="
local _STR50 = "U2VhcmNoaW5nIGZvciBiZWFjb24uYmFzZS4uLg=="
local _STR51 = "QmVhY29uLkJhc2Ugbm90IGZvdW5kISBCb3ggbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGRlbGl2ZXJlZCBvciB0aGVyZSdzIGFuIGlzc3VlLg=="
local _STR52 = "Rm91bmQgQmVhY29uLkJhc2UsIG1vdmluZyB0byBpdCBub3cuLi4="
local _STR53 = "UmVhY2hlZCB0aGUgYmVhY29uIQ=="
local _STR54 = "Qm94IHN1Y2Nlc3NmdWxseSBkZWxpdmVyZWQhIEJlYWNvbiBubyBsb25nZXIgZXhpc3RzLg=="
local _STR55 = "V2FpdGluZyBmb3IgY2hhcmFjdGVyLi4u"
local _STR56 = "RmFpbGVkIHRvIHJlYWNoIGpvYiBsb2NhdGlvbiwgcmV0cnlpbmcuLi4="
local _STR57 = "RmFpbGVkIHRvIGFwcGx5IGZvciBqb2IsIHJldHJ5aW5nLi4u"
local _STR58 = "Q2hhcmFjdGVyIGxvc3QsIHdhaXRpbmcgZm9yIHJlc3Bhd24uLi4="
local _STR59 = "LS0tIFN0YXJ0aW5nIGJveCAj"
local _STR60 = "IC0tLQ=="
local _STR61 = "TW92aW5nIHRvIGJveCBwaWNrdXAgbG9jYXRpb24uLi4="
local _STR62 = "RmFpbGVkIHRvIG1vdmUgdG8gcGlja3VwIGxvY2F0aW9uLCByZXRyeWluZy4uLg=="
local _STR63 = "Qm94ICM="
local _STR64 = "IHBpY2tlZCB1cCBzdWNjZXNzZnVsbHk="
local _STR65 = "IGRlbGl2ZXJlZCBzdWNjZXNzZnVsbHkh"
local _STR66 = "SXNzdWUgd2l0aCBkZWxpdmVyeSBmb3IgYm94ICM="
local _STR67 = "LCBjb250aW51aW5nIGFueXdheS4uLg=="
local _STR68 = "RmFpbGVkIHRvIHBpY2sgdXAgYm94LCByZXRyeWluZy4uLg=="
local _STR69 = "LS0tIENvbXBsZXRlZCBjeWNsZSAj"
local _STR70 = "UmVzdGFydGluZyBkdWUgdG8gY2hhcmFjdGVyIGlzc3VlLi4u"
local _STR71 = "QXV0byBmYXJtIGV4ZWN1dGlvbiB0ZXJtaW5hdGVkLg=="
local _STR72 = "UXVpY2stMTEgQXV0b0Zhcm0="
local _STR73 = "QXV0byBmYXJtIHN0YXJ0ZWQh"
local _STR74 = "QXV0byBmYXJtIHN0b3BwZWQh"
local _STR75 = "UXVpY2sxMVRvZ2dsZQ=="
local _STR76 = "RmFpbGVkIHRvIGdldCBqYW5pdG9yIGNoYXJhY3RlciByZWZlcmVuY2Vz"
local _STR77 = "Q2xlYW5pbmcgdXAgamFuaXRvciBmYXJtIHNjcmlwdC4uLg=="
local _STR78 = "SmFuaXRvciBmYXJtIHNjcmlwdCBzdG9wcGVkIGFuZCBjbGVhbmVkIHVwLg=="
local _STR79 = "Q2hhcmFjdGVyIHJlc3Bhd25lZCEgQ29udGludWluZyBqYW5pdG9yIGZhcm0uLi4="
local _STR80 = "VmVjdG9yMw=="
local _STR81 = "RmFpbGVkIHRvIGNvbXB1dGUgcGF0aDo="
local _STR82 = "Q2hhcmFjdGVyIGxvc3QgZHVyaW5nIG1vdmVtZW50LCB3YWl0aW5nIGZvciByZXNwYXduLi4u"
local _STR83 = "Q2hhcmFjdGVyIGxvc3QgZHVyaW5nIGZpbmFsIG1vdmVtZW50LCB3YWl0aW5nIGZvciByZXNwYXduLi4u"
local _STR84 = "UmVhY2hlZCBkZXN0aW5hdGlvbg=="
local _STR85 = "Tm8gY2hhcmFjdGVyIGZvdW5kIGZvciB0b3VjaCBpbnRlcmFjdGlvbiwgd2FpdGluZyBmb3IgcmVzcGF3bi4uLg=="
local _STR86 = "VG91Y2hJbnRlcmVzdA=="
local _STR87 = "RmlyZWQgdG91Y2ggZXZlbnQ="
local _STR88 = "VG91Y2hJbnRlcmVzdCBub3QgZm91bmQ="
local _STR89 = "TG9va2luZyBmb3IgQXBwbHkgYnV0dG9uLi4u"
local _STR90 = "QXBwbHkgdG8gSmFuaXRvciBqb2I="
local _STR91 = "U2NyZWVuR3Vp"
local _STR92 = "QXBwbHkgdG8gSmFuaXRvciBqb2I/"
local _STR93 = "VGV4dExhYmVs"
local _STR94 = "QXBwbHkgdG8gSmFuaXRvcg=="
local _STR95 = "Rm91bmQgam9iIGRpYWxvZyB3aXRoIHRleHQ6IA=="
local _STR96 = "QXBwbHk="
local _STR97 = "VGV4dEJ1dHRvbg=="
local _STR98 = "Rm91bmQgQXBwbHkgYnV0dG9uIQ=="
local _STR99 = "TWV0aG9kIDE6IERpcmVjdCBNb3VzZUJ1dHRvbjFDbGljayBmaXJlIHN1Y2NlZWRlZA=="
local _STR100 = "TWV0aG9kIDI6IGdldGNvbm5lY3Rpb25zIGZpcmUgc3VjY2VlZGVk"
local _STR101 = "U3VjY2Vzc2Z1bGx5IGNsaWNrZWQgQXBwbHkgYnV0dG9uIQ=="
local _STR102 = "Q291bGQgbm90IGZpbmQgQXBwbHkgYnV0dG9uIGluIGFueSBHVUk="
local _STR103 = "U2VhcmNoaW5nIGZvciBzbWFsbCBwdWRkbGVzIG9ubHkuLi4="
local _STR104 = "U21hbGxQdWRkbGU="
local _STR105 = "Rm91bmQgbmFtZWQgU21hbGxQdWRkbGU="
local _STR106 = "U21hbGw="
local _STR107 = "Rm91bmQgcHVkZGxlIHdpdGggU21hbGwgaW4gbmFtZTog"
local _STR108 = "RXhjbHVkaW5nIHB1ZGRsZSBhdCBpbmRleCA="
local _STR109 = "Tm8gY2hhcmFjdGVyIGZvdW5kIGZvciBwdWRkbGUgY2xlYW5pbmcsIHdhaXRpbmcgZm9yIHJlc3Bhd24uLi4="
local _STR110 = "Q2xlYW5pbmcgcHVkZGxlOiA="
local _STR111 = "Q2xlYW5pbmcgYSBzbWFsbCBwdWRkbGU6IA=="
local _STR112 = "VG91Y2hpbmcgcHVkZGxlIHRvIHN0YXJ0IGNsZWFuaW5nLi4u"
local _STR113 = "V2FpdGluZyA="
local _STR114 = "IHNlY29uZHMgdG8gY2xlYW4gcHVkZGxlLi4u"
local _STR115 = "UHVkZGxlIGNsZWFuaW5nIGNvbXBsZXRlZA=="
local _STR116 = "UHJveGltaXR5UHJvbXB0"
local _STR117 = "QWN0aXZhdGluZyBwcm94aW1pdHkgcHJvbXB0IG9uIHB1ZGRsZS4uLg=="
local _STR118 = "Tm8gZGlyZWN0IGludGVyYWN0aW9uIG1ldGhvZCBmb3VuZCwgd2FpdGluZyBhdCBwdWRkbGUuLi4="
local _STR119 = "U3RhcnRpbmcgY29udGludW91cyBwdWRkbGUgY2xlYW5pbmcgbG9vcC4uLg=="
local _STR120 = "Q2hhcmFjdGVyIGxvc3QgZHVyaW5nIHB1ZGRsZSBsb29wLCB3YWl0aW5nIGZvciByZXNwYXduLi4u"
local _STR121 = "Rm91bmQg"
local _STR122 = "IHB1ZGRsZXMgdG8gdmlzaXQ="
local _STR123 = "Tm8gcHVkZGxlcyBmb3VuZCwgd2FpdGluZyBiZWZvcmUgcmV0cnlpbmcuLi4="
local _STR124 = "Q2hhcmFjdGVyIGxvc3QgYmVmb3JlIHB1ZGRsZSA="
local _STR125 = "LCBicmVha2luZyBsb29wLi4u"
local _STR126 = "TW92aW5nIHRvIHB1ZGRsZSA="
local _STR127 = "Lw=="
local _STR128 = "IC0g"
local _STR129 = "RmFpbGVkIHRvIHJlYWNoIHB1ZGRsZSA="
local _STR130 = "Q29tcGxldGVkIG9uZSBjbGVhbmluZyBjeWNsZSwgd2FpdGluZyBiZWZvcmUgc3RhcnRpbmcgdGhlIG5leHQgY3ljbGUuLi4="
local _STR131 = "U3RhcnRpbmcgamFuaXRvciBqb2IgYXBwbGljYXRpb24gc2VxdWVuY2U="
local _STR132 = "LSBGaXhlZCBZIHBvc2l0aW9uOiA="
local _STR133 = "LSBUd2VlbiBzcGVlZDog"
local _STR134 = "IChsb3dlciA9IGZhc3Rlcik="
local _STR135 = "LSBCYXNlIHdhaXQgdGltZSBwZXIgcHVkZGxlOiA="
local _STR136 = "IHNlY29uZHM="
local _STR137 = "LSBMb29wIHdhaXQgdGltZTog"
local _STR138 = "LSBDTEVBTklORyBTTUFMTCBQVURETEVTIE9OTFk="
local _STR139 = "U3VjY2Vzc2Z1bGx5IGFwcGxpZWQgZm9yIGphbml0b3Igam9iIQ=="
local _STR140 = "RmFpbGVkIHRvIGNsaWNrIEFwcGx5IGJ1dHRvbi4gVHJ5aW5nIHRvIHN0YXJ0IHB1ZGRsZSBjbGVhbmluZyBhbnl3YXkuLi4="
local _STR141 = "RmFpbGVkIHRvIGludGVyYWN0IHdpdGggdGhlIFRvdWNoUGFydCwgcmV0cnlpbmcuLi4="
local _STR142 = "RmFpbGVkIHRvIHJlYWNoIHRhcmdldCBsb2NhdGlvbiwgcmV0cnlpbmcuLi4="
local _STR143 = "QnVyZ2VyIFBsYWNlIEF1dG9GYXJt"
local _STR144 = "SmFuaXRvciBmYXJtIHN0YXJ0ZWQh"
local _STR145 = "SmFuaXRvciBmYXJtIHN0b3BwZWQh"
local _STR146 = "SmFuaXRvclRvZ2dsZQ=="
local _STR147 = "TW9kZWw="
local _STR148 = "R3JpbGxBcmVh"
local _STR149 = "UHJvZ3Jlc3NCYXJGcmFtZQ=="
local _STR150 = "TWFpbkZyYW1l"
local _STR151 = "SW5wdXRGcmFtZQ=="
local _STR152 = "QmFyQW1vdW50"
local _STR153 = "Q29va2VkUGVyZmVjdGx5"
local _STR154 = "Y29va2luZ19jb21wbGV0ZQ=="
local _STR155 = "ZmluaXNoX2Nvb2tpbmc="
local _STR156 = "am9iX3Rhc2tfY29tcGxldGU="
local _STR157 = "c3RlYWtob3VzZV9jb29r"
local _STR158 = "cGVyZmVjdA=="
local _STR159 = "RmluaXNoQmFy"
local _STR160 = "QXR0YWNobWVudA=="
local _STR161 = "QmFzZVBhcnQ="
local _STR162 = "QmVhY29u"
local _STR163 = "QmFzZQ=="
local _STR164 = "U3RlYWtob3VzZSBBdXRvIEZhcm0="
local _STR165 = "U3RlYWtob3VzZUZhcm1Ub2dnbGU="
local _STR166 = "RXJyb3IgaW4gYXV0byBjb29raW5nOiA="
local _STR167 = "UmVwbGljYXRlZFN0b3JhZ2U="
local _STR168 = "MzQ1MDc5NDE4NA=="
local _STR169 = "Q2xlYW5pbmcgdXAgQVRNIGhhY2sgc2NyaXB0Li4u"
local _STR170 = "QVRNIGhhY2sgc2NyaXB0IHN0b3BwZWQgYW5kIGNsZWFuZWQgdXAu"
local _STR171 = "QVRNIEhhY2sgc3RhcnRlZCEgVGhlIHNjcmlwdCB3aWxsIGF1dG9tYXRpY2FsbHkgd2luIEFUTSBtaW5pZ2FtZXMu"
local _STR172 = "QXV0by13aW4gZXJyb3I6IA=="
local _STR173 = "QVRNIEhhY2sgQXV0b1dpbg=="
local _STR174 = "QVRNIEhhY2sgc3RhcnRlZCE="
local _STR175 = "QVRNIEhhY2sgc3RvcHBlZCE="
local _STR176 = "QVRNSGFja1RvZ2dsZQ=="
local _STR177 = "MkQgQm94"
local _STR178 = "TGluZQ=="
local _STR179 = "bnVtYmVy"
local _STR180 = "SGVhZA=="
local _STR181 = "M0QgQm94"
local _STR182 = "RVNQIFR5cGU="
local _STR183 = "RVNQRHJvcGRvd24="
local _STR184 = "Qm94IEVTUA=="
local _STR185 = "RVNQVG9nZ2xl"
local _STR186 = "TmFtZVRhZw=="
local _STR187 = "QmlsbGJvYXJkR3Vp"
local _STR188 = "TmFtZSBFU1A="
local _STR189 = "TmFtZVRhZ3NUb2dnbGU="
local _STR190 = "TGVnZW5kYXJ5"
local _STR191 = "T21lZ2E="
local _STR192 = "VW5jb21tb24="
local _STR193 = "RG91YmxlIEJhcnJlbA=="
local _STR194 = "RXBpYw=="
local _STR195 = "UmFyZQ=="
local _STR196 = "SHVudGluZyBSaWZsZQ=="
local _STR197 = "QmFyYmVkIEJhc2ViYWxsIEJhdA=="
local _STR198 = "QmFzZWJhbGwgQmF0"
local _STR199 = "QmlrZSBMb2Nr"
local _STR200 = "Q29tbW9u"
local _STR201 = "QnJvbnplIE1vcA=="
local _STR202 = "Q2hhaXIgTGVn"
local _STR203 = "QnV0Y2hlciBLbmlmZQ=="
local _STR204 = "Q29tYmF0IEF4ZQ=="
local _STR205 = "RGlhbW9uZCBNb3A="
local _STR206 = "RnJ5aW5nIFBhbg=="
local _STR207 = "R29sZCBNb3A="
local _STR208 = "TWV0YWwgQmFzZWJhbGwgQmF0"
local _STR209 = "TWV0YWwgUGlwZQ=="
local _STR210 = "TmFpbGVkIFdvb2RlbiBCb2FyZA=="
local _STR211 = "UG9vbCBDdWU="
local _STR212 = "Um9sbGluZyBQaW4="
local _STR213 = "UnVzdHkgU2hvdmVs"
local _STR214 = "U2lsdmVyIE1vcA=="
local _STR215 = "U2xlZGdlIEhhbW1lcg=="
local _STR216 = "VGFjdGljYWwgQXhl"
local _STR217 = "VGFjdGljYWwgS25pZmU="
local _STR218 = "VGFjdGljYWwgU2hvdmVs"
local _STR219 = "VGlyZSBJcm9u"
local _STR220 = "V29vZGVuIEJvYXJk"
local _STR221 = "cmJ4YXNzZXRpZDovLzEyNDU1NTQzMDU3NzE3OA=="
local _STR222 = "cmJ4YXNzZXRpZDovLzEzMjc4MTE3NDgzOTg0NA=="
local _STR223 = "cmJ4YXNzZXRpZDovLzc5NjU5MDc5OTg4MDIy"
local _STR224 = "cmJ4YXNzZXRpZDovLzg5MjQwNjQyMzc2NzE1"
local _STR225 = "cmJ4YXNzZXRpZDovLzgzNjI1NzY1NjM4MDM5"
local _STR226 = "cmJ4YXNzZXRpZDovLzEyMDkzNzYxNjI2NjkwMw=="
local _STR227 = "cmJ4YXNzZXRpZDovLzEzMzQxMTI5MTM5ODAwMg=="
local _STR228 = "cmJ4YXNzZXRpZDovLzk3ODQ2MTU0MzY2ODcw"
local _STR229 = "cmJ4YXNzZXRpZDovLzgxNTQ3NzA0OTY1MTUz"
local _STR230 = "cmJ4YXNzZXRpZDovLzczMzg3OTY1OTgyNjAz"
local _STR231 = "cmJ4YXNzZXRpZDovLzgwNTAxMDc5NDg5Nzc3"
local _STR232 = "cmJ4YXNzZXRpZDovLzkyNTIxMTAwMjk3Nzc2"
local _STR233 = "cmJ4YXNzZXRpZDovLzEzODQyNjAwMDE0MjgwNw=="
local _STR234 = "cmJ4YXNzZXRpZDovLzEwMTI3MTM3NTkzMDQwOQ=="
local _STR235 = "cmJ4YXNzZXRpZDovLzkwNTg4MzA1ODkyNzA3"
local _STR236 = "cmJ4YXNzZXRpZDovLzEwOTI5MDY5NTY1MjMzOA=="
local _STR237 = "cmJ4YXNzZXRpZDovLzEwMTExMTIyMjMxMjUwNw=="
local _STR238 = "cmJ4YXNzZXRpZDovLzEyNDE4NzU0Nzc4NzM5MA=="
local _STR239 = "cmJ4YXNzZXRpZDovLzcwMzkwMjAxNTA3ODM5"
local _STR240 = "cmJ4YXNzZXRpZDovLzEzMzA2MDY3MjY2OTI2MA=="
local _STR241 = "cmJ4YXNzZXRpZDovLzgyODMzMjA1MTc1NTE1"
local _STR242 = "cmJ4YXNzZXRpZDovLzg1Mzg4NDc3MzE0NzU5"
local _STR243 = "cmJ4YXNzZXRpZDovLzExNDQ2OTkwMzA2ODg3NQ=="
local _STR244 = "cmJ4YXNzZXRpZDovLzg4OTc3NTc2MzcyMDMx"
local _STR245 = "cmJ4YXNzZXRpZDovLzkwNDI0MTE1MTAxMjE5"
local _STR246 = "cmJ4YXNzZXRpZDovLzExNjg5ODM1MDk3ODE0OQ=="
local _STR247 = "cmJ4YXNzZXRpZDovLzg5MjAwMjg2NTMyNTI0"
local _STR248 = "cmJ4YXNzZXRpZDovLzEyNjk3Mjk5NDEyNzAzOQ=="
local _STR249 = "cmJ4YXNzZXRpZDovLzc4MDA3NDY3ODA1NTQ2"
local _STR250 = "cmJ4YXNzZXRpZDovLzEzNzU2MDQ2MTgzOTQ5OQ=="
local _STR251 = "cmJ4YXNzZXRpZDovLzcwNjg1NDU5ODkxMzUz"
local _STR252 = "cmJ4YXNzZXRpZDovLzg4MDA5MjE4MDkyOTcz"
local _STR253 = "cmJ4YXNzZXRpZDovLzcxNDg5MDMxOTI2NTk0"
local _STR254 = "cmJ4YXNzZXRpZDovLzEzMzU4MjA4NDY3MDg2Ng=="
local _STR255 = "cmJ4YXNzZXRpZDovLzExNDQyMTU4ODQwOTUyNQ=="
local _STR256 = "cmJ4YXNzZXRpZDovLzEwMjc3NTM3Nzc4MDA5MA=="
local _STR257 = "cmJ4YXNzZXRpZDovLzkyNzMzNzExOTU2NzY0"
local _STR258 = "cmJ4YXNzZXRpZDovLzczOTYzMTcwODI5NDcz"
local _STR259 = "cmJ4YXNzZXRpZDovLzczNDMxNDAwMjY0NzMz"
local _STR260 = "cmJ4YXNzZXRpZDovLzgwMjYzMTk5NjIzMjA1"
local _STR261 = "cmJ4YXNzZXRpZDovLzkzNTQ2NjgzMDczNTI3"
local _STR262 = "cmJ4YXNzZXRpZDovLzkzMDYwNTE1NzM1ODY1"
local _STR263 = "cmJ4YXNzZXRpZDovLzEyODUyMTQ3MjQ4Nzk2Nw=="
local _STR264 = "cmJ4YXNzZXRpZDovLzEzODE4ODQ2MzkxODkxMQ=="
local _STR265 = "cmJ4YXNzZXRpZDovLzkyMzQzMDU3NzgxODcw"
local _STR266 = "cmJ4YXNzZXRpZDovLzEyNTY4MTg5MjM0OTY5MQ=="
local _STR267 = "cmJ4YXNzZXRpZDovLzEyMDQ1MDA2OTcyOTg0OQ=="
local _STR268 = "cmJ4YXNzZXRpZDovLzczMzAyNjMzOTc2ODcz"
local _STR269 = "cmJ4YXNzZXRpZDovLzc4NjcxODM3MjQzNTI5"
local _STR270 = "V2VhcG9uRVNQQWRvcm5tZW50"
local _STR271 = "VG9vbA=="
local _STR272 = "QmFja3BhY2s="
local _STR273 = "RnJhbWU="
local _STR274 = "VUlDb3JuZXI="
local _STR275 = "VUlHcmFkaWVudA=="
local _STR276 = "VUlTdHJva2U="
local _STR277 = "SW1hZ2VMYWJlbA=="
local _STR278 = "V2VhcG9uIEVTUA=="
local _STR279 = "U2hvd3Mgd2VhcG9ucyB0aGF0IG90aGVyIHBsYXllcnMgYXJlIGNhcnJ5aW5n"
local _STR280 = "V2VhcG9uRVNQ"
local _STR281 = "YWNjZWxlcmF0aW9u"
local _STR282 = "YnJha2luZw=="
local _STR283 = "ZGVjZWxlcmF0aW9u"
local _STR284 = "Zm9yd2FyZE1heFNwZWVk"
local _STR285 = "aGFuZEJyYWtlVG9ycXVl"
local _STR286 = "bWF4U3BlZWRUb3JxdWU="
local _STR287 = "cmV2ZXJzZU1heFNwZWVk"
local _STR288 = "U2xpZGVy"
local _STR289 = "QXBwbHkgTW90b3IgQ2hhbmdlcw=="
local _STR290 = "QXBwbHkgYWxsIHNsaWRlciB2YWx1ZXMgdG8gdmVoaWNsZSBtb3RvcnM="
local _STR291 = "VmVoaWNsZXM="
local _STR292 = "Rm9sZGVy"
local _STR293 = "TW90b3Jz"
local _STR294 = "U3BlZWRNdWx0aXBsaWVy"
local _STR295 = "c3ByaW50"
local _STR296 = "U3VwZXIgU3BlZWQ="
local _STR297 = "U3BlZWQgQm9vc3Q="
local _STR298 = "U3BlZWRCb29zdFRvZ2dsZQ=="
local _STR299 = "U3VwZXIgSnVtcA=="
local _STR300 = "SnVtcCBCb29zdA=="
local _STR301 = "SnVtcEJvb3N0VG9nZ2xl"
local _STR302 = "SW5maW5pdGUgU3RhbWluYQ=="
local _STR303 = "TmV2ZXIgcnVuIG91dCBvZiBzdGFtaW5hIHdoaWxlIHNwcmludGluZw=="
local _STR304 = "SW5maW5pdGVTdGFtaW5hVG9nZ2xl"
local _STR305 = "RzM="
local _STR306 = "YWNjdXJhY3k="
local _STR307 = "ZmlyZVJhdGU="
local _STR308 = "bWFnU2l6ZQ=="
local _STR309 = "cmFuZ2U="
local _STR310 = "cmVjb2ls"
local _STR311 = "cmVsb2FkVGltZQ=="
local _STR312 = "QUs0Nw=="
local _STR313 = "QW5hY29uZGE="
local _STR314 = "Qzk="
local _STR315 = "Q3Jvc3Nib3c="
local _STR316 = "RHJhY28="
local _STR317 = "RmlyZXdvcmsgTGF1bmNoZXI="
local _STR318 = "R2xvY2s="
local _STR319 = "TTI0"
local _STR320 = "TVA1"
local _STR321 = "UDIyNg=="
local _STR322 = "UlBH"
local _STR323 = "UmVtaW5ndG9u"
local _STR324 = "U2F3bm9mZg=="
local _STR325 = "VXpp"
local _STR326 = "QWNjdXJhY3kgTXVsdGlwbGllcg=="
local _STR327 = "QWNjdXJhY3lNdWx0aXBsaWVyU2xpZGVy"
local _STR328 = "RmlyZSBSYXRlIE11bHRpcGxpZXI="
local _STR329 = "RmlyZVJhdGVNdWx0aXBsaWVyU2xpZGVy"
local _STR330 = "TWFnYXppbmUgU2l6ZSBNdWx0aXBsaWVy"
local _STR331 = "TWFnU2l6ZU11bHRpcGxpZXJTbGlkZXI="
local _STR332 = "UmFuZ2UgTXVsdGlwbGllcg=="
local _STR333 = "UmFuZ2VNdWx0aXBsaWVyU2xpZGVy"
local _STR334 = "UmVjb2lsIE11bHRpcGxpZXI="
local _STR335 = "UmVjb2lsTXVsdGlwbGllclNsaWRlcg=="
local _STR336 = "UmVsb2FkIFRpbWUgTXVsdGlwbGllcg=="
local _STR337 = "UmVsb2FkVGltZU11bHRpcGxpZXJTbGlkZXI="
local _STR338 = "R3VuIE1vZGlmaWVy"
local _STR339 = "RW5hYmxlL0Rpc2FibGUgZ3VuIG1vZGlmaWNhdGlvbnM="
local _STR340 = "R3VuTW9kaWZpZXJUb2dnbGU="
local _STR341 = "RGVhdGhTY3JlZW4="
local _STR342 = "RGVhdGhTY3JlZW5Ib2xkZXI="
local _STR343 = "UmVzcGF3bkJ1dHRvbkZyYW1l"
local _STR344 = "UmVzcGF3bkJ1dHRvbg=="
local _STR345 = "R3VpU2VydmljZQ=="
local _STR346 = "VmlydHVhbElucHV0TWFuYWdlcg=="
local _STR347 = "UGxheWVyR3Vp"
local _STR348 = "QXV0byBSZXNwYXdu"
local _STR349 = "QXV0b21hdGljYWxseSByZXNwYXduIHdoZW4geW91IGRpZQ=="
local _STR350 = "QXV0b1Jlc3Bhd25Ub2dnbGU="
local _STR351 = "Q2lyY2xl"
local _STR352 = "RW5hYmxlIEFpbWJvdA=="
local _STR353 = "SG9sZCBMZWZ0IENvbnRyb2wgdG8gYWN0aXZhdGUgYWltYm90"
local _STR354 = "QWltYm90VG9nZ2xl"
local _STR355 = "Rk9WIFJhZGl1cw=="
local _STR356 = "Rk9WU2xpZGVy"
local _STR357 = "U2hvdyBGT1YgQ2lyY2xl"
local _STR358 = "VG9nZ2xlIEZPViBjaXJjbGUgdmlzaWJpbGl0eQ=="
local _STR359 = "Rk9WVG9nZ2xl"
local _STR360 = "V2hpdGVsaXN0IFBsYXllcnM="
local _STR361 = "U2VsZWN0IHBsYXllcnMgdG8gaWdub3JlIHdoZW4gYWltaW5n"
local _STR362 = "dGFibGU="
local _STR363 = "V2hpdGVsaXN0RHJvcGRvd24="
local _STR364 = "QXhl"
local _STR365 = "Q3Jvd2Jhcg=="
local _STR366 = "SGFtbWVy"
local _STR367 = "TWFjaGV0dGU="
local _STR368 = "TW9w"
local _STR369 = "U2hhbms="
local _STR370 = "U2hvdmVs"
local _STR371 = "U3dpdGNoYmxhZGU="
local _STR372 = "VGFzZXI="
local _STR373 = "V3JlbmNo"
local _STR374 = "RmlzdHM="
local _STR375 = "TWVsZWUgV2VhcG9uIE1vZGlmaWVy"
local _STR376 = "TW9kaWZpZXMgbWVsZWUgd2VhcG9uIHNwZWVkIGFuZCByYW5nZSBhdHRyaWJ1dGVz"
local _STR377 = "TWVsZWVNb2RpZmllcg=="
local _STR378 = "V2VhcG9uIFJhbmdl"
local _STR379 = "V2VhcG9uUmFuZ2U="
local _STR380 = "QXV0byBGaW5pc2g="
local _STR381 = "RmluaXNoIGRvd25lZCBwbGF5ZXJzIChleGNlcHQgd2hpdGVsaXN0ZWQp"
local _STR382 = "QXV0b0ZpbmlzaFRvZ2dsZQ=="
local _STR383 = "RmluaXNoIERpc3RhbmNl"
local _STR384 = "QXV0b0ZpbmlzaERpc3RhbmNl"
local _STR385 = "U2VsZWN0IHBsYXllcnMgdG8gTk9UIGF1dG8gZmluaXNo"
local _STR386 = "QXV0b0ZpbmlzaFdoaXRlbGlzdA=="
local _STR387 = "RmluaXNoUHJvbXB0"
local _STR388 = "cyBrZXkgd2lsbCBiZSBzYXZlZCwgYnV0IGlmIHlvdSBjaGFuZ2UgdGhlIGtleSwgdGhleSB3aWxsIGJlIHVuYWJsZSB0byB1c2UgeW91ciBzY3JpcHQKCQlLZXkgPSB7X1NUUjE0fSwgLS0gTGlzdCBvZiBrZXlzIHRoYXQgd2lsbCBiZSBhY2NlcHRlZCBieSB0aGUgc3lzdGVtLCBwbGVhc2UgdXNlIGEgc3lzdGVtIGxpa2UgUGVsaWNhbiBvciBMdWFybW9yIHRoYXQgcHJvdmlkZSBrZXkgc3RyaW5ncyBiYXNlZCBvbiB5b3VyIEhXSUQgc2luY2UgcHV0dGluZyBhIHNpbXBsZSBzdHJpbmcgaXMgdmVyeSBlYXN5IHRvIGJ5cGFzcwoJCVNlY29uZEFjdGlvbiA9IHsKCQkJRW5hYmxlZCA9IGZhbHNlLCAtLSBTZXQgdG8gZmFsc2UgaWYgeW91IGRvIG5vdCB3YW50IGEgc2Vjb25kIGFjdGlvbiwKCQkJVHlwZSA9IF9TVFIxNSwgLS0gTGluayAvIERpc2NvcmQuCgkJCVBhcmFtZXRlciA9IF9TVFIxNiAtLSBJZiBUeXBlIGlzIERpc2NvcmQsIHRoZW4gcHV0IHlvdXIgaW52aXRlIGxpbmsgKERPIE5PVCBQVVQgRElTQ09SRC5HRy8pLiBFbHNlLCBwdXQgdGhlIGZ1bGwgbGluayBvZiB5b3VyIGtleSBzeXN0ZW0gaGVyZS4KCQl9Cgl9Cn0pCgotLSBDcmVhdGUgVGFicwpsb2NhbCBQbGF5ZXIgPSBXaW5kb3c6Q3JlYXRlVGFiKHsKCU5hbWUgPSBfU1RSMTcsCglJY29uID0gX1NUUjE4LAoJSW1hZ2VTb3VyY2UgPSBfU1RSMTksCglTaG93VGl0bGUgPSB0cnVlCn0pCgpsb2NhbCBBaW1ib3QgPSBXaW5kb3c6Q3JlYXRlVGFiKHsKCU5hbWUgPSBfU1RSMjAsCglJY29uID0gX1NUUjIxLAoJSW1hZ2VTb3VyY2UgPSBfU1RSMTksCglTaG93VGl0bGUgPSB0cnVlCn0pCgpsb2NhbCBWaXN1YWxzID0gV2luZG93OkNyZWF0ZVRhYih7CglOYW1lID0gX1NUUjIyLAoJSWNvbiA9IF9TVFIyMywKCUltYWdlU291cmNlID0gX1NUUjE5LAoJU2hvd1RpdGxlID0gdHJ1ZQp9KQoKbG9jYWwgQ29tYmF0ID0gV2luZG93OkNyZWF0ZVRhYih7CglOYW1lID0gX1NUUjI0LAoJSWNvbiA9IF9TVFIyNSwKCUltYWdlU291cmNlID0gX1NUUjE5LAoJU2hvd1RpdGxlID0gdHJ1ZQp9KQoKbG9jYWwgV2VhcG9uID0gV2luZG93OkNyZWF0ZVRhYih7CglOYW1lID0gX1NUUjI2LAoJSWNvbiA9IF9TVFIyNywKCUltYWdlU291cmNlID0gX1NUUjE5LAoJU2hvd1RpdGxlID0gdHJ1ZQp9KQoKbG9jYWwgVmVoaWNsZSA9IFdpbmRvdzpDcmVhdGVUYWIoewoJTmFtZSA9IF9TVFIyOCwKCUljb24gPSBfU1RSMjksCglJbWFnZVNvdXJjZSA9IF9TVFIxOSwKCVNob3dUaXRsZSA9IHRydWUKfSkKCmxvY2FsIEpvYkF1dG9GYXJtID0gV2luZG93OkNyZWF0ZVRhYih7CglOYW1lID0gX1NUUjMwLAoJSWNvbiA9IF9TVFIzMSwKCUltYWdlU291cmNlID0gX1NUUjE5LAoJU2hvd1RpdGxlID0gdHJ1ZQp9KQoKCmxvY2FsIFBhcmFncmFwaCA9IEpvYkF1dG9GYXJtOkNyZWF0ZVBhcmFncmFwaCh7CglUaXRsZSA9IF9TVFIzMiwKCVRleHQgPSBfU1RSMzMKfSkKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLSBKT0IgQVVUT0ZBUk0gU0NSSVBUIChPcHRpbWl6ZWQpCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKLS0gQ29uc29saWRhdGVkIHN0YXRlIG1hbmFnZW1lbnQKbG9jYWwgSm9iQXV0b0Zhcm1fU3RhdGUgPSB7CiAgICBydW5uaW5nID0gZmFsc2UsCiAgICBjb25uZWN0aW9ucyA9IHt9LAogICAgY3VycmVudFR3ZWVuID0gbmlsLAogICAgbG9jYXRpb24gPSBWZWN0b3IzLm5ldygxMzQuMDMyLCAyNTUuNDY3LCAyMDguNjE0KQp9CgotLSBGdW5jdGlvbiB0byBnZXQgY3VycmVudCBjaGFyYWN0ZXIgcmVmZXJlbmNlcwpsb2NhbCBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJSZWZlcmVuY2VzKCkKICAgIGxvY2FsIGNoYXIgPSBwbGF5ZXIuQ2hhcmFjdGVyCiAgICBpZiBub3QgY2hhciB0aGVuIHJldHVybiBuaWwsIG5pbCwgbmlsIGVuZAogICAgCiAgICByZXR1cm4gY2hhciwgY2hhcjpGaW5kRmlyc3RDaGlsZChfU1RSMSksIGNoYXI6RmluZEZpcnN0Q2hpbGQoX1NUUjIpCmVuZAoKLS0gRnVuY3Rpb24gdG8gd2FpdCBmb3IgY2hhcmFjdGVyIHRvIGxvYWQKbG9jYWwgZnVuY3Rpb24gd2FpdEZvckNoYXJhY3RlcigpCiAgICBsb2NhbCBjaGFyID0gcGxheWVyLkNoYXJhY3RlciBvciBwbGF5ZXIuQ2hhcmFjdGVyQWRkZWQ6V2FpdCgpCiAgICBsb2NhbCBodW0gPSBjaGFyOldhaXRGb3JDaGlsZChfU1RSMSwgMTApCiAgICBsb2NhbCByb290ID0gY2hhcjpXYWl0Rm9yQ2hpbGQoX1NUUjIsIDEwKQogICAgCiAgICBpZiBub3QgaHVtIG9yIG5vdCByb290IHRoZW4KICAgICAgICB3YXJuKF9TVFIzNCkKICAgICAgICByZXR1cm4gbmlsLCBuaWwsIG5pbAogICAgZW5kCiAgICAKICAgIHJldHVybiBjaGFyLCBodW0sIHJvb3QKZW5kCgotLSBGdW5jdGlvbiB0byBjbGVhbiB1cCBhbGwgY29ubmVjdGlvbnMgYW5kIHR3ZWVucwpsb2NhbCBmdW5jdGlvbiBjbGVhbnVwKCkKICAgIHByaW50KF9TVFIzNSkKICAgIAogICAgLS0gQ2FuY2VsIGFueSBhY3RpdmUgdHdlZW4KICAgIGlmIEpvYkF1dG9GYXJtX1N0YXRlLmN1cnJlbnRUd2VlbiB0aGVuCiAgICAgICAgSm9iQXV0b0Zhcm1fU3RhdGUuY3VycmVudFR3ZWVuOkNhbmNlbCgpCiAgICAgICAgSm9iQXV0b0Zhcm1fU3RhdGUuY3VycmVudFR3ZWVuID0gbmlsCiAgICBlbmQKICAgIAogICAgLS0gRGlzY29ubmVjdCBhbGwgY29ubmVjdGlvbnMKICAgIGZvciBfLCBjb25uZWN0aW9uIGluIHBhaXJzKEpvYkF1dG9GYXJtX1N0YXRlLmNvbm5lY3Rpb25zKSBkbwogICAgICAgIGlmIGNvbm5lY3Rpb24gdGhlbgogICAgICAgICAgICBjb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQogICAgICAgIGVuZAogICAgZW5kCiAgICBKb2JBdXRvRmFybV9TdGF0ZS5jb25uZWN0aW9ucyA9IHt9CiAgICAKICAgIHByaW50KF9TVFIzNikKZW5kCgotLSBGdW5jdGlvbiB0byBoYW5kbGUgY2hhcmFjdGVyIGRlYXRoCmxvY2FsIGZ1bmN0aW9uIG9uQ2hhcmFjdGVyRGllZCgpCiAgICBwcmludChfU1RSMzcpCiAgICAKICAgIC0tIERvbg=="
local _STR389 = "dmUgcmVhY2hlZCB0aGUgZmluYWwgd2F5cG9pbnQKICAgICAgICAgICAgaWYgaSA9PSAjcGF0aDpHZXRXYXlwb2ludHMoKSBhbmQgSm9iQXV0b0Zhcm1fU3RhdGUucnVubmluZyB0aGVuCiAgICAgICAgICAgICAgICBwcmludChfU1RSNDEpCiAgICAgICAgICAgIGVuZAogICAgICAgIGVuZAogICAgZWxzZQogICAgICAgIGlmIG5vdCBKb2JBdXRvRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gcmV0dXJuIGZhbHNlIGVuZAogICAgICAgIAogICAgICAgIHdhcm4oX1NUUjQyLCBlcnJvck1lc3NhZ2UpCiAgICAgICAgCiAgICAgICAgLS0gSWYgcGF0aCBjb21wdXRhdGlvbiBmYWlscywganVzdCB0d2VlbiBkaXJlY3RseSB0byB0YXJnZXQgd2l0aCBmaXhlZCBZCiAgICAgICAgcHJpbnQoX1NUUjQzKQogICAgICAgIGlmIG5vdCB0d2VlblRvUG9zaXRpb24odGFyZ2V0UG9zaXRpb24pIHRoZW4gcmV0dXJuIGZhbHNlIGVuZAogICAgZW5kCiAgICAKICAgIGlmIG5vdCBKb2JBdXRvRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gcmV0dXJuIGZhbHNlIGVuZAogICAgCiAgICAtLSBNYWtlIHN1cmUgd2U="
local _STR390 = "dCBibG9jawogICAgICAgICAgICBzcGF3bihmdW5jdGlvbigpCiAgICAgICAgICAgICAgICBzdGFydEF1dG9GYXJtKCkKICAgICAgICAgICAgZW5kKQogICAgICAgIGVsc2UKICAgICAgICAgICAgcHJpbnQoX1NUUjc0KQogICAgICAgICAgICBjbGVhbnVwKCkKICAgICAgICBlbmQKICAgIGVuZAp9LCBfU1RSNzUpCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLSBKQU5JVE9SIEFVVE9GQVJNIFNDUklQVCAoT3B0aW1pemVkKQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCi0tIENvbnNvbGlkYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IGZvciBqYW5pdG9yCmxvY2FsIEphbml0b3JGYXJtX1N0YXRlID0gewogICAgcnVubmluZyA9IGZhbHNlLAogICAgY29ubmVjdGlvbnMgPSB7fSwKICAgIGN1cnJlbnRUd2VlbiA9IG5pbCwKICAgIHlQb3NpdGlvbk1haW50ZW5hbmNlID0gZmFsc2UsCiAgICB0YXJnZXRQYXJ0ID0gd29ya3NwYWNlLkJ1cmdlUGxhY2VCZWFjb24uVG91Y2hQYXJ0LAogICAgY29uZmlnID0gewogICAgICAgIGZpeGVkWVBvc2l0aW9uID0gMjU1LjQsCiAgICAgICAgdHdlZW5TcGVlZCA9IDAuMywKICAgICAgICB3YWl0VGltZVBlclB1ZGRsZSA9IDUsCiAgICAgICAgbG9vcFdhaXRUaW1lID0gMAogICAgfQp9CgotLSBGdW5jdGlvbiB0byBnZXQgY3VycmVudCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyBmb3IgamFuaXRvcgpsb2NhbCBmdW5jdGlvbiBnZXRKYW5pdG9yQ2hhcmFjdGVyUmVmZXJlbmNlcygpCiAgICBsb2NhbCBjaGFyID0gcGxheWVyLkNoYXJhY3RlcgogICAgaWYgbm90IGNoYXIgdGhlbiByZXR1cm4gbmlsLCBuaWwsIG5pbCBlbmQKICAgIAogICAgcmV0dXJuIGNoYXIsIGNoYXI6RmluZEZpcnN0Q2hpbGQoX1NUUjEpLCBjaGFyOkZpbmRGaXJzdENoaWxkKF9TVFIyKQplbmQKCi0tIEZ1bmN0aW9uIHRvIHdhaXQgZm9yIGNoYXJhY3RlciB0byBsb2FkIGZvciBqYW5pdG9yCmxvY2FsIGZ1bmN0aW9uIHdhaXRGb3JKYW5pdG9yQ2hhcmFjdGVyKCkKICAgIGxvY2FsIGNoYXIgPSBwbGF5ZXIuQ2hhcmFjdGVyIG9yIHBsYXllci5DaGFyYWN0ZXJBZGRlZDpXYWl0KCkKICAgIGxvY2FsIGh1bSA9IGNoYXI6V2FpdEZvckNoaWxkKF9TVFIxLCAxMCkKICAgIGxvY2FsIHJvb3QgPSBjaGFyOldhaXRGb3JDaGlsZChfU1RSMiwgMTApCiAgICAKICAgIGlmIG5vdCBodW0gb3Igbm90IHJvb3QgdGhlbgogICAgICAgIHdhcm4oX1NUUjc2KQogICAgICAgIHJldHVybiBuaWwsIG5pbCwgbmlsCiAgICBlbmQKICAgIAogICAgcmV0dXJuIGNoYXIsIGh1bSwgcm9vdAplbmQKCi0tIEZ1bmN0aW9uIHRvIGNsZWFuIHVwIGphbml0b3IgY29ubmVjdGlvbnMgYW5kIHR3ZWVucwpsb2NhbCBmdW5jdGlvbiBqYW5pdG9yQ2xlYW51cCgpCiAgICBwcmludChfU1RSNzcpCiAgICAKICAgIC0tIENhbmNlbCBhbnkgYWN0aXZlIHR3ZWVuCiAgICBpZiBKYW5pdG9yRmFybV9TdGF0ZS5jdXJyZW50VHdlZW4gdGhlbgogICAgICAgIEphbml0b3JGYXJtX1N0YXRlLmN1cnJlbnRUd2VlbjpDYW5jZWwoKQogICAgICAgIEphbml0b3JGYXJtX1N0YXRlLmN1cnJlbnRUd2VlbiA9IG5pbAogICAgZW5kCiAgICAKICAgIC0tIFN0b3AgWSBwb3NpdGlvbiBtYWludGVuYW5jZQogICAgSmFuaXRvckZhcm1fU3RhdGUueVBvc2l0aW9uTWFpbnRlbmFuY2UgPSBmYWxzZQogICAgCiAgICAtLSBEaXNjb25uZWN0IGFsbCBjb25uZWN0aW9ucwogICAgZm9yIF8sIGNvbm5lY3Rpb24gaW4gcGFpcnMoSmFuaXRvckZhcm1fU3RhdGUuY29ubmVjdGlvbnMpIGRvCiAgICAgICAgaWYgY29ubmVjdGlvbiB0aGVuCiAgICAgICAgICAgIGNvbm5lY3Rpb246RGlzY29ubmVjdCgpCiAgICAgICAgZW5kCiAgICBlbmQKICAgIEphbml0b3JGYXJtX1N0YXRlLmNvbm5lY3Rpb25zID0ge30KICAgIAogICAgcHJpbnQoX1NUUjc4KQplbmQKCi0tIEZ1bmN0aW9uIHRvIGhhbmRsZSBjaGFyYWN0ZXIgZGVhdGggZm9yIGphbml0b3IKbG9jYWwgZnVuY3Rpb24gb25KYW5pdG9yQ2hhcmFjdGVyRGllZCgpCiAgICBwcmludChfU1RSMzcpCiAgICAKICAgIC0tIERvbg=="
local _STR391 = "dCBhbHJlYWR5IGluIG91ciBsaXN0CiAgICAgICAgaWYgcHVkZGxlIGFuZCBwdWRkbGUuTmFtZTpmaW5kKF9TVFIxMDYpIGFuZCBwdWRkbGUgfj0gc21hbGxQdWRkbGUgdGhlbgogICAgICAgICAgICB0YWJsZS5pbnNlcnQocHVkZGxlcywgcHVkZGxlKQogICAgICAgICAgICBwcmludChfU1RSMTA3IC4uIHB1ZGRsZS5OYW1lKQogICAgICAgIGVuZAogICAgZW5kCiAgICAKICAgIC0tIEZpbHRlciBvdXQgbmlsIGVudHJpZXMgYW5kIGV4cGxpY2l0bHkgZXhjbHVkZSBwdWRkbGVzIGF0IGluZGljZXMgNCBhbmQgNQogICAgbG9jYWwgdmFsaWRQdWRkbGVzID0ge30KICAgIGZvciBfLCBwdWRkbGUgaW4gcGFpcnMocHVkZGxlcykgZG8KICAgICAgICBpZiBwdWRkbGUgdGhlbgogICAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIHB1ZGRsZSBpcyBvbmUgb2YgdGhlIG9uZXMgd2Ugd2FudCB0byBleGNsdWRlCiAgICAgICAgICAgIGxvY2FsIGlzRXhjbHVkZWQgPSBmYWxzZQogICAgICAgICAgICBsb2NhbCBhbGxDaGlsZHJlbiA9IHB1ZGRsZXNDb250YWluZXI6R2V0Q2hpbGRyZW4oKQogICAgICAgICAgICBmb3IgaSwgY2hpbGQgaW4gcGFpcnMoYWxsQ2hpbGRyZW4pIGRvCiAgICAgICAgICAgICAgICBpZiBjaGlsZCA9PSBwdWRkbGUgYW5kIChpID09IDQgb3IgaSA9PSA1KSB0aGVuCiAgICAgICAgICAgICAgICAgICAgaXNFeGNsdWRlZCA9IHRydWUKICAgICAgICAgICAgICAgICAgICBwcmludChfU1RSMTA4IC4uIGkpCiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbmQKICAgICAgICAgICAgCiAgICAgICAgICAgIC0tIE9ubHkgYWRkIGlmIG5vdCBleGNsdWRlZAogICAgICAgICAgICBpZiBub3QgaXNFeGNsdWRlZCB0aGVuCiAgICAgICAgICAgICAgICB0YWJsZS5pbnNlcnQodmFsaWRQdWRkbGVzLCBwdWRkbGUpCiAgICAgICAgICAgIGVuZAogICAgICAgIGVuZAogICAgZW5kCiAgICAKICAgIC0tIFNvcnQgYnkgZGlzdGFuY2UgKGNsb3Nlc3QgZmlyc3QpCiAgICB0YWJsZS5zb3J0KHZhbGlkUHVkZGxlcywgZnVuY3Rpb24oYSwgYikKICAgICAgICByZXR1cm4gKGEuUG9zaXRpb24gLSByb290LlBvc2l0aW9uKS5NYWduaXR1ZGUgPCAoYi5Qb3NpdGlvbiAtIHJvb3QuUG9zaXRpb24pLk1hZ25pdHVkZQogICAgZW5kKQogICAgCiAgICByZXR1cm4gdmFsaWRQdWRkbGVzCmVuZAoKLS0gRnVuY3Rpb24gdG8gY2xlYW4gYSBwdWRkbGUKbG9jYWwgZnVuY3Rpb24gY2xlYW5QdWRkbGUocHVkZGxlKQogICAgaWYgbm90IEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgdGhlbiByZXR1cm4gZmFsc2UgZW5kCiAgICAKICAgIGxvY2FsIGNoYXIsIGh1bSwgcm9vdCA9IGdldEphbml0b3JDaGFyYWN0ZXJSZWZlcmVuY2VzKCkKICAgIGlmIG5vdCByb290IHRoZW4KICAgICAgICBwcmludChfU1RSMTA5KQogICAgICAgIGNoYXIsIGh1bSwgcm9vdCA9IHdhaXRGb3JKYW5pdG9yQ2hhcmFjdGVyKCkKICAgICAgICBpZiBub3Qgcm9vdCBvciBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIHJldHVybiBmYWxzZSBlbmQKICAgIGVuZAogICAgCiAgICBwcmludChfU1RSMTEwIC4uIHB1ZGRsZS5OYW1lKQogICAgcHJpbnQoX1NUUjExMSAuLiBwdWRkbGUuTmFtZSkKICAgIAogICAgLS0gVHJ5IHRvIGZpbmQgVG91Y2hJbnRlcmVzdCBpbiB0aGUgcHVkZGxlCiAgICBsb2NhbCB0b3VjaEludGVyZXN0ID0gcHVkZGxlOkZpbmRGaXJzdENoaWxkKF9TVFI4NikKICAgIGlmIHRvdWNoSW50ZXJlc3QgdGhlbgogICAgICAgIHByaW50KF9TVFIxMTIpCiAgICAgICAgZmlyZXRvdWNoaW50ZXJlc3Qocm9vdCwgcHVkZGxlLCAwKSAtLSBCZWdpbiB0b3VjaAogICAgICAgIAogICAgICAgIC0tIFdhaXQgZm9yIGNsZWFuaW5nIHRvIGNvbXBsZXRlCiAgICAgICAgcHJpbnQoX1NUUjExMyAuLiBKYW5pdG9yRmFybV9TdGF0ZS5jb25maWcud2FpdFRpbWVQZXJQdWRkbGUgLi4gX1NUUjExNCkKICAgICAgICBsb2NhbCBzdGFydFRpbWUgPSB0aWNrKCkKICAgICAgICB3aGlsZSBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIGFuZCAodGljaygpIC0gc3RhcnRUaW1lKSA8IEphbml0b3JGYXJtX1N0YXRlLmNvbmZpZy53YWl0VGltZVBlclB1ZGRsZSBkbwogICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICBlbmQKICAgICAgICAKICAgICAgICBpZiBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIHJldHVybiBmYWxzZSBlbmQKICAgICAgICAKICAgICAgICBmaXJldG91Y2hpbnRlcmVzdChyb290LCBwdWRkbGUsIDEpIC0tIEVuZCB0b3VjaAogICAgICAgIHByaW50KF9TVFIxMTUpCiAgICAgICAgcmV0dXJuIHRydWUKICAgIGVsc2UKICAgICAgICAtLSBJZiBubyBUb3VjaEludGVyZXN0LCB0cnkgdG8gZmluZCBhIFByb3hpbWl0eVByb21wdCBvciBvdGhlciBpbnRlcmFjdGlvbgogICAgICAgIGxvY2FsIHByb3hpbWl0eVByb21wdCA9IHB1ZGRsZTpGaW5kRmlyc3RDaGlsZChfU1RSMTE2KQogICAgICAgIGlmIHByb3hpbWl0eVByb21wdCB0aGVuCiAgICAgICAgICAgIHByaW50KF9TVFIxMTcpCiAgICAgICAgICAgIGZpcmVwcm94aW1pdHlwcm9tcHQocHJveGltaXR5UHJvbXB0KQogICAgICAgICAgICAKICAgICAgICAgICAgLS0gV2FpdCBmb3IgY2xlYW5pbmcgdG8gY29tcGxldGUKICAgICAgICAgICAgbG9jYWwgc3RhcnRUaW1lID0gdGljaygpCiAgICAgICAgICAgIHdoaWxlIEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgYW5kICh0aWNrKCkgLSBzdGFydFRpbWUpIDwgSmFuaXRvckZhcm1fU3RhdGUuY29uZmlnLndhaXRUaW1lUGVyUHVkZGxlIGRvCiAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIAogICAgICAgICAgICBpZiBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIHJldHVybiBmYWxzZSBlbmQKICAgICAgICAgICAgCiAgICAgICAgICAgIHByaW50KF9TVFIxMTUpCiAgICAgICAgICAgIHJldHVybiB0cnVlCiAgICAgICAgZWxzZQogICAgICAgICAgICAtLSBJZiBubyBkaXJlY3QgaW50ZXJhY3Rpb24gbWV0aG9kIGZvdW5kLCBqdXN0IHdhaXQgYXQgdGhlIHB1ZGRsZQogICAgICAgICAgICBwcmludChfU1RSMTE4KQogICAgICAgICAgICBsb2NhbCBzdGFydFRpbWUgPSB0aWNrKCkKICAgICAgICAgICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBhbmQgKHRpY2soKSAtIHN0YXJ0VGltZSkgPCBKYW5pdG9yRmFybV9TdGF0ZS5jb25maWcud2FpdFRpbWVQZXJQdWRkbGUgZG8KICAgICAgICAgICAgICAgIHdhaXQoMC4xKQogICAgICAgICAgICBlbmQKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIG5vdCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gcmV0dXJuIGZhbHNlIGVuZAogICAgICAgICAgICAKICAgICAgICAgICAgcHJpbnQoX1NUUjExNSkKICAgICAgICAgICAgcmV0dXJuIHRydWUKICAgICAgICBlbmQKICAgIGVuZAogICAgCiAgICByZXR1cm4gZmFsc2UKZW5kCgotLSBGdW5jdGlvbiB0byB2aXNpdCBhbGwgcHVkZGxlcyBpbiBhIGNvbnRpbnVvdXMgbG9vcApsb2NhbCBmdW5jdGlvbiB2aXNpdEFsbFB1ZGRsZXNMb29wKCkKICAgIHByaW50KF9TVFIxMTkpCiAgICAKICAgIC0tIFJ1biB3aGlsZSBzY3JpcHQgaXMgZW5hYmxlZAogICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBkbwogICAgICAgIC0tIENoZWNrIGNoYXJhY3RlciByZWZlcmVuY2VzCiAgICAgICAgbG9jYWwgY2hhciwgaHVtLCByb290ID0gZ2V0SmFuaXRvckNoYXJhY3RlclJlZmVyZW5jZXMoKQogICAgICAgIGlmIG5vdCBjaGFyIG9yIG5vdCBodW0gb3Igbm90IHJvb3QgdGhlbgogICAgICAgICAgICBwcmludChfU1RSMTIwKQogICAgICAgICAgICBjaGFyLCBodW0sIHJvb3QgPSB3YWl0Rm9ySmFuaXRvckNoYXJhY3RlcigpCiAgICAgICAgICAgIGlmIG5vdCBjaGFyIG9yIG5vdCBodW0gb3Igbm90IHJvb3Qgb3Igbm90IEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgdGhlbgogICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgZW5kCiAgICAgICAgZW5kCiAgICAgICAgCiAgICAgICAgLS0gR2V0IHB1ZGRsZXMgc29ydGVkIGJ5IGRpc3RhbmNlIChyZWNhbGN1bGF0ZWQgZWFjaCBsb29wKQogICAgICAgIGxvY2FsIHNvcnRlZFB1ZGRsZXMgPSBnZXRQdWRkbGVzSW5PcmRlcigpCiAgICAgICAgcHJpbnQoX1NUUjEyMSAuLiAjc29ydGVkUHVkZGxlcyAuLiBfU1RSMTIyKQogICAgICAgIAogICAgICAgIC0tIElmIG5vIHB1ZGRsZXMgZm91bmQsIHdhaXQgYSBiaXQgYW5kIHRyeSBhZ2FpbgogICAgICAgIGlmICNzb3J0ZWRQdWRkbGVzID09IDAgdGhlbgogICAgICAgICAgICBpZiBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIGJyZWFrIGVuZAogICAgICAgICAgICBwcmludChfU1RSMTIzKQogICAgICAgICAgICBsb2NhbCBzdGFydFRpbWUgPSB0aWNrKCkKICAgICAgICAgICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBhbmQgKHRpY2soKSAtIHN0YXJ0VGltZSkgPCAoSmFuaXRvckZhcm1fU3RhdGUuY29uZmlnLmxvb3BXYWl0VGltZSAqIDIpIGRvCiAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgZW5kCiAgICAgICAgZWxzZQogICAgICAgICAgICAtLSBWaXNpdCBlYWNoIHB1ZGRsZQogICAgICAgICAgICBmb3IgaSwgcHVkZGxlIGluIGlwYWlycyhzb3J0ZWRQdWRkbGVzKSBkbwogICAgICAgICAgICAgICAgaWYgbm90IEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgdGhlbiBicmVhayBlbmQKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLS0gQ2hlY2sgY2hhcmFjdGVyIHJlZmVyZW5jZXMgYmVmb3JlIGVhY2ggcHVkZGxlCiAgICAgICAgICAgICAgICBsb2NhbCBjdXJyZW50Q2hhciwgY3VycmVudEh1bSwgY3VycmVudFJvb3QgPSBnZXRKYW5pdG9yQ2hhcmFjdGVyUmVmZXJlbmNlcygpCiAgICAgICAgICAgICAgICBpZiBub3QgY3VycmVudENoYXIgb3Igbm90IGN1cnJlbnRIdW0gb3Igbm90IGN1cnJlbnRSb290IHRoZW4KICAgICAgICAgICAgICAgICAgICBwcmludChfU1RSMTI0IC4uIGkgLi4gX1NUUjEyNSkKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHByaW50KF9TVFIxMjYgLi4gaSAuLiBfU1RSMTI3IC4uICNzb3J0ZWRQdWRkbGVzIC4uIF9TVFIxMjggLi4gcHVkZGxlLk5hbWUpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC0tIE1vdmUgdG8gdGhlIHB1ZGRsZQogICAgICAgICAgICAgICAgaWYgbW92ZVRvSmFuaXRvckxvY2F0aW9uKHB1ZGRsZS5Qb3NpdGlvbikgdGhlbgogICAgICAgICAgICAgICAgICAgIGlmIG5vdCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gYnJlYWsgZW5kCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgY2xlYW5QdWRkbGUocHVkZGxlKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGlmIG5vdCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gYnJlYWsgZW5kCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLS0gU2hvcnQgd2FpdCBiZXR3ZWVuIHB1ZGRsZXMKICAgICAgICAgICAgICAgICAgICBsb2NhbCBzdGFydFRpbWUgPSB0aWNrKCkKICAgICAgICAgICAgICAgICAgICB3aGlsZSBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIGFuZCAodGljaygpIC0gc3RhcnRUaW1lKSA8IDAuNSBkbwogICAgICAgICAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICBwcmludChfU1RSMTI5IC4uIGkpCiAgICAgICAgICAgICAgICAgICAgLS0gSWYgbW92ZW1lbnQgZmFpbGVkLCBtaWdodCBiZSBjaGFyYWN0ZXIgaXNzdWUgLSBicmVhayB0byByZXN0YXJ0CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbmQKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIG5vdCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gYnJlYWsgZW5kCiAgICAgICAgICAgIAogICAgICAgICAgICBwcmludChfU1RSMTMwKQogICAgICAgICAgICBsb2NhbCBzdGFydFRpbWUgPSB0aWNrKCkKICAgICAgICAgICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBhbmQgKHRpY2soKSAtIHN0YXJ0VGltZSkgPCBKYW5pdG9yRmFybV9TdGF0ZS5jb25maWcubG9vcFdhaXRUaW1lIGRvCiAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgZW5kCiAgICAgICAgZW5kCiAgICBlbmQKZW5kCgotLSBNYWluIGphbml0b3IgZmFybWluZyBmdW5jdGlvbgpsb2NhbCBmdW5jdGlvbiBzdGFydEphbml0b3JGYXJtKCkKICAgIHdoaWxlIEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgZG8KICAgICAgICAtLSBXYWl0IGZvciBjaGFyYWN0ZXIgaWYgbmVlZGVkCiAgICAgICAgbG9jYWwgY2hhciwgaHVtLCByb290ID0gZ2V0SmFuaXRvckNoYXJhY3RlclJlZmVyZW5jZXMoKQogICAgICAgIGlmIG5vdCBjaGFyIG9yIG5vdCBodW0gb3Igbm90IHJvb3QgdGhlbgogICAgICAgICAgICBwcmludChfU1RSNTUpCiAgICAgICAgICAgIGNoYXIsIGh1bSwgcm9vdCA9IHdhaXRGb3JKYW5pdG9yQ2hhcmFjdGVyKCkKICAgICAgICAgICAgaWYgbm90IGNoYXIgb3Igbm90IGh1bSBvciBub3Qgcm9vdCBvciBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuCiAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBlbmQKICAgICAgICBlbmQKICAgICAgICAKICAgICAgICAtLSBTZXQgdXAgZGVhdGggZGV0ZWN0aW9uIGZvciBjdXJyZW50IGNoYXJhY3RlcgogICAgICAgIHRhYmxlLmluc2VydChKYW5pdG9yRmFybV9TdGF0ZS5jb25uZWN0aW9ucywgaHVtLkRpZWQ6Q29ubmVjdChvbkphbml0b3JDaGFyYWN0ZXJEaWVkKSkKICAgICAgICAKICAgICAgICBwcmludChfU1RSMTMxKQogICAgICAgIHByaW50KF9TVFIxMzIgLi4gSmFuaXRvckZhcm1fU3RhdGUuY29uZmlnLmZpeGVkWVBvc2l0aW9uKQogICAgICAgIHByaW50KF9TVFIxMzMgLi4gSmFuaXRvckZhcm1fU3RhdGUuY29uZmlnLnR3ZWVuU3BlZWQgLi4gX1NUUjEzNCkKICAgICAgICBwcmludChfU1RSMTM1IC4uIEphbml0b3JGYXJtX1N0YXRlLmNvbmZpZy53YWl0VGltZVBlclB1ZGRsZSAuLiBfU1RSMTM2KQogICAgICAgIHByaW50KF9TVFIxMzcgLi4gSmFuaXRvckZhcm1fU3RhdGUuY29uZmlnLmxvb3BXYWl0VGltZSAuLiBfU1RSMTM2KQogICAgICAgIHByaW50KF9TVFIxMzgpCiAgICAgICAgCiAgICAgICAgLS0gU3RhcnQgdGhlIFkgcG9zaXRpb24gbWFpbnRlbmFuY2UKICAgICAgICBtYWludGFpbkphbml0b3JZUG9zaXRpb24oKQogICAgICAgIAogICAgICAgIC0tIFN0ZXAgMTogTW92ZSB0byB0aGUgdGFyZ2V0IGxvY2F0aW9uCiAgICAgICAgaWYgbW92ZVRvSmFuaXRvckxvY2F0aW9uKEphbml0b3JGYXJtX1N0YXRlLnRhcmdldFBhcnQpIGFuZCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4KICAgICAgICAgICAgLS0gU3RlcCAyOiBGaXJlIHRvdWNoIHRyYW5zbWl0dGVycwogICAgICAgICAgICBpZiBmaXJlSmFuaXRvclRvdWNoKCkgYW5kIEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgdGhlbgogICAgICAgICAgICAgICAgLS0gV2FpdCBhIG1vbWVudCBmb3IgdGhlIGRpYWxvZyB0byBhcHBlYXIKICAgICAgICAgICAgICAgIGxvY2FsIHN0YXJ0VGltZSA9IHRpY2soKQogICAgICAgICAgICAgICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBhbmQgKHRpY2soKSAtIHN0YXJ0VGltZSkgPCAxLjUgZG8KICAgICAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIGJyZWFrIGVuZAogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAtLSBTdGVwIDM6IENsaWNrIEFwcGx5IGJ1dHRvbgogICAgICAgICAgICAgICAgaWYgY2xpY2tKYW5pdG9yQXBwbHlCdXR0b24oKSBhbmQgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuCiAgICAgICAgICAgICAgICAgICAgcHJpbnQoX1NUUjEzOSkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAtLSBXYWl0IGEgbW9tZW50IGZvciBqb2IgdG8gYmUgYXBwbGllZAogICAgICAgICAgICAgICAgICAgIGxvY2FsIHN0YXJ0VGltZSA9IHRpY2soKQogICAgICAgICAgICAgICAgICAgIHdoaWxlIEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgYW5kICh0aWNrKCkgLSBzdGFydFRpbWUpIDwgMiBkbwogICAgICAgICAgICAgICAgICAgICAgICB3YWl0KDAuMSkKICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBpZiBub3QgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuIGJyZWFrIGVuZAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIC0tIFN0ZXAgNDogU3RhcnQgY29udGludW91cyBwdWRkbGUgY2xlYW5pbmcgbG9vcAogICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsUHVkZGxlc0xvb3AoKQogICAgICAgICAgICAgICAgZWxzZQogICAgICAgICAgICAgICAgICAgIGlmIG5vdCBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4gYnJlYWsgZW5kCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgcHJpbnQoX1NUUjE0MCkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAtLSBXYWl0IGFuZCB0cnkgdG8gc3RhcnQgcHVkZGxlIGNsZWFuaW5nIGxvb3AgYW55d2F5CiAgICAgICAgICAgICAgICAgICAgbG9jYWwgc3RhcnRUaW1lID0gdGljaygpCiAgICAgICAgICAgICAgICAgICAgd2hpbGUgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyBhbmQgKHRpY2soKSAtIHN0YXJ0VGltZSkgPCAyIGRvCiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXQoMC4xKQogICAgICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGlmIEphbml0b3JGYXJtX1N0YXRlLnJ1bm5pbmcgdGhlbgogICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbFB1ZGRsZXNMb29wKCkKICAgICAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICBwcmludChfU1RSMTQxKQogICAgICAgICAgICAgICAgaWYgSmFuaXRvckZhcm1fU3RhdGUucnVubmluZyB0aGVuCiAgICAgICAgICAgICAgICAgICAgd2FpdCgyKQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgZWxzZQogICAgICAgICAgICBwcmludChfU1RSMTQyKQogICAgICAgICAgICBpZiBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4KICAgICAgICAgICAgICAgIHdhaXQoMikKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgIGVuZAogICAgICAgIGVuZAogICAgICAgIAogICAgICAgIC0tIElmIHdlIGdldCBoZXJlIGFuZCBzY3JpcHQgaXMgc3RpbGwgcnVubmluZywgY2hhcmFjdGVyIHByb2JhYmx5IGRpZWQKICAgICAgICBpZiBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4KICAgICAgICAgICAgcHJpbnQoX1NUUjcwKQogICAgICAgICAgICB3YWl0KDEpIC0tIFNob3J0IHdhaXQgYmVmb3JlIHJlc3RhcnRpbmcKICAgICAgICBlbmQKICAgIGVuZAogICAgCiAgICBqYW5pdG9yQ2xlYW51cCgpCmVuZAoKLS0gQ3JlYXRlIEphbml0b3IgVG9nZ2xlCmxvY2FsIEphbml0b3JUb2dnbGUgPSBKb2JBdXRvRmFybTpDcmVhdGVUb2dnbGUoewoJTmFtZSA9IF9TVFIxNDMsCglEZXNjcmlwdGlvbiA9IF9TVFIxNiwKCUN1cnJlbnRWYWx1ZSA9IGZhbHNlLAogICAgQ2FsbGJhY2sgPSBmdW5jdGlvbihWYWx1ZSkKICAgICAgICBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nID0gVmFsdWUKICAgICAgICAKICAgICAgICBpZiBKYW5pdG9yRmFybV9TdGF0ZS5ydW5uaW5nIHRoZW4KICAgICAgICAgICAgcHJpbnQoX1NUUjE0NCkKICAgICAgICAgICAgLS0gUnVuIHRoZSBmYXJtIGluIGEgc2VwYXJhdGUgdGhyZWFkIHNvIGl0IGRvZXNu"
local _STR392 = "dmUgcmVhY2hlZCB0YXJnZXQgbGV2ZWxzCiAgICBpZiBBVE1IYWNrX1N0YXRlLlNsaWRlck1pbmlnYW1lLmxldmVsLmdldCgpID49IEFUTUhhY2tfU3RhdGUuU2xpZGVyTWluaWdhbWUubGV2ZWxzLmdldCgpIHRoZW4KICAgICAgICBBVE1IYWNrX1N0YXRlLlNsaWRlck1pbmlnYW1lLndpbjpGaXJlKHRydWUpCiAgICBlbmQKZW5kCgotLSBBVE0gSGFjayBjbGVhbnVwIGZ1bmN0aW9uCmxvY2FsIGZ1bmN0aW9uIGF0bUhhY2tDbGVhbnVwKCkKICAgIHByaW50KF9TVFIxNjkpCiAgICBBVE1IYWNrX1N0YXRlLnJ1bm5pbmcgPSBmYWxzZQogICAgaWYgQVRNSGFja19TdGF0ZS5sb29wIHRoZW4KICAgICAgICBBVE1IYWNrX1N0YXRlLmxvb3AgPSBuaWwKICAgIGVuZAogICAgcHJpbnQoX1NUUjE3MCkKZW5kCgotLSBTdGFydCBBVE0gaGFjayBmdW5jdGlvbgpsb2NhbCBmdW5jdGlvbiBzdGFydEFUTUhhY2soKQogICAgcHJpbnQoX1NUUjE3MSkKICAgIAogICAgLS0gTWFpbiBsb29wCiAgICBBVE1IYWNrX1N0YXRlLmxvb3AgPSB0YXNrLnNwYXduKGZ1bmN0aW9uKCkKICAgICAgICB3aGlsZSBBVE1IYWNrX1N0YXRlLnJ1bm5pbmcgZG8KICAgICAgICAgICAgLS0gTWluaW1hbCB3YWl0IHRpbWUKICAgICAgICAgICAgdGFzay53YWl0KDAuMDEpCiAgICAgICAgICAgIAogICAgICAgICAgICAtLSBBdXRvLXdpbiBsb2dpYwogICAgICAgICAgICBsb2NhbCBzdWNjZXNzLCBlcnIgPSBwY2FsbChhdXRvV2luQVRNSGFjaykKICAgICAgICAgICAgaWYgbm90IHN1Y2Nlc3MgdGhlbgogICAgICAgICAgICAgICAgd2FybihfU1RSMTcyIC4uIHRvc3RyaW5nKGVycikpCiAgICAgICAgICAgIGVuZAogICAgICAgIGVuZAogICAgZW5kKQplbmQKCi0tIENyZWF0ZSBBVE0gSGFjayBUb2dnbGUKbG9jYWwgQVRNSGFja1RvZ2dsZSA9IEpvYkF1dG9GYXJtOkNyZWF0ZVRvZ2dsZSh7CglOYW1lID0gX1NUUjE3MywKCURlc2NyaXB0aW9uID0gbmlsLAoJQ3VycmVudFZhbHVlID0gZmFsc2UsCiAgICBDYWxsYmFjayA9IGZ1bmN0aW9uKFZhbHVlKQogICAgICAgIEFUTUhhY2tfU3RhdGUucnVubmluZyA9IFZhbHVlCiAgICAgICAgCiAgICAgICAgaWYgQVRNSGFja19TdGF0ZS5ydW5uaW5nIHRoZW4KICAgICAgICAgICAgcHJpbnQoX1NUUjE3NCkKICAgICAgICAgICAgLS0gUnVuIHRoZSBoYWNrIGluIGEgc2VwYXJhdGUgdGhyZWFkIHNvIGl0IGRvZXNu"
local _STR393 = "dCBjcmVhdGUgaWYgYWxyZWFkeSBleGlzdHMKICAgIAogICAgbG9jYWwgYmlsbGJvYXJkR3VpID0gSW5zdGFuY2UubmV3KF9TVFIxODcpCiAgICBiaWxsYm9hcmRHdWkuTmFtZSA9IF9TVFIxODYKICAgIGJpbGxib2FyZEd1aS5QYXJlbnQgPSBoZWFkCiAgICBiaWxsYm9hcmRHdWkuU2l6ZSA9IFVEaW0yLm5ldygwLCAxMDAsIDAsIDIwKQogICAgYmlsbGJvYXJkR3VpLlN0dWRzT2Zmc2V0ID0gVmVjdG9yMy5uZXcoMCwgMiwgMCkKICAgIGJpbGxib2FyZEd1aS5BbHdheXNPblRvcCA9IHRydWUKICAgIGJpbGxib2FyZEd1aS5MaWdodEluZmx1ZW5jZSA9IDAKICAgIGJpbGxib2FyZEd1aS5TaXplT2Zmc2V0ID0gVmVjdG9yMi5uZXcoMCwgMCkKICAgIAogICAgbG9jYWwgbmFtZUxhYmVsID0gSW5zdGFuY2UubmV3KF9TVFI5MykKICAgIG5hbWVMYWJlbC5QYXJlbnQgPSBiaWxsYm9hcmRHdWkKICAgIG5hbWVMYWJlbC5TaXplID0gVURpbTIubmV3KDEsIDAsIDEsIDApCiAgICBuYW1lTGFiZWwuQmFja2dyb3VuZFRyYW5zcGFyZW5jeSA9IDEKICAgIG5hbWVMYWJlbC5UZXh0ID0gbmFtZVBsYXllci5OYW1lCiAgICBuYW1lTGFiZWwuVGV4dENvbG9yMyA9IENvbG9yMy5mcm9tUkdCKDI1NSwgMjU1LCAyNTUpCiAgICBuYW1lTGFiZWwuVGV4dFNpemUgPSAxMgogICAgbmFtZUxhYmVsLkZvbnQgPSBFbnVtLkZvbnQuU291cmNlU2Fuc0JvbGQKICAgIG5hbWVMYWJlbC5UZXh0U3Ryb2tlVHJhbnNwYXJlbmN5ID0gMAogICAgbmFtZUxhYmVsLlRleHRTdHJva2VDb2xvcjMgPSBDb2xvcjMuZnJvbVJHQigwLCAwLCAwKQplbmQKCmxvY2FsIGZ1bmN0aW9uIHJlbW92ZUFsbE5hbWVUYWdzKCkKICAgIGZvciBfLCBuYW1lUGxheWVyIGluIHBhaXJzKGdhbWUuUGxheWVyczpHZXRQbGF5ZXJzKCkpIGRvCiAgICAgICAgaWYgbmFtZVBsYXllci5DaGFyYWN0ZXIgdGhlbgogICAgICAgICAgICBsb2NhbCBoZWFkID0gbmFtZVBsYXllci5DaGFyYWN0ZXI6RmluZEZpcnN0Q2hpbGQoX1NUUjE4MCkKICAgICAgICAgICAgaWYgaGVhZCB0aGVuCiAgICAgICAgICAgICAgICBsb2NhbCBuYW1lVGFnID0gaGVhZDpGaW5kRmlyc3RDaGlsZChfU1RSMTg2KQogICAgICAgICAgICAgICAgaWYgbmFtZVRhZyB0aGVuCiAgICAgICAgICAgICAgICAgICAgbmFtZVRhZzpEZXN0cm95KCkKICAgICAgICAgICAgICAgIGVuZAogICAgICAgICAgICBlbmQKICAgICAgICBlbmQKICAgIGVuZAplbmQKCi0tIE5hbWUgdGFncyBjbGVhbnVwIGZ1bmN0aW9uCmxvY2FsIGZ1bmN0aW9uIG5hbWVUYWdzQ2xlYW51cCgpCiAgICAtLSBTdG9wIHRoZSBjb25uZWN0aW9uCiAgICBpZiBOYW1lVGFnc19TdGF0ZS5jb25uZWN0aW9uIHRoZW4KICAgICAgICBOYW1lVGFnc19TdGF0ZS5jb25uZWN0aW9uOkRpc2Nvbm5lY3QoKQogICAgICAgIE5hbWVUYWdzX1N0YXRlLmNvbm5lY3Rpb24gPSBuaWwKICAgIGVuZAogICAgCiAgICAtLSBSZW1vdmUgYWxsIGV4aXN0aW5nIG5hbWUgdGFncwogICAgcmVtb3ZlQWxsTmFtZVRhZ3MoKQplbmQKCi0tIFN0YXJ0IG5hbWUgdGFncyBmdW5jdGlvbgpsb2NhbCBmdW5jdGlvbiBzdGFydE5hbWVUYWdzKCkKICAgIC0tIFN0YXJ0IHRoZSBuYW1lIHRhZyBzeXN0ZW0KICAgIE5hbWVUYWdzX1N0YXRlLmNvbm5lY3Rpb24gPSBydW5TZXJ2aWNlLkhlYXJ0YmVhdDpDb25uZWN0KGZ1bmN0aW9uKCkKICAgICAgICBpZiBOYW1lVGFnc19TdGF0ZS5lbmFibGVkIHRoZW4KICAgICAgICAgICAgZm9yIF8sIG5hbWVQbGF5ZXIgaW4gcGFpcnMoZ2FtZS5QbGF5ZXJzOkdldFBsYXllcnMoKSkgZG8KICAgICAgICAgICAgICAgIGlmIG5hbWVQbGF5ZXIgfj0gcGxheWVyIGFuZCBuYW1lUGxheWVyLkNoYXJhY3RlciB0aGVuCiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTmFtZVRhZyhuYW1lUGxheWVyKQogICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIGVuZAogICAgICAgIGVuZAogICAgZW5kKQplbmQKCi0tIENyZWF0ZSBOYW1lIFRhZ3MgVG9nZ2xlCmxvY2FsIE5hbWVUYWdzVG9nZ2xlID0gVmlzdWFsczpDcmVhdGVUb2dnbGUoewoJTmFtZSA9IF9TVFIxODgsCglEZXNjcmlwdGlvbiA9IG5pbCwKCUN1cnJlbnRWYWx1ZSA9IGZhbHNlLAogICAgQ2FsbGJhY2sgPSBmdW5jdGlvbihWYWx1ZSkKICAgICAgICBOYW1lVGFnc19TdGF0ZS5lbmFibGVkID0gVmFsdWUKICAgICAgICAKICAgICAgICBpZiBOYW1lVGFnc19TdGF0ZS5lbmFibGVkIHRoZW4KICAgICAgICAgICAgLS0gUnVuIHRoZSBuYW1lIHRhZ3MgaW4gYSBzZXBhcmF0ZSB0aHJlYWQgc28gaXQgZG9lc24="
local _STR394 = "dCBuZWVkIHRvIGJlIGRpc2Nvbm5lY3RlZCBzaW5jZSBpdA=="

-- Obfuscated main code
-- Load Luna UI Library
local Luna = loadstring(game:HttpGet(_STR0, true))()

---------------------------------------------------------------------------------------------
-- BASIC LOCALS & SERVICES (Reusable for other scripts)
---------------------------------------------------------------------------------------------

-- Player & Character
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild(_STR1)
local hrp = character:WaitForChild(_STR2)

-- Services
local pathfindingService = game:GetService(_STR3)
local tweenService = game:GetService(_STR4)
local runService = game:GetService(_STR5)
local userInputService = game:GetService(_STR6)

---------------------------------------------------------------------------------------------
-- UI WINDOW & TABS
---------------------------------------------------------------------------------------------

local Window = Luna:CreateWindow({
	Name = _STR7, -- This Is Title Of Your Window
	Subtitle = nil, -- A Gray Subtitle next To the main title.
	LogoID = _STR8, -- The Asset ID of your logo. Set to nil if you do not have a logo for Luna to use.
	LoadingEnabled = true, -- Whether to enable the loading animation. Set to false if you do not want the loading screen or have your own custom one.
	LoadingTitle = _STR7, -- Header for loading screen
	LoadingSubtitle = _STR9, -- Subtitle for loading screen

	ConfigSettings = {
		RootFolder = nil, -- The Root Folder Is Only If You Have A Hub With Multiple Game Scripts and u may remove it. DO NOT ADD A SLASH
		ConfigFolder = _STR10 -- The Name Of The Folder Where Luna Will Store Configs For This Script. DO NOT ADD A SLASH
	},

	KeySystem = false, -- As Of Beta 6, Luna Has officially Implemented A Key System!
	KeySettings = {
		Title = _STR11,
		Subtitle = _STR12,
		Note = _STR13,
		SaveInRoot = true, -- Enabling will save the key in your RootFolder (YOU MUST HAVE ONE BEFORE ENABLING THIS OPTION)
		SaveKey = true, -- The user_STR388t stop the script, just wait for respawn
    if JobAutoFarm_State.running then
        print(_STR38)
        local char, hum, root = waitForCharacter()
        
        if char and hum and root and JobAutoFarm_State.running then
            print(_STR39)
            -- The main loop will continue automatically
        end
    end
end

-- Function to tween to a position with fixed Y at 255
local function tweenToPosition(position)
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print(_STR40)
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    -- Keep Y fixed at 255
    local fixedPosition = Vector3.new(position.X, 255, position.Z)
    local distance = (root.Position - fixedPosition).Magnitude
    
    JobAutoFarm_State.currentTween = game:GetService(_STR4):Create(
        root, 
        TweenInfo.new(distance / 17, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
        {CFrame = CFrame.new(fixedPosition)}
    )
    JobAutoFarm_State.currentTween:Play()
    
    -- Create a connection to check if script is still running
    local completed = false
    local connection = JobAutoFarm_State.currentTween.Completed:Connect(function()
        completed = true
    end)
    
    -- Wait for tween to complete or script to stop
    local startTime = tick()
    local timeout = distance / 17 + 5 -- Add 5 seconds buffer
    
    while not completed and JobAutoFarm_State.running and (tick() - startTime) < timeout do
        wait(0.1)
    end
    
    connection:Disconnect()
    
    if not JobAutoFarm_State.running then
        if JobAutoFarm_State.currentTween then
            JobAutoFarm_State.currentTween:Cancel()
        end
        return false
    end
    
    JobAutoFarm_State.currentTween = nil
    return true
end

-- Function to follow path to a target position
local function followPathTo(targetPosition)
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print(_STR40)
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    -- First set Y position to 255
    root.CFrame = CFrame.new(root.Position.X, 255.3, root.Position.Z)
    wait(0.1)
    
    if not JobAutoFarm_State.running then return false end
    
    -- Create and compute path
    local path = game:GetService(_STR3):CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true
    })
    
    local success, errorMessage = pcall(function()
        path:ComputeAsync(root.Position, targetPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success and JobAutoFarm_State.running then
        for i, waypoint in ipairs(path:GetWaypoints()) do
            if not JobAutoFarm_State.running then return false end
            
            -- Move to each waypoint with fixed Y
            if not tweenToPosition(waypoint.Position) then return false end
            
            -- If we_STR389re at the exact target position with Y=255
    local char, hum, root = getCharacterReferences()
    if root then
        root.CFrame = CFrame.new(targetPosition.X, 255, targetPosition.Z)
    end
    return true
end

-- Function to trigger the job UI initially
local function applyForJob()
    if not JobAutoFarm_State.running then return false end
    
    local char, hum, root = getCharacterReferences()
    if not root then
        print(_STR40)
        char, hum, root = waitForCharacter()
        if not root or not JobAutoFarm_State.running then return false end
    end
    
    print(_STR44)
    local touchPart = workspace.Map.Tiles.GasStationTile.Quick11.Interior.Quick11Beacon.TouchPart
    firetouchinterest(root, touchPart, 0)
    wait(0.1)
    firetouchinterest(root, touchPart, 1)
    print(_STR45)
    
    -- Wait for you to manually click Apply
    print(_STR46)
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 8 do
        wait(0.1)
    end
    
    if not JobAutoFarm_State.running then return false end
    
    print(_STR47)
    return true
end

-- Function to pick up a box
local function pickUpBox()
    if not JobAutoFarm_State.running then return false end
    
    print(_STR48)
    
    -- Fire the proximity prompt
    fireproximityprompt(workspace.Map.Tiles.GasStationTile.Quick11.Interior.ShelfStockingJob.NormalBox.ProximityPrompt)
    print(_STR49)
    
    -- Wait a moment for the box to be picked up
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 2 do
        wait(0.1)
    end
    
    return JobAutoFarm_State.running
end

-- Function to move to beacon and wait for delivery
local function moveToBeaconAndDeliver()
    if not JobAutoFarm_State.running then return false end
    
    print(_STR50)
    
    -- Find the beacon base
    local success, beaconBase = pcall(function()
        return workspace.Beacon.Base
    end)
    
    if not JobAutoFarm_State.running then return false end
    
    if not success or not beaconBase then
        print(_STR51)
        return false
    end
    
    print(_STR52)
    
    -- Move to the beacon position
    if not followPathTo(beaconBase.Position) then return false end
    
    print(_STR53)
    
    if not JobAutoFarm_State.running then return false end
    
    -- Wait for delivery to complete - beacon should disappear
    local waitStart = tick()
    while JobAutoFarm_State.running and (tick() - waitStart) < 10 do
        -- Check if beacon still exists
        local beaconStillExists = pcall(function()
            return workspace.Beacon.Base ~= nil
        end)
        
        if not beaconStillExists then
            print(_STR54)
            return true
        end
        
        wait(0.5)
    end
    
    return JobAutoFarm_State.running
end

-- Main farming function
local function startAutoFarm()
    while JobAutoFarm_State.running do
        -- Wait for character if needed
        local char, hum, root = getCharacterReferences()
        if not char or not hum or not root then
            print(_STR55)
            char, hum, root = waitForCharacter()
            if not char or not hum or not root or not JobAutoFarm_State.running then
                break
            end
        end
        
        -- Set up death detection for current character
        table.insert(JobAutoFarm_State.connections, hum.Died:Connect(onCharacterDied))
        
        -- First apply for the job
        if not followPathTo(JobAutoFarm_State.location) then 
            if JobAutoFarm_State.running then
                print(_STR56)
                wait(2)
                continue
            else
                break
            end
        end
        
        if not applyForJob() then 
            if JobAutoFarm_State.running then
                print(_STR57)
                wait(2)
                continue
            else
                break
            end
        end
        
        -- Now start the box stocking loop
        local boxCount = 0
        
        while JobAutoFarm_State.running do
            -- Check if character still exists
            local currentChar, currentHum, currentRoot = getCharacterReferences()
            if not currentChar or not currentHum or not currentRoot then
                print(_STR58)
                break -- Break inner loop to restart with new character
            end
            
            print(_STR59 .. (boxCount + 1) .. _STR60)
            
            -- Go to job location to pick up a box
            print(_STR61)
            if not followPathTo(JobAutoFarm_State.location) then 
                if JobAutoFarm_State.running then
                    print(_STR62)
                    wait(2)
                    continue
                else
                    break
                end
            end
            
            -- Pick up a box
            if pickUpBox() then
                boxCount = boxCount + 1
                print(_STR63 .. boxCount .. _STR64)
                
                -- Move to beacon and deliver
                if moveToBeaconAndDeliver() then
                    print(_STR63 .. boxCount .. _STR65)
                else
                    if not JobAutoFarm_State.running then break end
                    print(_STR66 .. boxCount .. _STR67)
                end
                
                -- Short wait before getting the next box
                if not JobAutoFarm_State.running then break end
                wait(1)
            else
                if not JobAutoFarm_State.running then break end
                print(_STR68)
                wait(2)
            end
            
            if not JobAutoFarm_State.running then break end
            print(_STR69 .. boxCount .. _STR60)
        end
        
        -- If we get here and script is still running, character probably died
        if JobAutoFarm_State.running then
            print(_STR70)
            wait(1) -- Short wait before restarting
        end
    end
    
    print(_STR71)
    cleanup()
end

-- Create Toggle
local Toggle = JobAutoFarm:CreateToggle({
	Name = _STR72,
	Description = _STR16,
	CurrentValue = false,
    Callback = function(Value)
        JobAutoFarm_State.running = Value
        
        if JobAutoFarm_State.running then
            print(_STR73)
            -- Run the farm in a separate thread so it doesn_STR390t stop the script, just wait for respawn
    if JanitorFarm_State.running then
        print(_STR38)
        local char, hum, root = waitForJanitorCharacter()
        
        if char and hum and root and JanitorFarm_State.running then
            print(_STR79)
            -- The main loop will continue automatically
        end
    end
end

-- Function to find path and tween to location for janitor
local function moveToJanitorLocation(target)
    if not JanitorFarm_State.running then return false end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print(_STR40)
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    -- Create path
    local path = game:GetService(_STR3):CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true
    })
    
    -- Get target position
    local targetPosition = typeof(target) == _STR80 and target or target.Position
    
    -- Compute the path
    local success, errorMessage = pcall(function()
        path:ComputeAsync(root.Position, targetPosition)
    end)
    
    if not success then
        print(_STR81, errorMessage)
        return false
    end
    
    -- Move through each waypoint using tweens
    for i, waypoint in ipairs(path:GetWaypoints()) do
        if not JanitorFarm_State.running then return false end
        
        -- Check character references again
        local currentChar, currentHum, currentRoot = getJanitorCharacterReferences()
        if not currentRoot then
            print(_STR82)
            currentChar, currentHum, currentRoot = waitForJanitorCharacter()
            if not currentRoot or not JanitorFarm_State.running then return false end
        end
        
        -- Keep y-position fixed at specified height
        JanitorFarm_State.currentTween = game:GetService(_STR4):Create(
            currentRoot,
            TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
            {CFrame = CFrame.new(Vector3.new(waypoint.Position.X, JanitorFarm_State.config.fixedYPosition, waypoint.Position.Z))}
        )
        JanitorFarm_State.currentTween:Play()
        
        -- Wait for completion or script stop
        local completed = false
        local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
            completed = true
        end)
        
        while not completed and JanitorFarm_State.running do
            wait(0.1)
        end
        
        connection:Disconnect()
        
        if not JanitorFarm_State.running then
            if JanitorFarm_State.currentTween then
                JanitorFarm_State.currentTween:Cancel()
            end
            return false
        end
    end
    
    if not JanitorFarm_State.running then return false end
    
    -- Get character references for final movement
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print(_STR83)
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    -- Final tween to exact position (but still keeping y fixed)
    JanitorFarm_State.currentTween = game:GetService(_STR4):Create(
        root,
        TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear),
        {CFrame = CFrame.new(Vector3.new(targetPosition.X, JanitorFarm_State.config.fixedYPosition, targetPosition.Z))}
    )
    JanitorFarm_State.currentTween:Play()
    
    local completed = false
    local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
        completed = true
    end)
    
    while not completed and JanitorFarm_State.running do
        wait(0.1)
    end
    
    connection:Disconnect()
    
    if not JanitorFarm_State.running then
        if JanitorFarm_State.currentTween then
            JanitorFarm_State.currentTween:Cancel()
        end
        return false
    end
    
    JanitorFarm_State.currentTween = nil
    print(_STR84)
    return true
end

-- Function to fire touch transmitters for janitor
local function fireJanitorTouch()
    if not JanitorFarm_State.running then return false end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then
        print(_STR85)
        char, hum, root = waitForJanitorCharacter()
        if not root or not JanitorFarm_State.running then return false end
    end
    
    local touchInterest = JanitorFarm_State.targetPart:FindFirstChild(_STR86)
    if touchInterest then
        firetouchinterest(root, JanitorFarm_State.targetPart, 0) -- Begin touch
        wait(0.1)
        firetouchinterest(root, JanitorFarm_State.targetPart, 1) -- End touch
        print(_STR87)
        return true
    else
        print(_STR88)
        return false
    end
end

-- Function to click the green Apply button for janitor
local function clickJanitorApplyButton()
    if not JanitorFarm_State.running then return false end
    
    print(_STR89)
    wait(1) -- Wait for dialog to appear
    
    if not JanitorFarm_State.running then return false end
    
    -- Find all TextLabels with _STR90 text
    for _, gui in pairs(player.PlayerGui:GetChildren()) do
        if gui:IsA(_STR91) then
            -- Search for the text _STR92
            for _, desc in pairs(gui:GetDescendants()) do
                if desc:IsA(_STR93) and string.find(desc.Text, _STR94) then
                    print(_STR95 .. desc.Text)
                    
                    -- Look for the green Apply button (should be a TextButton with _STR96 text)
                    for _, buttonDesc in pairs(desc.Parent:GetDescendants()) do
                        if buttonDesc:IsA(_STR97) and buttonDesc.Text == _STR96 then
                            print(_STR98)
                            
                            -- Try multiple methods to click the button
                            local clicked = false
                            
                            -- Method 1: Fire MouseButton1Click directly
                            pcall(function()
                                buttonDesc.MouseButton1Click:Fire()
                                clicked = true
                                print(_STR99)
                            end)
                            
                            wait(0.2)
                            
                            -- Method 2: Using getconnections
                            if not clicked then
                                pcall(function()
                                    for _, connection in pairs(getconnections(buttonDesc.MouseButton1Click)) do
                                        connection:Fire()
                                        clicked = true
                                        print(_STR100)
                                        break
                                    end
                                end)
                            end
                            
                            if clicked then
                                print(_STR101)
                                return true
                            end
                        end
                    end
                    break
                end
            end
        end
    end
    
    print(_STR102)
    return false
end

-- Function to maintain Y position for janitor
local function maintainJanitorYPosition()
    JanitorFarm_State.yPositionMaintenance = true
    
    -- Create a loop that constantly sets the Y position
    spawn(function()
        while JanitorFarm_State.yPositionMaintenance and JanitorFarm_State.running do
            local char, hum, root = getJanitorCharacterReferences()
            if root then
                local currentPos = root.Position
                if currentPos.Y ~= JanitorFarm_State.config.fixedYPosition then
                    root.CFrame = CFrame.new(currentPos.X, JanitorFarm_State.config.fixedYPosition, currentPos.Z)
                end
            end
            wait(0.1)
        end
    end)
end

-- Function to get all puddle locations and sort them by distance
local function getPuddlesInOrder()
    if not JanitorFarm_State.running then return {} end
    
    local char, hum, root = getJanitorCharacterReferences()
    if not root then return {} end
    
    -- Find all puddles in the container
    local puddlesContainer = workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace.Interior.Puddles
    
    print(_STR103)
    
    -- Create a table to hold small puddles
    local puddles = {}
    
    -- Add the specifically named SmallPuddle if it exists
    local smallPuddle = puddlesContainer:FindFirstChild(_STR104)
    if smallPuddle then
        table.insert(puddles, smallPuddle)
        print(_STR105)
    end
    
    -- Look through all puddles and find any with _STR106 in the name
    for _, puddle in pairs(puddlesContainer:GetChildren()) do
        -- Check if the puddle has _STR106 in its name and isn_STR391t block
            spawn(function()
                startJanitorFarm()
            end)
        else
            print(_STR145)
            janitorCleanup()
        end
    end
}, _STR146)
-------------------------
--autocook
-------------------------
-- Optimized Steakhouse Auto Farm Script
-- Consolidated state management for maximum efficiency

-- Consolidated state management for steakhouse
local SteakhouseFarm_State = {
    enabled = false,
    autoMovement = false,
    steaksCookedCounter = 0,
    isRunning = false,
    connections = {},
    config = {
        tweenSpeed = 28,
        waitBetweenActions = 0.0,
        steakhouseBeacon = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.SteakHouseBeacon.TouchPart,
        fridgeArea = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge.Area,
        fridge = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge
    }
}

-- Initialize player references and Net module
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild(_STR1)
local hrp = character:WaitForChild(_STR2)

-- Net module detection (exact from working script)
local Net = nil
if _G.NetBypass and _G.NetBypass.Net then
    Net = _G.NetBypass.Net
elseif _G.Net then
    Net = _G.Net
else
    local success, netModule = pcall(function()
        return require(game.ReplicatedStorage.Modules.Core.Net)
    end)
    if success and netModule then
        Net = netModule
    end
end

-- Precise timing function (exact from working script)
local function isPerfectMoment(barAmount, cookedPerfectly)
    local currentPosition = barAmount.Size.X.Scale
    local perfectStart = cookedPerfectly.Position.X.Scale
    local perfectEnd = perfectStart + cookedPerfectly.Size.X.Scale
    
    return currentPosition >= (perfectStart + 0.01) and 
           currentPosition <= (perfectEnd - 0.01)
end

-- Enhanced Auto Cook Function with Stealth Net Bypass (exact from working script)
local function autoCookSteak()
    -- Find current grill
    local currentGrill = nil
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA(_STR147) and obj:FindFirstChild(_STR148) then
            currentGrill = obj
            break
        end
    end
    
    -- Find progress bar frame
    local progressBarFrame = nil
    for _, gui in pairs(player.PlayerGui:GetChildren()) do
        if gui:IsA(_STR91) then
            local found = gui:FindFirstChild(_STR149)
            if found and found.Visible then
                progressBarFrame = found
                break
            end
        end
    end
    
    if not progressBarFrame or not currentGrill then 
        return false 
    end
    
    local mainFrame = progressBarFrame:FindFirstChild(_STR150)
    local inputFrame = progressBarFrame:FindFirstChild(_STR151)
    
    if not mainFrame or not inputFrame then 
        return false 
    end
    
    local barAmount = mainFrame:FindFirstChild(_STR152)
    local cookedPerfectly = mainFrame:FindFirstChild(_STR153)
    
    if not barAmount or not cookedPerfectly then 
        return false 
    end
    
    -- Check if in perfect moment
    if isPerfectMoment(barAmount, cookedPerfectly) then
        -- STEALTH METHOD: Use Net bypass with proper filtering check
        if Net and _G.NetBypass then
            local stealthEvents = {_STR154, _STR155, _STR156}
            
            for _, eventName in pairs(stealthEvents) do
                if _G.NetBypass.allowEvent then
                    _G.NetBypass.allowEvent(eventName)
                end
            end
            
            pcall(function()
                wait(math.random(50, 150) / 1000)
                Net.send(_STR154, {
                    perfect = true,
                    grill = currentGrill,
                    timestamp = tick()
                })
                
                wait(math.random(30, 80) / 1000)
                Net.send(_STR156, _STR157, {
                    result = _STR158,
                    completion_time = tick()
                })
            end)
        end
        
        -- Complete the visual/client-side
        wait(math.random(100, 200) / 1000)
        
        local completionMethods = {
            function()
                local cookModule = require(game.ReplicatedStorage.Modules.Game.Cooking)
                if cookModule and cookModule.force_complete then
                    pcall(function()
                        cookModule.force_complete(currentGrill)
                    end)
                end
            end,
            function()
                local finishBar = inputFrame:FindFirstChild(_STR159)
                if finishBar then
                    for _, connection in pairs(getconnections(finishBar.MouseButton1Click)) do
                        pcall(function() 
                            connection:Fire() 
                        end)
                    end
                end
            end
        }
        
        for i, method in ipairs(completionMethods) do
            pcall(method)
        end
        
        SteakhouseFarm_State.steaksCookedCounter = SteakhouseFarm_State.steaksCookedCounter + 1
        wait(math.random(500, 1000) / 1000)
        return true
    end
    
    return false
end

-- Helper function to wait for character respawn
local function waitForRespawn()
    if not character or not character:FindFirstChild(_STR1) then
        character = player.CharacterAdded:Wait()
        humanoid = character:WaitForChild(_STR1)
        hrp = character:WaitForChild(_STR2)
    end
end

-- Movement function
local function moveToPosition(targetPosition)
    waitForRespawn()
    
    local path = game:GetService(_STR3):CreatePath({
        AgentCanJump = true,
        AgentHeight = 5,
        AgentRadius = 2,
        WaypointSpacing = 4
    })
    
    local success, errorMessage = pcall(function()
        local fixedYPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
        path:ComputeAsync(hrp.Position, fixedYPosition)
    end)
    
    if success and path.Status == Enum.PathStatus.Success then
        local waypoints = path:GetWaypoints()
        
        for i, waypoint in ipairs(waypoints) do
            if not SteakhouseFarm_State.autoMovement then return false end
            
            waitForRespawn()
            
            local waypointPosition = Vector3.new(waypoint.Position.X, 255, waypoint.Position.Z)
            
            local tweenInfo = TweenInfo.new(
                (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - 
                Vector3.new(waypointPosition.X, 0, waypointPosition.Z)).Magnitude / SteakhouseFarm_State.config.tweenSpeed,
                Enum.EasingStyle.Linear
            )
            
            local tween = game:GetService(_STR4):Create(hrp, tweenInfo, {
                CFrame = CFrame.new(waypointPosition)
            })
            
            tween:Play()
            
            local connection
            connection = game:GetService(_STR5).Heartbeat:Connect(function()
                if not SteakhouseFarm_State.autoMovement then
                    tween:Cancel()
                    connection:Disconnect()
                end
            end)
            
            tween.Completed:Wait()
            connection:Disconnect()
            
            if not SteakhouseFarm_State.autoMovement then return false end
            wait(0.1)
        end
        return true
    else
        warn(_STR42, errorMessage)
        local fixedPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
        humanoid:MoveTo(fixedPosition)
        
        local reachedDestination = false
        local startTime = tick()
        while not reachedDestination and SteakhouseFarm_State.autoMovement and (tick() - startTime) < 10 do
            if (hrp.Position - fixedPosition).Magnitude < 5 then
                reachedDestination = true
            end
            wait(0.1)
        end
        
        return reachedDestination and SteakhouseFarm_State.autoMovement
    end
end

-- Fridge interaction function
local function interactWithFridge()
    waitForRespawn()
    
    local fridgeAreaPosition = SteakhouseFarm_State.config.fridgeArea.Position
    local targetPosition = Vector3.new(fridgeAreaPosition.X, 255, fridgeAreaPosition.Z)
    local moveSuccess = moveToPosition(targetPosition)
    
    if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
    
    wait(1)
    if not SteakhouseFarm_State.autoMovement then return false end
    
    hrp.CFrame = CFrame.new(hrp.Position, 
        Vector3.new(fridgeAreaPosition.X, hrp.Position.Y, fridgeAreaPosition.Z))
    
    wait(1.5)
    if not SteakhouseFarm_State.autoMovement then return false end
    
    local maxAttempts = 5
    for attempt = 1, maxAttempts do
        if not SteakhouseFarm_State.autoMovement then return false end
        
        local proximityPrompt = nil
        
        for i, child in pairs(SteakhouseFarm_State.config.fridge:GetChildren()) do
            if i == 4 and child:FindFirstChild(_STR160) then
                proximityPrompt = child.Attachment:FindFirstChild(_STR116)
                if proximityPrompt then break end
            end
        end
        
        if not proximityPrompt then
            for _, child in pairs(SteakhouseFarm_State.config.fridge:GetDescendants()) do
                if child:IsA(_STR116) then
                    proximityPrompt = child
                    break
                end
            end
        end
        
        if proximityPrompt then
            local promptParent = proximityPrompt.Parent
            if promptParent and promptParent:IsA(_STR161) then
                hrp.CFrame = CFrame.new(promptParent.Position + Vector3.new(0, 2, 0))
            elseif promptParent and promptParent:IsA(_STR160) and promptParent.Parent:IsA(_STR161) then
                hrp.CFrame = CFrame.new(promptParent.Parent.Position + Vector3.new(0, 2, 0))
            end
            
            if not SteakhouseFarm_State.autoMovement then return false end
            
            fireproximityprompt(proximityPrompt)
            
            local waitTime = 3
            local startTime = tick()
            while SteakhouseFarm_State.autoMovement and (tick() - startTime) < waitTime do
                wait(0.1)
            end
            
            if not SteakhouseFarm_State.autoMovement then return false end
            
            return true
        end
        
        if attempt < maxAttempts and SteakhouseFarm_State.autoMovement then
            local offsetPosition = targetPosition + Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
            hrp.CFrame = CFrame.new(offsetPosition)
            if not SteakhouseFarm_State.autoMovement then return false end
            wait(1)
        end
    end
    
    return false
end

-- Beacon finding and movement function
local function findAndMoveToBeacon()
    waitForRespawn()
    
    local startTime = tick()
    local timeout = 10
    local beaconFound = false
    local targetBeacon = nil
    
    while not beaconFound and SteakhouseFarm_State.autoMovement and (tick() - startTime) < timeout do
        if workspace:FindFirstChild(_STR162) and workspace.Beacon:FindFirstChild(_STR163) then
            targetBeacon = workspace.Beacon.Base
            beaconFound = true
            break
        end
        wait(0.5)
    end
    
    if not beaconFound or not targetBeacon then
        return false
    end
    
    if not SteakhouseFarm_State.autoMovement then return false end
    
    local beaconPosition = targetBeacon.Position
    
    local moveSuccess = moveToPosition(beaconPosition)
    
    if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
    
    return true
end

-- Main auto farm cleanup function
local function steakhouseCleanup()
    SteakhouseFarm_State.enabled = false
    SteakhouseFarm_State.autoMovement = false
    
    for _, connection in pairs(SteakhouseFarm_State.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    SteakhouseFarm_State.connections = {}
end

-- LUNA TOGGLE SYSTEM INTEGRATION
local SteakhouseFarmToggle = JobAutoFarm:CreateToggle({
    Name = _STR164,
    Description = _STR16,
    CurrentValue = false,
    Callback = function(Value)
        SteakhouseFarm_State.enabled = Value
        SteakhouseFarm_State.autoMovement = Value
        
        if not Value then
            steakhouseCleanup()
        end
    end
}, _STR165)

-- Auto Movement Loop
if not SteakhouseFarm_State.isRunning then
    SteakhouseFarm_State.isRunning = true
    
    -- Movement loop
    task.spawn(function()
        while SteakhouseFarm_State.isRunning do
            if SteakhouseFarm_State.autoMovement then
                pcall(function()
                    local fridgeSuccess = interactWithFridge()
                    
                    if not fridgeSuccess or not SteakhouseFarm_State.autoMovement then
                        wait(3)
                        return
                    end
                    
                    if not SteakhouseFarm_State.autoMovement then return end
                    wait(SteakhouseFarm_State.config.waitBetweenActions)
                    
                    local beaconSuccess = findAndMoveToBeacon()
                    
                    if not beaconSuccess or not SteakhouseFarm_State.autoMovement then
                        wait(3)
                        return
                    end
                    
                    if not SteakhouseFarm_State.autoMovement then return end
                    
                    local cookingStart = tick()
                    local cookingTimeout = 20
                    local cookingCompleted = false
                    
                    while SteakhouseFarm_State.autoMovement and (tick() - cookingStart) < cookingTimeout do
                        local progressBarFrame = nil
                        for _, gui in pairs(player.PlayerGui:GetChildren()) do
                            if gui:IsA(_STR91) then
                                local found = gui:FindFirstChild(_STR149)
                                if found and found.Visible then
                                    progressBarFrame = found
                                    break
                                end
                            end
                        end
                        
                        if progressBarFrame then
                            while progressBarFrame and progressBarFrame.Visible and SteakhouseFarm_State.autoMovement do
                                wait(0.1)
                            end
                            cookingCompleted = true
                            break
                        end
                        
                        wait(0.5)
                    end
                    
                    if cookingCompleted then
                        wait(2)
                    else
                        wait(5)
                    end
                end)
            end
            
            wait(1)
        end
    end)
    
    -- Auto-cook loop (exact from working script)
    task.spawn(function()
        while SteakhouseFarm_State.isRunning do
            task.wait(0.01)
            
            if SteakhouseFarm_State.enabled then
                local success, result = pcall(autoCookSteak)
                if not success then
                    warn(_STR166 .. tostring(result))
                end
            end
        end
    end)
end

--------------------------------------------------------------------------------------------
JobAutoFarm:CreateDivider()
---------------------------------------------------------------------------------------------
-- ATM HACK SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for ATM hack
local ATMHack_State = {
    running = false,
    loop = nil,
    SliderMinigame = require(game:GetService(_STR167).Modules.Game.Minigames.SliderMinigame)
}

-- Override the needle position calculation
local function modifiedNeedlePositionCalculation()
    -- Increase speed multiplier (from 0.65 to 2)
    local v23 = tick() * 2 % 3;
    
    -- Expand range from [0, 1] to [-0.5, 1.5]
    if v23 > 1.5 then
        v23 = 3 - v23;
    elseif v23 < -0.5 then
        v23 = -v23 - 0.5;
    end
    
    ATMHack_State.SliderMinigame.needle_pos.set(v23)
end

-- Function to check if needle is in target zone
local function isNeedleInTargetZone()
    local needlePos = ATMHack_State.SliderMinigame.needle_pos.get()
    local targetPos = ATMHack_State.SliderMinigame.target_pos.get()
    local targetSize = ATMHack_State.SliderMinigame.target_size.get()
    
    -- Expand target zone slightly for more success
    local lowerBound = targetPos - (targetSize / 2) - 0.1
    local upperBound = targetPos + (targetSize / 2) + 0.1
    
    -- Check if needle is within the expanded target zone
    return needlePos >= lowerBound and needlePos <= upperBound
end

-- Function to simulate a click when in target zone
local function autoClickIfInTargetZone()
    if isNeedleInTargetZone() then
        -- Simulate clicking
        local currentLevel = ATMHack_State.SliderMinigame.level.get()
        ATMHack_State.SliderMinigame.level.set(currentLevel + 1)
        
        -- Minimal audio feedback
        require(game:GetService(_STR167).Modules.Game.Minigames.SliderMinigame.play_audio)(
            _STR168, 
            0.1, 
            (math.min(2, 1.25 + 0.25 * currentLevel))
        )
    end
end

-- Main auto-win loop
local function autoWinATMHack()
    -- Ensure the minigame is enabled
    if not ATMHack_State.SliderMinigame.enabled.get() then return end
    
    -- Modify needle position calculation
    modifiedNeedlePositionCalculation()
    
    -- Try to click in target zone multiple times
    for _ = 1, 3 do
        autoClickIfInTargetZone()
    end
    
    -- Check if we_STR392t block
            spawn(function()
                startATMHack()
            end)
        else
            print(_STR175)
            atmHackCleanup()
        end
    end
}, _STR176)

---------------------------------------------------------------------------------------------
-- ESP SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for ESP system
local ESP_State = {
    objects2D = {},
    objects3D = {},
    currentMode = _STR177,
    enabled = false,
    config2D = {
        BoxThickness = 2,
        BoxTransparency = 1,
        HealthColorGradient = {
            {Threshold = 25, Color = Color3.fromRGB(255, 0, 0)},     -- Red at low health
            {Threshold = 50, Color = Color3.fromRGB(255, 165, 0)},   -- Orange at medium-low health
            {Threshold = 75, Color = Color3.fromRGB(255, 255, 0)},   -- Yellow at medium health
            {Threshold = 100, Color = Color3.fromRGB(0, 255, 0)}     -- Green at full health
        },
        MaxDisplayDistance = 1000,
        BoxSizeX = 2,
        BoxSizeY = 3,
        RefreshRate = 5,
    },
    config3D = {
        Box_Color = Color3.fromRGB(255, 0, 0),
        Box_Thickness = 2,
        Box_Transparency = 1,
        Autothickness = true
    }
}

-- Functions for health color (2D ESP)
local function GetHealthColor2D(health)
    for _, colorInfo in ipairs(ESP_State.config2D.HealthColorGradient) do
        if health <= colorInfo.Threshold then
            return colorInfo.Color
        end
    end
    return Color3.fromRGB(0, 255, 0)
end

-- Functions for health color (3D ESP)
local function GetHealthColor3D(currentHealth, maxHealth)
    return Color3.fromRGB(227, 52, 52):Lerp(Color3.fromRGB(88, 217, 24), currentHealth / maxHealth)
end

-- Create 2D ESP objects for a player
local function CreateESP2DForPlayer(espPlayer)
    if espPlayer == player then return end
    if ESP_State.objects2D[espPlayer] then return ESP_State.objects2D[espPlayer] end
    
    ESP_State.objects2D[espPlayer] = {
        Top = Drawing.new(_STR178),
        Bottom = Drawing.new(_STR178),
        Left = Drawing.new(_STR178),
        Right = Drawing.new(_STR178),
        LastUpdate = tick()
    }
    
    for _, line in pairs(ESP_State.objects2D[espPlayer]) do
        if type(line) ~= _STR179 then
            line.Visible = false
            line.Thickness = ESP_State.config2D.BoxThickness
            line.Transparency = ESP_State.config2D.BoxTransparency
            line.Color = ESP_State.config2D.HealthColorGradient[1].Color
            line.From = Vector2.new(0, 0)
            line.To = Vector2.new(0, 0)
        end
    end
    
    return ESP_State.objects2D[espPlayer]
end

-- Create 3D ESP objects for a player
local function CreateESP3DForPlayer(espPlayer)
    if espPlayer == player then return end
    if ESP_State.objects3D[espPlayer] then return ESP_State.objects3D[espPlayer] end
    
    ESP_State.objects3D[espPlayer] = {
        lines = {},
        connection = nil
    }
    
    for i = 1, 12 do
        ESP_State.objects3D[espPlayer].lines[i] = Drawing.new(_STR178)
        ESP_State.objects3D[espPlayer].lines[i].Visible = false
        ESP_State.objects3D[espPlayer].lines[i].Color = ESP_State.config3D.Box_Color
        ESP_State.objects3D[espPlayer].lines[i].Thickness = ESP_State.config3D.Box_Thickness
        ESP_State.objects3D[espPlayer].lines[i].Transparency = ESP_State.config3D.Box_Transparency
    end
    
    return ESP_State.objects3D[espPlayer]
end

-- Remove ESP objects for a player
local function RemoveESPForPlayer(espPlayer)
    -- Remove 2D ESP
    if ESP_State.objects2D[espPlayer] then
        for _, line in pairs(ESP_State.objects2D[espPlayer]) do
            if type(line) ~= _STR179 then
                line:Remove()
            end
        end
        ESP_State.objects2D[espPlayer] = nil
    end
    
    -- Remove 3D ESP
    if ESP_State.objects3D[espPlayer] then
        if ESP_State.objects3D[espPlayer].connection then
            ESP_State.objects3D[espPlayer].connection:Disconnect()
        end
        for _, line in pairs(ESP_State.objects3D[espPlayer].lines) do
            line:Remove()
        end
        ESP_State.objects3D[espPlayer] = nil
    end
end

-- Update 2D ESP for all players
local function Update2DESP()
    for _, espPlayer in ipairs(game.Players:GetPlayers()) do
        if espPlayer ~= player then
            local espObj = CreateESP2DForPlayer(espPlayer)
            
            if ESP_State.enabled and ESP_State.currentMode == _STR177 and espPlayer.Character and 
               espPlayer.Character:FindFirstChild(_STR2) and 
               espPlayer.Character:FindFirstChild(_STR1) then
                
                if tick() - espObj.LastUpdate > ESP_State.config2D.RefreshRate then
                    RemoveESPForPlayer(espPlayer)
                    espObj = CreateESP2DForPlayer(espPlayer)
                    espObj.LastUpdate = tick()
                end
                
                local hrp = espPlayer.Character.HumanoidRootPart
                local humanoid = espPlayer.Character.Humanoid
                local head = espPlayer.Character:FindFirstChild(_STR180)
                
                local distance = (workspace.CurrentCamera.CFrame.Position - hrp.Position).Magnitude
                if distance > ESP_State.config2D.MaxDisplayDistance then
                    for _, line in pairs(espObj) do
                        if type(line) ~= _STR179 then
                            line.Visible = false
                        end
                    end
                else
                    local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                    
                    if onScreen then
                        local scaleFactor = math.clamp(1 - (distance / ESP_State.config2D.MaxDisplayDistance), 0.3, 1)
                        local scale = (head and head.Size.Y/2 or 0.5)
                        local size = Vector3.new(ESP_State.config2D.BoxSizeX, ESP_State.config2D.BoxSizeY, 0) * (scale * 2 * scaleFactor)
                        
                        local TL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, size.Y, 0)).Position)
                        local TR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, size.Y, 0)).Position)
                        local BL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, -size.Y, 0)).Position)
                        local BR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, -size.Y, 0)).Position)
                        
                        espObj.Top.From = Vector2.new(TL.X, TL.Y)
                        espObj.Top.To = Vector2.new(TR.X, TR.Y)
                        espObj.Left.From = Vector2.new(TL.X, TL.Y)
                        espObj.Left.To = Vector2.new(BL.X, BL.Y)
                        espObj.Right.From = Vector2.new(TR.X, TR.Y)
                        espObj.Right.To = Vector2.new(BR.X, BR.Y)
                        espObj.Bottom.From = Vector2.new(BL.X, BL.Y)
                        espObj.Bottom.To = Vector2.new(BR.X, BR.Y)
                        
                        local healthPercentage = (humanoid.Health / humanoid.MaxHealth) * 100
                        
                        for _, line in pairs(espObj) do
                            if type(line) ~= _STR179 then
                                line.Color = GetHealthColor2D(healthPercentage)
                                line.Transparency = ESP_State.config2D.BoxTransparency * scaleFactor
                                line.Visible = true
                            end
                        end
                    else
                        for _, line in pairs(espObj) do
                            if type(line) ~= _STR179 then
                                line.Visible = false
                            end
                        end
                    end
                end
            else
                for _, line in pairs(espObj) do
                    if type(line) ~= _STR179 then
                        line.Visible = false
                    end
                end
            end
        end
    end
end

-- Create 3D ESP for a specific player
local function Create3DESPForPlayer(espPlayer)
    if espPlayer == player then return end
    
    local esp3DObj = CreateESP3DForPlayer(espPlayer)
    
    local function Update3DESP()
        if ESP_State.enabled and ESP_State.currentMode == _STR181 and espPlayer.Character and 
           espPlayer.Character:FindFirstChild(_STR1) and 
           espPlayer.Character:FindFirstChild(_STR2) and 
           espPlayer.Character.Humanoid.Health > 0 then
            
            local pos, vis = workspace.CurrentCamera:WorldToViewportPoint(espPlayer.Character.HumanoidRootPart.Position)
            if vis then
                local Scale = espPlayer.Character.Head.Size.Y/2
                local Size = Vector3.new(2, 3, 1.5) * (Scale * 2)

                local Top1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z)).p)
                local Top2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z)).p)
                local Top3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, Size.Z)).p)
                local Top4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z)).p)

                local Bottom1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, -Size.Z)).p)
                local Bottom2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, Size.Z)).p)
                local Bottom3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, Size.Z)).p)
                local Bottom4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p)

                local lines = esp3DObj.lines
                
                -- Top face
                lines[1].From = Vector2.new(Top1.X, Top1.Y); lines[1].To = Vector2.new(Top2.X, Top2.Y)
                lines[2].From = Vector2.new(Top2.X, Top2.Y); lines[2].To = Vector2.new(Top3.X, Top3.Y)
                lines[3].From = Vector2.new(Top3.X, Top3.Y); lines[3].To = Vector2.new(Top4.X, Top4.Y)
                lines[4].From = Vector2.new(Top4.X, Top4.Y); lines[4].To = Vector2.new(Top1.X, Top1.Y)
                
                -- Bottom face
                lines[5].From = Vector2.new(Bottom1.X, Bottom1.Y); lines[5].To = Vector2.new(Bottom2.X, Bottom2.Y)
                lines[6].From = Vector2.new(Bottom2.X, Bottom2.Y); lines[6].To = Vector2.new(Bottom3.X, Bottom3.Y)
                lines[7].From = Vector2.new(Bottom3.X, Bottom3.Y); lines[7].To = Vector2.new(Bottom4.X, Bottom4.Y)
                lines[8].From = Vector2.new(Bottom4.X, Bottom4.Y); lines[8].To = Vector2.new(Bottom1.X, Bottom1.Y)
                
                -- Vertical lines
                lines[9].From = Vector2.new(Top1.X, Top1.Y); lines[9].To = Vector2.new(Bottom1.X, Bottom1.Y)
                lines[10].From = Vector2.new(Top2.X, Top2.Y); lines[10].To = Vector2.new(Bottom2.X, Bottom2.Y)
                lines[11].From = Vector2.new(Top3.X, Top3.Y); lines[11].To = Vector2.new(Bottom3.X, Bottom3.Y)
                lines[12].From = Vector2.new(Top4.X, Top4.Y); lines[12].To = Vector2.new(Bottom4.X, Bottom4.Y)

                -- Health-based color and thickness
                local healthColor = GetHealthColor3D(espPlayer.Character.Humanoid.Health, espPlayer.Character.Humanoid.MaxHealth)
                local thickness = ESP_State.config3D.Box_Thickness
                if ESP_State.config3D.Autothickness then
                    thickness = math.clamp(1/(player.Character.HumanoidRootPart.Position - espPlayer.Character.HumanoidRootPart.Position).magnitude*100, 0.1, 4)
                end
                
                for _, line in pairs(lines) do
                    line.Color = healthColor
                    line.Thickness = thickness
                    line.Visible = true
                end
            else
                for _, line in pairs(esp3DObj.lines) do
                    line.Visible = false
                end
            end
        else
            for _, line in pairs(esp3DObj.lines) do
                line.Visible = false
            end
            if not game.Players:FindFirstChild(espPlayer.Name) then
                if esp3DObj.connection then
                    esp3DObj.connection:Disconnect()
                end
            end
        end
    end
    
    esp3DObj.connection = runService.RenderStepped:Connect(Update3DESP)
end

-- Initialize 3D ESP for all players
local function Initialize3DESP()
    for _, espPlayer in ipairs(game.Players:GetPlayers()) do
        if espPlayer ~= player then
            Create3DESPForPlayer(espPlayer)
        end
    end
end

-- Clean up all ESP
local function CleanupAllESP()
    for espPlayer, _ in pairs(ESP_State.objects2D) do
        RemoveESPForPlayer(espPlayer)
    end
    for espPlayer, _ in pairs(ESP_State.objects3D) do
        RemoveESPForPlayer(espPlayer)
    end
end

-- Update ESP based on current mode
local function UpdateESPSystem()
    if not ESP_State.enabled then
        CleanupAllESP()
        return
    end
    
    if ESP_State.currentMode == _STR177 then
        -- Clean up 3D ESP
        for espPlayer, esp3DObj in pairs(ESP_State.objects3D) do
            if esp3DObj.connection then
                esp3DObj.connection:Disconnect()
            end
            for _, line in pairs(esp3DObj.lines) do
                line.Visible = false
            end
        end
    elseif ESP_State.currentMode == _STR181 then
        -- Clean up 2D ESP
        for espPlayer, espObj in pairs(ESP_State.objects2D) do
            for _, line in pairs(espObj) do
                if type(line) ~= _STR179 then
                    line.Visible = false
                end
            end
        end
        Initialize3DESP()
    end
end

-- Create ESP Type Dropdown
local ESPDropdown = Visuals:CreateDropdown({
	Name = _STR182,
    Description = nil,
	Options = {_STR177, _STR181},
    CurrentOption = {_STR177},
    MultipleOptions = false,
    SpecialType = nil,
    Callback = function(Option)
        ESP_State.currentMode = Option
        UpdateESPSystem()
    end
}, _STR183)

-- Create ESP Toggle
local ESPToggle = Visuals:CreateToggle({
	Name = _STR184,
	Description = nil,
	CurrentValue = false,
    Callback = function(Value)
        ESP_State.enabled = Value
        UpdateESPSystem()
    end
}, _STR185)

-- Main render loop for 2D ESP
runService.RenderStepped:Connect(function()
    if ESP_State.enabled and ESP_State.currentMode == _STR177 then
        Update2DESP()
    end
end)

-- Handle new players joining
game.Players.PlayerAdded:Connect(function(newPlayer)
    if ESP_State.currentMode == _STR181 and ESP_State.enabled then
        Create3DESPForPlayer(newPlayer)
    end
end)

-- Handle players leaving
game.Players.PlayerRemoving:Connect(function(espPlayer)
    RemoveESPForPlayer(espPlayer)
end)
---------------------------------------------------------------------------------------------
-- NAME TAGS SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for name tags
local NameTags_State = {
    enabled = false,
    connection = nil
}

local function createNameTag(namePlayer)
    if namePlayer == player then return end
    
    local character = namePlayer.Character
    if not character then return end
    
    local head = character:FindFirstChild(_STR180)
    if not head then return end
    
    local existingTag = head:FindFirstChild(_STR186)
    if existingTag then return end -- Don_STR393t block
            spawn(function()
                startNameTags()
            end)
        else
            nameTagsCleanup()
        end
    end
}, _STR189)
---------------------------------------------------------------------------------------------
-- WEAPON ESP (Optimized)
---------------------------------------------------------------------------------------------

-- Move weapon data to global scope to avoid local variable limits
getgenv().WeaponESPData = getgenv().WeaponESPData or {}

-- Weapon signatures for identification
getgenv().WeaponESPData.signatures = {
    -- Firearms
    AK47 = {accuracy = 0.85, automatic = true, fire_rate = 600, MagSize = 30, range = 300, Recoil = 0.4, reload_time = 2.2, damage = 27, Durability = 720, KnockbackForce = 100, RagdollChance = 0.1, RarityName = _STR190, RarityPrice = 70000},
    Anaconda = {accuracy = 0.95, automatic = false, fire_rate = 80, MagSize = 6, range = 120, Recoil = 0.8, reload_time = 2, damage = 70, Durability = 120, KnockbackForce = 350, RagdollChance = 0.3, RarityName = _STR191, RarityPrice = 420000},
    C9 = {accuracy = 0.7, automatic = false, fire_rate = 300, MagSize = 8, range = 80, Recoil = 0.2, reload_time = 2, damage = 11, Durability = 120, RagdollChance = 0, RarityName = _STR192, RarityPrice = 700},
    Crossbow = {accuracy = 0.95, automatic = false, fire_rate = 100, MagSize = 1, range = 500, Recoil = 0.3, reload_time = 2, damage = 90, Durability = 120, KnockbackForce = 100, RagdollChance = 0.3, RarityName = _STR190, RarityPrice = 60000},
    [_STR193] = {accuracy = 0.5, automatic = false, fire_rate = 100, MagSize = 2, range = 50, Recoil = 2, reload_time = 3, damage = 16, Durability = 84, KnockbackForce = 300, RagdollChance = 0.4, RarityName = _STR194, RarityPrice = 8000},
    Draco = {accuracy = 0.75, automatic = true, fire_rate = 900, MagSize = 25, range = 250, Recoil = 0.5, reload_time = 2.2, damage = 15, Durability = 600, RagdollChance = 0, RarityName = _STR194, RarityPrice = 19000},
    G3 = {accuracy = 0.65, automatic = false, fire_rate = 320, MagSize = 10, range = 80, Recoil = 0.2, reload_time = 2, damage = 13, Durability = 144, RagdollChance = 0, RarityName = _STR192, RarityPrice = 900},
    Glock = {accuracy = 0.8, automatic = false, fire_rate = 370, MagSize = 15, range = 80, Recoil = 0.2, reload_time = 2, damage = 19, Durability = 168, RagdollChance = 0, RarityName = _STR195, RarityPrice = 1800},
    [_STR196] = {accuracy = 0.93, automatic = false, fire_rate = 50, MagSize = 5, range = 500, Recoil = 0.8, reload_time = 2.2, damage = 35, Durability = 72, KnockbackForce = 200, RagdollChance = 0.2, RarityName = _STR195, RarityPrice = 5000},
    M24 = {accuracy = 0.97, automatic = false, fire_rate = 50, MagSize = 7, range = 500, Recoil = 0.8, reload_time = 2, damage = 50, Durability = 120, KnockbackForce = 200, RagdollChance = 0.2, RarityName = _STR194, RarityPrice = 25000},
    MP5 = {accuracy = 0.85, automatic = true, fire_rate = 800, MagSize = 30, range = 200, Recoil = 0.35, reload_time = 2, damage = 19, Durability = 720, RagdollChance = 0, RarityName = _STR190, RarityPrice = 38000},
    P226 = {accuracy = 0.75, automatic = false, fire_rate = 370, MagSize = 7, range = 80, Recoil = 0.25, reload_time = 2, damage = 22, Durability = 180, RagdollChance = 0, RarityName = _STR195, RarityPrice = 2200},
    RPG = {accuracy = 0.9, automatic = false, fire_rate = 100, MagSize = 1, range = 600, Recoil = 2, reload_time = 2.6, explode_damage = 1000, Durability = 96, ExplodeKnockback = 300, ExplodeRadius = 12, RarityName = _STR190, RarityPrice = 90000},
    Remington = {accuracy = 0.6, automatic = false, fire_rate = 80, MagSize = 5, range = 80, Recoil = 1.5, reload_time = 2, damage = 19, Durability = 300, KnockbackForce = 300, RagdollChance = 0.4, RarityName = _STR190, RarityPrice = 45000},
    Sawnoff = {accuracy = 0.4, automatic = false, fire_rate = 150, MagSize = 2, range = 30, Recoil = 3, reload_time = 3, damage = 18, Durability = 240, KnockbackForce = 450, RagdollChance = 0.5, RarityName = _STR195, RarityPrice = 3500},
    Uzi = {accuracy = 0.7, automatic = true, fire_rate = 1200, MagSize = 20, range = 150, Recoil = 0.3, reload_time = 1.7, damage = 8, Durability = 480, RagdollChance = 0, RarityName = _STR195, RarityPrice = 3000},
    -- Melee Weapons
    Axe = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 34, destructive = 1.6, Durability = 80, knockback_force = 250, ragdoll_chance = 0.2, RarityName = _STR195, RarityPrice = 3200},
    [_STR197] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 43, destructive = 1.2, Durability = 100, knockback_force = 300, ragdoll_chance = 0.2, RarityName = _STR194, RarityPrice = 16000},
    [_STR198] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 26, destructive = 1.2, Durability = 80, knockback_force = 300, ragdoll_chance = 0.2, RarityName = _STR192, RarityPrice = 900},
    [_STR199] = {speed = 1.9, range = 6, cone_angle = 70, damage = 17, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.15, RarityName = _STR200, RarityPrice = 90},
    [_STR201] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 20, MopSpeedPercentageIncrease = 10, RarityName = _STR200, RarityPrice = 100},
    [_STR202] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 21, destructive = 1, Durability = 50, knockback_force = 100, ragdoll_chance = 0.15, RarityName = _STR200, RarityPrice = 300},
    [_STR203] = {speed = 1.6, range = 6, cone_angle = 75, damage = 30, destructive = 0.9, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = _STR195, RarityPrice = 1500},
    [_STR204] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 40, destructive = 1.6, Durability = 90, knockback_force = 200, ragdoll_chance = 0.15, RarityName = _STR194, RarityPrice = 14000},
    Crowbar = {speed = 1.6, range = 7, cone_angle = 80, damage = 31, destructive = 2, Durability = 100, knockback_force = 250, ragdoll_chance = 0.15, RarityName = _STR195, RarityPrice = 3000},
    [_STR205] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 100, MopSpeedPercentageIncrease = 40, RarityName = _STR195, RarityPrice = 1500},
    [_STR206] = {speed = 1.7, range = 6.5, cone_angle = 90, damage = 28, destructive = 1, Durability = 60, knockback_force = 400, ragdoll_chance = 0.3, RarityName = _STR195, RarityPrice = 2400},
    [_STR207] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 70, MopSpeedPercentageIncrease = 30, RarityName = _STR192, RarityPrice = 800},
    Hammer = {speed = 1.75, range = 6, cone_angle = 70, damage = 23, destructive = 1.5, Durability = 70, knockback_force = 80, ragdoll_chance = 0.1, RarityName = _STR192, RarityPrice = 400},
    Machette = {speed = 1.8, range = 7.25, cone_angle = 85, damage = 38, destructive = 0.9, Durability = 90, knockback_force = 100, ragdoll_chance = 0.15, RarityName = _STR194, RarityPrice = 14000},
    [_STR208] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 35, destructive = 1.4, Durability = 110, knockback_force = 350, ragdoll_chance = 0.2, RarityName = _STR195, RarityPrice = 4000},
    [_STR209] = {speed = 1.55, range = 6.5, cone_angle = 75, damage = 20, destructive = 1.5, Durability = 60, knockback_force = 150, ragdoll_chance = 0.3, RarityName = _STR200, RarityPrice = 150},
    Mop = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 0, MopSpeedPercentageIncrease = 0, RarityName = _STR200, RarityPrice = 0},
    [_STR210] = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 23, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.1, RarityName = _STR192, RarityPrice = 350},
    [_STR211] = {speed = 1.7, range = 7.5, cone_angle = 80, damage = 15, destructive = 1, Durability = 30, knockback_force = 80, ragdoll_chance = 0.1, RarityName = _STR200, RarityPrice = 70},
    [_STR212] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 16, destructive = 1, Durability = 30, knockback_force = 100, ragdoll_chance = 0.1, RarityName = _STR200, RarityPrice = 70},
    [_STR213] = {speed = 1.2, range = 7, cone_angle = 75, damage = 25, destructive = 1.3, Durability = 50, knockback_force = 250, ragdoll_chance = 0.15, RarityName = _STR192, RarityPrice = 600},
    Shank = {speed = 2, range = 5.5, cone_angle = 60, damage = 20, destructive = 0.7, Durability = 40, knockback_force = 50, ragdoll_chance = 0.1, RarityName = _STR200, RarityPrice = 300},
    Shovel = {speed = 1.2, range = 7.5, cone_angle = 75, damage = 41, destructive = 1.4, Durability = 80, knockback_force = 300, ragdoll_chance = 0.3, RarityName = _STR194, RarityPrice = 9000},
    [_STR214] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 45, MopSpeedPercentageIncrease = 20, RarityName = _STR200, RarityPrice = 300},
    [_STR215] = {speed = 1.1, range = 7.25, cone_angle = 80, damage = 47, destructive = 3, Durability = 110, knockback_force = 550, ragdoll_chance = 0.5, RarityName = _STR194, RarityPrice = 25000},
    Switchblade = {speed = 2, range = 5.5, cone_angle = 60, damage = 29, destructive = 0.7, Durability = 60, knockback_force = 80, ragdoll_chance = 0.1, RarityName = _STR195, RarityPrice = 2200},
    [_STR216] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 65, destructive = 1.5, Durability = 120, knockback_force = 250, ragdoll_chance = 0.2, RarityName = _STR190, RarityPrice = 40000},
    [_STR217] = {speed = 2.2, range = 5.75, cone_angle = 75, damage = 50, destructive = 0.8, Durability = 110, knockback_force = 100, ragdoll_chance = 0.1, RarityName = _STR190, RarityPrice = 30000},
    [_STR218] = {speed = 2, range = 6.75, cone_angle = 75, damage = 58, destructive = 1.4, Durability = 130, knockback_force = 150, ragdoll_chance = 0.15, RarityName = _STR190, RarityPrice = 35000},
    Taser = {speed = 2, range = 5.25, cone_angle = 60, damage = 10, Durability = 40, knockback_force = 100, ragdoll_chance = 1, RarityName = _STR200, RarityPrice = 120},
    [_STR219] = {speed = 1.6, range = 6.5, cone_angle = 80, damage = 24, destructive = 1.2, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = _STR192, RarityPrice = 450},
    [_STR220] = {speed = 1.45, range = 6.5, cone_angle = 80, damage = 16, destructive = 1, Durability = 25, knockback_force = 100, ragdoll_chance = 0.1, RarityName = _STR200, RarityPrice = 50},
    Wrench = {speed = 1.5, range = 6, cone_angle = 80, damage = 34, destructive = 1.8, Durability = 70, knockback_force = 200, ragdoll_chance = 0.15, RarityName = _STR195, RarityPrice = 2200}
}

-- Weapon images
getgenv().WeaponESPData.weaponImages = {
    AK47 = _STR221,
    Anaconda = _STR222,
    C9 = _STR223,
    Crossbow = _STR224,
    [_STR193] = _STR225,
    Draco = _STR226,
    G3 = _STR227,
    Glock = _STR228,
    [_STR196] = _STR229,
    M24 = _STR230,
    MP5 = _STR231,
    P226 = _STR232,
    RPG = _STR233,
    Remington = _STR234,
    Sawnoff = _STR235,
    Uzi = _STR236,
    Axe = _STR237,
    [_STR197] = _STR238,
    [_STR198] = _STR239,
    [_STR199] = _STR240,
    [_STR201] = _STR241,
    [_STR203] = _STR242,
    [_STR202] = _STR243,
    [_STR204] = _STR244,
    Crowbar = _STR245,
    [_STR205] = _STR246,
    [_STR206] = _STR247,
    [_STR207] = _STR248,
    Hammer = _STR249,
    Machette = _STR250,
    [_STR208] = _STR251,
    [_STR209] = _STR252,
    Mop = _STR253,
    [_STR210] = _STR254,
    [_STR211] = _STR255,
    [_STR212] = _STR256,
    [_STR213] = _STR257,
    Shank = _STR258,
    Shovel = _STR259,
    [_STR214] = _STR260,
    [_STR215] = _STR261,
    Switchblade = _STR262,
    [_STR216] = _STR263,
    [_STR217] = _STR264,
    [_STR218] = _STR265,
    Taser = _STR266,
    [_STR219] = _STR267,
    [_STR220] = _STR268,
    Wrench = _STR269
}

-- Rarity colors for weapon boxes
getgenv().WeaponESPData.rarityColors = {
    Common = Color3.fromRGB(169, 169, 169),
    Uncommon = Color3.fromRGB(128, 128, 128),
    Rare = Color3.fromRGB(0, 180, 0),
    Epic = Color3.fromRGB(163, 53, 238),
    Legendary = Color3.fromRGB(255, 165, 0),
    Omega = Color3.fromRGB(255, 0, 0)
}

-- Consolidated state management for weapon ESP
local WeaponESP_State = {
    enabled = false,
    connection = nil,
    playerESPs = {}
}

-- Utility functions
local function getAttribute(obj, attr)
    local success, value = pcall(function() return obj:GetAttribute(attr) end)
    return success and value or nil
end

local function identifyWeapon(tool)
    for weaponName, signature in pairs(getgenv().WeaponESPData.signatures) do
        local matched, total = 0, 0
        for attrName, expectedValue in pairs(signature) do
            local toolValue = getAttribute(tool, attrName)
            if toolValue ~= nil then
                total = total + 1
                if type(expectedValue) == _STR179 then
                    if math.abs(toolValue - expectedValue) <= 0.01 then matched = matched + 1 end
                elseif toolValue == expectedValue then matched = matched + 1 end
            end
        end
        if total > 0 and matched / total >= 0.7 then
            return {name = weaponName, rarity = signature.RarityName, price = signature.RarityPrice}
        end
    end
    return nil
end

local function createPlayerESP(targetPlayer)
    if targetPlayer == player or not WeaponESP_State.enabled then return end
    
    local targetCharacter = targetPlayer.Character
    if not targetCharacter then return end
    
    local existingESP = targetCharacter:FindFirstChild(_STR270)
    if existingESP then existingESP:Destroy() end
    
    local weapons = {}
    local function collectWeapons(container)
        for _, tool in ipairs(container:GetChildren()) do
            if tool:IsA(_STR271) then
                local weaponInfo = identifyWeapon(tool)
                if weaponInfo then table.insert(weapons, weaponInfo) end
            end
        end
    end
    
    local backpack = targetPlayer:FindFirstChild(_STR272)
    if backpack then collectWeapons(backpack) end
    collectWeapons(targetCharacter)
    
    if #weapons > 0 then
        local billboard = Instance.new(_STR187)
        billboard.Name = _STR270
        billboard.Parent = targetCharacter
        billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
        billboard.StudsOffset = Vector3.new(0, -5, 0)
        billboard.AlwaysOnTop = true
        billboard.LightInfluence = 0
        billboard.Adornee = targetCharacter:FindFirstChild(_STR2)
        billboard.ClipsDescendants = false
        billboard.ExtentsOffset = Vector3.new(0, 0, 0)
        billboard.ExtentsOffsetWorldSpace = Vector3.new(0, 0, 0)
        billboard.MaxDistance = math.huge
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
        
        -- Force consistent size regardless of distance
        local connection = game:GetService(_STR5).Heartbeat:Connect(function()
            if billboard and billboard.Parent then
                billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
            else
                connection:Disconnect()
            end
        end)
        
        WeaponESP_State.playerESPs[targetPlayer] = {billboard = billboard, connection = connection}
        
        local frame = Instance.new(_STR273)
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 1
        frame.Parent = billboard
        
        for i, weapon in ipairs(weapons) do
            -- Get rarity color for this weapon
            local rarityColor = getgenv().WeaponESPData.rarityColors[weapon.rarity] or Color3.fromRGB(255, 255, 255)
            
            -- Create individual box for each weapon
            local weaponBox = Instance.new(_STR273)
            weaponBox.Size = UDim2.new(0, 22, 0, 22)
            weaponBox.Position = UDim2.new(0, (i-1) * 24, 0, 2)
            weaponBox.BackgroundColor3 = rarityColor
            weaponBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
            weaponBox.BorderSizePixel = 1
            weaponBox.Parent = frame
            
            -- Add corner rounding
            local corner = Instance.new(_STR274)
            corner.CornerRadius = UDim.new(0, 3)
            corner.Parent = weaponBox
            
            -- Add glossy gradient effect
            local gradient = Instance.new(_STR275)
            gradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                ColorSequenceKeypoint.new(0.5, rarityColor),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
            }
            gradient.Rotation = -45
            gradient.Parent = weaponBox
            
            -- Add subtle stroke for extra definition
            local stroke = Instance.new(_STR276)
            stroke.Color = Color3.fromRGB(255, 255, 255)
            stroke.Transparency = 0.7
            stroke.Thickness = 1
            stroke.Parent = weaponBox
            
            -- Add weapon image inside the box
            local imageLabel = Instance.new(_STR277)
            imageLabel.Size = UDim2.new(0, 18, 0, 18)
            imageLabel.Position = UDim2.new(0, 2, 0, 2)
            imageLabel.BackgroundTransparency = 1
            imageLabel.Image = getgenv().WeaponESPData.weaponImages[weapon.name] or _STR16
            imageLabel.ScaleType = Enum.ScaleType.Fit
            imageLabel.Parent = weaponBox
        end
    end
end

local function removeAllESP()
    for targetPlayer, espData in pairs(WeaponESP_State.playerESPs) do
        if espData then
            if espData.billboard and espData.billboard.Parent then 
                espData.billboard:Destroy() 
            end
            if espData.connection then
                espData.connection:Disconnect()
            end
        end
    end
    WeaponESP_State.playerESPs = {}
    
    for _, targetPlayer in ipairs(game.Players:GetPlayers()) do
        if targetPlayer.Character then
            local existingESP = targetPlayer.Character:FindFirstChild(_STR270)
            if existingESP then existingESP:Destroy() end
        end
    end
end

local function startESP()
    if WeaponESP_State.connection then return end
    
    for _, targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer) end
    
    local playerAddedConnection = game.Players.PlayerAdded:Connect(createPlayerESP)
    local playerRemovingConnection = game.Players.PlayerRemoving:Connect(function(targetPlayer)
        if WeaponESP_State.playerESPs[targetPlayer] then
            if WeaponESP_State.playerESPs[targetPlayer].billboard then
                WeaponESP_State.playerESPs[targetPlayer].billboard:Destroy()
            end
            if WeaponESP_State.playerESPs[targetPlayer].connection then
                WeaponESP_State.playerESPs[targetPlayer].connection:Disconnect()
            end
            WeaponESP_State.playerESPs[targetPlayer] = nil
        end
    end)
    
    WeaponESP_State.connection = coroutine.create(function()
        while WeaponESP_State.enabled do
            wait(2)
            if WeaponESP_State.enabled then
                for _, targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer) end
            end
        end
    end)
    
    coroutine.resume(WeaponESP_State.connection)
    WeaponESP_State.playerESPs._connections = {playerAdded = playerAddedConnection, playerRemoving = playerRemovingConnection}
end

local function stopESP()
    WeaponESP_State.enabled = false
    if WeaponESP_State.playerESPs._connections then
        if WeaponESP_State.playerESPs._connections.playerAdded then WeaponESP_State.playerESPs._connections.playerAdded:Disconnect() end
        if WeaponESP_State.playerESPs._connections.playerRemoving then WeaponESP_State.playerESPs._connections.playerRemoving:Disconnect() end
        WeaponESP_State.playerESPs._connections = nil
    end
    removeAllESP()
    WeaponESP_State.connection = nil
end

-- Luna Toggle Integration
local Toggle = Visuals:CreateToggle({
    Name = _STR278,
    Description = _STR279,
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            WeaponESP_State.enabled = true
            startESP()
        else
            stopESP()
        end
    end
}, _STR280)
---------------------------------------------------------------------------------------------
-- VEHICLE MODIFICATION SYSTEM SCRIPT (Optimized)
---------------------------------------------------------------------------------------------

-- Consolidated state management for vehicle modification
local VehicleMod_State = {
    sliderValues = {},
    attributeConfigs = {
        {name = _STR281, min = 0, max = 100, default = 8, increment = 1},
        {name = _STR282, min = 0, max = 100, default = 10, increment = 1},
        {name = _STR283, min = 0, max = 50, default = 1, increment = 1},
        {name = _STR284, min = 0, max = 100, default = 23, increment = 1},
        {name = _STR285, min = 0, max = 50000, default = 20000, increment = 100},
        {name = _STR286, min = 0, max = 2000, default = 500, increment = 10},
        {name = _STR287, min = 0, max = 100, default = 5, increment = 1}
    }
}

-- Initialize slider values with defaults
for _, config in ipairs(VehicleMod_State.attributeConfigs) do
    VehicleMod_State.sliderValues[config.name] = config.default
end

-- Create sliders for each attribute using Luna system
for _, config in ipairs(VehicleMod_State.attributeConfigs) do
    Vehicle:CreateSlider({
        Name = config.name,
        Range = {config.min, config.max},
        Increment = config.increment,
        CurrentValue = config.default,
        Callback = function(Value)
            VehicleMod_State.sliderValues[config.name] = Value
        end
    }, _STR288 .. config.name)
end

-- Apply Changes Button using Luna system
local ApplyButton = Vehicle:CreateButton({
    Name = _STR289,
    Description = _STR290,
    Callback = function()
        -- Function to recursively find and update motors
        local function updateMotorsInObject(obj)
            -- Check if this object has motor attributes
            for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                if obj:GetAttribute(attributeName) ~= nil then
                    obj:SetAttribute(attributeName, value)
                end
            end
            
            -- Recursively check children
            for _, child in pairs(obj:GetChildren()) do
                updateMotorsInObject(child)
            end
        end
        
        -- Find all vehicles and their motors
        local vehiclesFolder = workspace:FindFirstChild(_STR291)
        if not vehiclesFolder then
            return
        end
        
        local motorsChanged = 0
        
        -- Process all vehicles in the Vehicles folder
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA(_STR147) or vehicle:IsA(_STR292) then
                updateMotorsInObject(vehicle)
            end
        end
        
        -- Also check for a direct Motors folder (backward compatibility)
        local motorsFolder = vehiclesFolder:FindFirstChild(_STR293)
        if motorsFolder then
            for _, motor in pairs(motorsFolder:GetChildren()) do
                for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                    if motor:GetAttribute(attributeName) ~= nil then
                        motor:SetAttribute(attributeName, value)
                        motorsChanged = motorsChanged + 1
                    end
                end
            end
        end
        
        -- Count total attributes changed
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA(_STR147) or vehicle:IsA(_STR292) then
                local function countAttributes(obj)
                    for attributeName, value in pairs(VehicleMod_State.sliderValues) do
                        if obj:GetAttribute(attributeName) ~= nil then
                            motorsChanged = motorsChanged + 1
                        end
                    end
                    for _, child in pairs(obj:GetChildren()) do
                        countAttributes(child)
                    end
                end
                countAttributes(vehicle)
            end
        end
    end
})
---------------------------------------------------------------------------------------
--SPEED BOOST RUNNING (Fixed Optimized)
---------------------------------------------------------------------------------------

-- Consolidated state management for speed boost
local SpeedBoost_State = {
    enabled = false,
    connection = nil,
    spamConnection = nil
}

local function enableAutoSprint()
    if not player.Character then return end
    
    -- Wait for game systems to fully load
    wait(2)
    
    SpeedBoost_State.connection = game:GetService(_STR5).Heartbeat:Connect(function()
        if not player.Character then
            if SpeedBoost_State.connection then
                SpeedBoost_State.connection:Disconnect()
                SpeedBoost_State.connection = nil
            end
            return
        end
        
        if SpeedBoost_State.enabled then
            -- Check if player is moving
            local humanoid = player.Character:FindFirstChild(_STR1)
            if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                
                -- Set speed multiplier for 21 speed (16 * 1.3125 = 21)
                player:SetAttribute(_STR294, 1.3125)
                
                -- Try to access the keybind system to simulate sprint key press
                local success = pcall(function()
                    local keybindModule = require(game.ReplicatedStorage.Modules.Game.Keybinds)
                    
                    -- Simulate holding the sprint key
                    if keybindModule.hook_action then
                        -- Force the sprint action to be active
                        keybindModule.hook_action(_STR295, function()
                            return true -- Always return true (sprint key pressed)
                        end)
                    end
                end)
                
                -- Also try to maintain the sprint state directly
                pcall(function()
                    local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                    if sprintModule.sprinting and sprintModule.sprinting.get() == false then
                        sprintModule.sprinting.set(true)
                    end
                    
                    -- Keep stamina topped up
                    if sprintModule.sprint_bar then
                        sprintModule.sprint_bar.set(1)
                    end
                end)
            else
                -- Reset speed multiplier when not moving
                player:SetAttribute(_STR294, 1)
            end
        end
    end)
end

local function startSprintSpam()
    -- The working shift spam exploit - every 0.5 seconds
    SpeedBoost_State.spamConnection = spawn(function()
        while SpeedBoost_State.enabled do
            wait(0.5) -- Every 0.5 seconds
            
            if SpeedBoost_State.enabled and player.Character then
                local humanoid = player.Character:FindFirstChild(_STR1)
                if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                    pcall(function()
                        local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                        
                        -- Directly call the sprinting state toggle like the real shift key does
                        if sprintModule.sprinting then
                            -- Simulate a quick sprint toggle (like tapping shift)
                            sprintModule.sprinting.set(false) -- Turn off
                            wait(0.05) -- Brief pause
                            sprintModule.sprinting.set(true)  -- Turn back on
                        end
                    end)
                end
            end
        end
    end)
end

local function stopAutoSprint()
    if SpeedBoost_State.connection then
        SpeedBoost_State.connection:Disconnect()
        SpeedBoost_State.connection = nil
    end
    -- spamConnection doesn_STR394s a spawn() thread
    SpeedBoost_State.spamConnection = nil
    -- Reset speed when disabled
    if player then
        player:SetAttribute(_STR294, 1)
    end
end

-- Apply to current and future characters
local function setupCharacter()
    if SpeedBoost_State.enabled then
        enableAutoSprint()
    end
end

if player.Character then
    setupCharacter()
end

player.CharacterAdded:Connect(function()
    wait(3)
    setupCharacter()
end)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = _STR296,
    Description = _STR297,
    CurrentValue = false,
    Callback = function(Value)
        SpeedBoost_State.enabled = Value
        
        if SpeedBoost_State.enabled then
            -- Start the auto sprint system
            if player.Character then
                enableAutoSprint()
            end
            startSprintSpam()
        else
            -- Stop the auto sprint system
            stopAutoSprint()
        end
    end
}, _STR298) -- Unique flag for configuration saving

-------------------------------------------------------------------------------------
--SUPER JUMP (Optimized)
-------------------------------------------------------------------------------------

-- Consolidated state management for super jump
local SuperJump_State = {
    enabled = false
}

local function updateJumpPower(character, enabled)
    local humanoid = character:WaitForChild(_STR1, 10)
    if not humanoid then
        return
    end
    
    if enabled then
        -- Enable UseJumpPower (this makes JumpPower work instead of JumpHeight)
        humanoid.UseJumpPower = true
        
        -- Set JumpPower to 65
        humanoid.JumpPower = 65
    else
        -- Reset to default values
        humanoid.UseJumpPower = true -- Keep this true but reset power
        humanoid.JumpPower = 23 -- Default jump power (changed from 50 to 23)
    end
end

local function setupCharacter(character)
    updateJumpPower(character, SuperJump_State.enabled)
end

-- Apply to current character if it exists
if player.Character then
    setupCharacter(player.Character)
end

-- Apply to future characters when they spawn
player.CharacterAdded:Connect(setupCharacter)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = _STR299,
    Description = _STR300,
    CurrentValue = false,
    Callback = function(Value)
        SuperJump_State.enabled = Value
        
        -- Apply to current character if it exists
        if player.Character then
            updateJumpPower(player.Character, SuperJump_State.enabled)
        end
    end
}, _STR301) -- Unique flag for configuration saving

Player:CreateDivider()
---------------------------------------------------------------------------
--Infi Stamina (Optimized)
---------------------------------------------------------------------------

-- Consolidated state management for infinite stamina
local InfiniteStamina_State = {
    enabled = false,
    connection = nil,
    spamConnection = nil
}

local function enableInfiniteStamina()
    if not player.Character then return end
    
    -- Wait for game systems to fully load
    wait(2)
    
    InfiniteStamina_State.connection = game:GetService(_STR5).Heartbeat:Connect(function()
        if not player.Character then
            if InfiniteStamina_State.connection then
                InfiniteStamina_State.connection:Disconnect()
                InfiniteStamina_State.connection = nil
            end
            return
        end
        
        if InfiniteStamina_State.enabled then
            -- Check if player is moving
            local humanoid = player.Character:FindFirstChild(_STR1)
            if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                
                -- ESSENTIAL: Hook the sprint action to enable sprinting
                pcall(function()
                    local keybindModule = require(game.ReplicatedStorage.Modules.Game.Keybinds)
                    
                    if keybindModule.hook_action then
                        keybindModule.hook_action(_STR295, function()
                            return true -- Always return true (sprint key pressed)
                        end)
                    end
                end)
                
                -- ESSENTIAL: Maintain the sprint state
                pcall(function()
                    local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                    if sprintModule.sprinting and sprintModule.sprinting.get() == false then
                        sprintModule.sprinting.set(true)
                    end
                    
                    -- Keep stamina topped up
                    if sprintModule.sprint_bar then
                        sprintModule.sprint_bar.set(1)
                    end
                end)
            end
        end
    end)
end

local function startStaminaSpam()
    -- The shift spam exploit for infinite stamina
    InfiniteStamina_State.spamConnection = spawn(function()
        while InfiniteStamina_State.enabled do
            wait(0.5) -- Every 0.5 seconds
            
            if InfiniteStamina_State.enabled and player.Character then
                local humanoid = player.Character:FindFirstChild(_STR1)
                if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                    pcall(function()
                        local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                        
                        -- Simulate the shift key spam exploit
                        if sprintModule.sprinting then
                            -- Quick sprint toggle (like manually tapping shift)
                            sprintModule.sprinting.set(false) -- Turn off
                            wait(0.05) -- Brief pause
                            sprintModule.sprinting.set(true)  -- Turn back on
                        end
                    end)
                end
            end
        end
    end)
end

local function stopInfiniteStamina()
    if InfiniteStamina_State.connection then
        InfiniteStamina_State.connection:Disconnect()
        InfiniteStamina_State.connection = nil
    end
    -- spamConnection doesn_STR394s a spawn() thread
    InfiniteStamina_State.spamConnection = nil
end

local function setupCharacter()
    if InfiniteStamina_State.enabled then
        enableInfiniteStamina()
    end
end

-- Apply to current and future characters
if player.Character then
    setupCharacter()
end

player.CharacterAdded:Connect(function()
    wait(3)
    setupCharacter()
end)

-- Luna Toggle Integration
local Toggle = Player:CreateToggle({
    Name = _STR302,
    Description = _STR303,
    CurrentValue = false,
    Callback = function(Value)
        InfiniteStamina_State.enabled = Value
        
        if InfiniteStamina_State.enabled then
            -- Start the infinite stamina system
            if player.Character then
                enableInfiniteStamina()
            end
            startStaminaSpam()
        else
            -- Stop the infinite stamina system
            stopInfiniteStamina()
        end
    end
}, _STR304) -- Unique flag for configuration saving
------------------------------------------------------------------------------
--WEAPON (Optimized)
------------------------------------------------------------------------------

-- Consolidated state management for weapon modification
local WeaponMod_State = {
    enabled = false,
    attributeMultipliers = {
        accuracy = 1,      -- Default multiplier for accuracy (0.75 → 1 * multiplier)
        fireRate = 1,      -- Default multiplier for fire rate (370 → 1000 * multiplier)
        magSize = 1,       -- Default multiplier for magazine size (7 → 1000 * multiplier)
        range = 1,         -- Default multiplier for range (80 → 1000 * multiplier)
        recoil = 1,        -- Default multiplier for recoil (0.25 → 0 * multiplier)
        reloadTime = 1     -- Default multiplier for reload time (2 → 0 * multiplier)
    },
    gunConfigs = {
        [_STR305] = {
            modifications = {
                {original = 0.65, target = 1, type = _STR306},
                {original = 320, target = 1000, type = _STR307},
                {original = 10, target = 1000, type = _STR308},
                {original = 80, target = 1000, type = _STR309},
                {original = 0.2, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR312] = {
            modifications = {
                {original = 0.85, target = 1, type = _STR306},
                {original = 600, target = 1000, type = _STR307},
                {original = 30, target = 1000, type = _STR308},
                {original = 300, target = 1000, type = _STR309},
                {original = 0.4, target = 0, type = _STR310},
                {original = 2.2, target = 0, type = _STR311}
            }
        },
        [_STR313] = {
            modifications = {
                {original = 0.95, target = 1, type = _STR306},
                {original = 80, target = 1000, type = _STR307},
                {original = 6, target = 1000, type = _STR308},
                {original = 120, target = 1000, type = _STR309},
                {original = 0.8, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR314] = {
            modifications = {
                {original = 0.7, target = 1, type = _STR306},
                {original = 300, target = 1000, type = _STR307},
                {original = 8, target = 1000, type = _STR308},
                {original = 80, target = 1000, type = _STR309},
                {original = 0.2, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR315] = {
            modifications = {
                {original = 0.95, target = 1, type = _STR306},
                {original = 100, target = 1000, type = _STR307},
                {original = 1, target = 1000, type = _STR308},
                {original = 500, target = 1000, type = _STR309},
                {original = 0.3, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR193] = {
            modifications = {
                {original = 0.5, target = 1, type = _STR306},
                {original = 100, target = 1000, type = _STR307},
                {original = 2, target = 1000, type = _STR308},
                {original = 50, target = 1000, type = _STR309},
                {original = 2, target = 0, type = _STR310},
                {original = 3, target = 0, type = _STR311}
            }
        },
        [_STR316] = {
            modifications = {
                {original = 0.75, target = 1, type = _STR306},
                {original = 900, target = 1000, type = _STR307},
                {original = 25, target = 1000, type = _STR308},
                {original = 250, target = 1000, type = _STR309},
                {original = 0.5, target = 0, type = _STR310},
                {original = 2.2, target = 0, type = _STR311}
            }
        },
        [_STR317] = {
            modifications = {
                {original = 0.8, target = 1, type = _STR306},
                {original = 100, target = 1000, type = _STR307},
                {original = 1, target = 1000, type = _STR308},
                {original = 500, target = 1000, type = _STR309},
                {original = 1, target = 0, type = _STR310},
                {original = 0.9, target = 0, type = _STR311}
            }
        },
        [_STR318] = {
            modifications = {
                {original = 0.8, target = 1, type = _STR306},
                {original = 370, target = 1000, type = _STR307},
                {original = 15, target = 1000, type = _STR308},
                {original = 80, target = 1000, type = _STR309},
                {original = 0.2, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR196] = {
            modifications = {
                {original = 0.93, target = 1, type = _STR306},
                {original = 50, target = 1000, type = _STR307},
                {original = 5, target = 1000, type = _STR308},
                {original = 500, target = 1000, type = _STR309},
                {original = 0.8, target = 0, type = _STR310},
                {original = 2.2, target = 0, type = _STR311}
            }
        },
        [_STR319] = {
            modifications = {
                {original = 0.97, target = 1, type = _STR306},
                {original = 50, target = 1000, type = _STR307},
                {original = 7, target = 1000, type = _STR308},
                {original = 500, target = 1000, type = _STR309},
                {original = 0.8, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR320] = {
            modifications = {
                {original = 0.85, target = 1, type = _STR306},
                {original = 800, target = 1000, type = _STR307},
                {original = 30, target = 1000, type = _STR308},
                {original = 200, target = 1000, type = _STR309},
                {original = 0.35, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR321] = {
            modifications = {
                {original = 0.75, target = 1, type = _STR306},
                {original = 370, target = 1000, type = _STR307},
                {original = 7, target = 1000, type = _STR308},
                {original = 80, target = 1000, type = _STR309},
                {original = 0.25, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR322] = {
            modifications = {
                {original = 0.9, target = 1, type = _STR306},
                {original = 100, target = 1000, type = _STR307},
                {original = 1, target = 1000, type = _STR308},
                {original = 600, target = 1000, type = _STR309},
                {original = 2, target = 0, type = _STR310},
                {original = 2.6, target = 0, type = _STR311}
            }
        },
        [_STR323] = {
            modifications = {
                {original = 0.6, target = 1, type = _STR306},
                {original = 80, target = 1000, type = _STR307},
                {original = 5, target = 1000, type = _STR308},
                {original = 80, target = 1000, type = _STR309},
                {original = 1.5, target = 0, type = _STR310},
                {original = 2, target = 0, type = _STR311}
            }
        },
        [_STR324] = {
            modifications = {
                {original = 0.4, target = 1, type = _STR306},
                {original = 150, target = 1000, type = _STR307},
                {original = 2, target = 1000, type = _STR308},
                {original = 30, target = 1000, type = _STR309},
                {original = 3, target = 0, type = _STR310},
                {original = 3, target = 0, type = _STR311}
            }
        },
        [_STR325] = {
            modifications = {
                {original = 0.7, target = 1, type = _STR306},
                {original = 1200, target = 1000, type = _STR307},
                {original = 20, target = 1000, type = _STR308},
                {original = 150, target = 1000, type = _STR309},
                {original = 0.3, target = 0, type = _STR310},
                {original = 1.7, target = 0, type = _STR311}
            }
        }
    }
}

-- Function to restore original attributes
local function RestoreGunAttributes(tool)
    if not tool then return end
    
    local gunConfig = WeaponMod_State.gunConfigs[tool.Name]
    if not gunConfig then return end
    
    wait(0.1)
    
    for _, modification in ipairs(gunConfig.modifications) do
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == _STR179 then
                if math.abs(attrValue - (modification.target * WeaponMod_State.attributeMultipliers[modification.type])) < 0.01 then
                    tool:SetAttribute(attrName, modification.original)
                end
            end
        end
    end
end

-- Function to modify attributes for detected guns
local function ModifyGunAttributes(tool)
    if not tool then return end
    if not WeaponMod_State.enabled then return end
    
    local gunConfig = WeaponMod_State.gunConfigs[tool.Name]
    if not gunConfig then return end
    
    wait(0.1)
    
    for _, modification in ipairs(gunConfig.modifications) do
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == _STR179 then
                if math.abs(attrValue - modification.original) < 0.01 then
                    -- Apply individual multiplier based on attribute type
                    tool:SetAttribute(attrName, modification.target * WeaponMod_State.attributeMultipliers[modification.type])
                end
            end
        end
    end
end

-- Function to modify existing guns
local function ModifyExistingGuns()
    if not player.Character then return end
    
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA(_STR271) then
            ModifyGunAttributes(item)
        end
    end
    
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA(_STR271) then
            ModifyGunAttributes(item)
        end
    end
end

-- Function to restore existing guns
local function RestoreExistingGuns()
    if not player.Character then return end
    
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA(_STR271) then
            RestoreGunAttributes(item)
        end
    end
    
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA(_STR271) then
            RestoreGunAttributes(item)
        end
    end
end

-- Set up monitoring
player.Backpack.ChildAdded:Connect(function(newItem)
    if newItem:IsA(_STR271) and WeaponMod_State.enabled then
        ModifyGunAttributes(newItem)
    end
end)

player.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(newItem)
        if newItem:IsA(_STR271) and WeaponMod_State.enabled then
            ModifyGunAttributes(newItem)
        end
    end)
end)

if player.Character then
    player.Character.ChildAdded:Connect(function(newItem)
        if newItem:IsA(_STR271) and WeaponMod_State.enabled then
            ModifyGunAttributes(newItem)
        end
    end)
end

-- Luna UI Integration - Individual Sliders for Each Attribute
Weapon:CreateSlider({
    Name = _STR326,
    Range = {0.1, 1}, -- 0.1x to 1x accuracy multiplier (max 100% accuracy)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.accuracy = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR327)

Weapon:CreateSlider({
    Name = _STR328,
    Range = {1, 1000}, -- 1x to 1000x fire rate multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.fireRate = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR329)

Weapon:CreateSlider({
    Name = _STR330,
    Range = {1, 1000}, -- 1x to 1000x magazine size multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.magSize = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR331)

Weapon:CreateSlider({
    Name = _STR332,
    Range = {1, 1000}, -- 1x to 1000x range multiplier
    Increment = 10,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.range = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR333)

Weapon:CreateSlider({
    Name = _STR334,
    Range = {0, 2}, -- 0x to 2x recoil multiplier (0 = no recoil)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.recoil = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR335)

Weapon:CreateSlider({
    Name = _STR336,
    Range = {0, 2}, -- 0x to 2x reload time multiplier (0 = instant reload)
    Increment = 0.1,
    CurrentValue = 1,
    Callback = function(Value)
        WeaponMod_State.attributeMultipliers.reloadTime = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        end
    end
}, _STR337)

-- Main Toggle (placed at the bottom as requested)
local Toggle = Weapon:CreateToggle({
    Name = _STR338,
    Description = _STR339,
    CurrentValue = false,
    Callback = function(Value)
        WeaponMod_State.enabled = Value
        if WeaponMod_State.enabled then
            ModifyExistingGuns()
        else
            RestoreExistingGuns()
        end
    end
}, _STR340)

------------------------------------------------------------------------------
--AUTO RESPAWN (Optimized)
------------------------------------------------------------------------------

-- Consolidated state management for auto respawn
local AutoRespawn_State = {
    enabled = false,
    isRespawning = false,
    connections = {}
}

-- Function to find and click the respawn button
local function clickRespawnButton()
    if AutoRespawn_State.isRespawning or not AutoRespawn_State.enabled then return end
    AutoRespawn_State.isRespawning = true
    
    pcall(function()
        local playerGui = player.PlayerGui
        local deathScreen = playerGui:FindFirstChild(_STR341)
        
        if deathScreen then
            local deathScreenHolder = deathScreen:FindFirstChild(_STR342)
            if deathScreenHolder then
                local frame = deathScreenHolder:FindFirstChild(_STR273)
                if frame then
                    local respawnButtonFrame = frame:FindFirstChild(_STR343)
                    if respawnButtonFrame then
                        local respawnButton = respawnButtonFrame:FindFirstChild(_STR344)
                        if respawnButton and respawnButton.Visible and respawnButton.Parent.Visible then
                            -- Multiple click methods to ensure it works
                            
                            -- Method 1: Fire the click event
                            for _, connection in pairs(getconnections(respawnButton.MouseButton1Click)) do
                                connection:Fire()
                            end
                            
                            -- Method 2: Use GuiService
                            game:GetService(_STR345):FireClick(respawnButton)
                            
                            -- Method 3: Simulate mouse click
                            local VirtualInputManager = game:GetService(_STR346)
                            local buttonPos = respawnButton.AbsolutePosition
                            local buttonSize = respawnButton.AbsoluteSize
                            local centerX = buttonPos.X + buttonSize.X/2
                            local centerY = buttonPos.Y + buttonSize.Y/2
                            
                            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                            VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                            
                            return true
                        end
                    end
                end
            end
        end
    end)
    
    AutoRespawn_State.isRespawning = false
    return false
end

-- Continuous monitoring function
local function startAutoRespawn()
    if AutoRespawn_State.connections.heartbeat then 
        AutoRespawn_State.connections.heartbeat:Disconnect() 
    end
    
    AutoRespawn_State.connections.heartbeat = game:GetService(_STR5).Heartbeat:Connect(function()
        if not AutoRespawn_State.enabled then return end
        
        if player.Character == nil or 
           (player.Character and player.Character:FindFirstChild(_STR1) and player.Character.Humanoid.Health <= 0) then
            
            if clickRespawnButton() then
                wait(2) -- Wait before checking again
            end
        end
    end)
end

-- Monitor for death screen appearance
local function monitorDeathScreen()
    local playerGui = player:WaitForChild(_STR347)
    
    if AutoRespawn_State.connections.deathScreen then 
        AutoRespawn_State.connections.deathScreen:Disconnect() 
    end
    
    -- Watch for DeathScreen being added
    AutoRespawn_State.connections.deathScreen = playerGui.ChildAdded:Connect(function(child)
        if child.Name == _STR341 and AutoRespawn_State.enabled then
            wait(0.1) -- Small delay for GUI to load
            
            spawn(function()
                for attempts = 1, 50 do -- Try for 5 seconds
                    if not (child.Parent and AutoRespawn_State.enabled) then break end
                    if clickRespawnButton() then break end
                    wait(0.1)
                end
            end)
        end
    end)
end

-- Monitor humanoid death
local function setupDeathMonitoring()
    local function connectCharacterDeath(character)
        table.insert(AutoRespawn_State.connections, character:WaitForChild(_STR1).Died:Connect(function()
            if not AutoRespawn_State.enabled then return end
            wait(0.5) -- Wait for death screen
            
            -- Keep trying to click respawn button
            spawn(function()
                for i = 1, 30 do -- Try for 3 seconds
                    if not AutoRespawn_State.enabled then break end
                    if clickRespawnButton() then break end
                    wait(0.1)
                end
            end)
        end))
    end
    
    if AutoRespawn_State.connections.characterAdded then 
        AutoRespawn_State.connections.characterAdded:Disconnect() 
    end
    
    AutoRespawn_State.connections.characterAdded = player.CharacterAdded:Connect(connectCharacterDeath)
    
    -- Setup for current character if it exists
    if player.Character and player.Character:FindFirstChild(_STR1) then
        connectCharacterDeath(player.Character)
    end
end

-- Function to enable auto respawn
local function enableAutoRespawn()
    AutoRespawn_State.enabled = true
    monitorDeathScreen()
    setupDeathMonitoring()
    startAutoRespawn()
end

-- Function to disable auto respawn
local function disableAutoRespawn()
    AutoRespawn_State.enabled = false
    
    -- Disconnect all connections
    for _, connection in pairs(AutoRespawn_State.connections) do
        if connection and connection.Disconnect then
            connection:Disconnect()
        end
    end
    AutoRespawn_State.connections = {}
end

-- Luna toggle integration
local AutoRespawnToggle = Player:CreateToggle({
    Name = _STR348,
    Description = _STR349,
    CurrentValue = false,
    Callback = function(Value)
        if Value then
            enableAutoRespawn()
        else
            disableAutoRespawn()
        end
    end
}, _STR350)

-------------------------------------------------------------------------------
--AIMBOT (Optimized)
-------------------------------------------------------------------------------

-- Consolidated state management for aimbot
local Aimbot_State = {
    config = {
        LOCK_DISTANCE = 10000,
        CAMERA_HEIGHT_OFFSET = 0.5,
        FOV_RADIUS = 200,
        SHOW_FOV_CIRCLE = true,
        WHITELIST = {},
        WHITELISTED_PLAYERS = {},
        AIMBOT_ENABLED = false,
        wasLeftControlDown = false
    },
    currentTarget = nil,
    fovCircle = nil,
    aimConnection = nil
}

-- Core Functions
local function updatePlayerList()
    local names = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player then table.insert(names, p.Name) end
    end
    return names
end

local function cleanWhitelist()
    local current = {}
    for _, p in pairs(game.Players:GetPlayers()) do current[p.Name] = true end
    for name, _ in pairs(Aimbot_State.config.WHITELIST) do
        if not current[name] then
            Aimbot_State.config.WHITELIST[name] = nil
        end
    end
end

local function createDrawings()
    if Aimbot_State.fovCircle then Aimbot_State.fovCircle:Destroy() end
    
    Aimbot_State.fovCircle = Drawing.new(_STR351)
    Aimbot_State.fovCircle.Radius = Aimbot_State.config.FOV_RADIUS
    Aimbot_State.fovCircle.Color = Color3.new(1, 1, 1)
    Aimbot_State.fovCircle.Transparency = 0.5
    Aimbot_State.fovCircle.Visible = false
    Aimbot_State.fovCircle.Thickness = 2
    Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
end

local function updateVisuals()
    if Aimbot_State.fovCircle then
        Aimbot_State.fovCircle.Visible = Aimbot_State.config.SHOW_FOV_CIRCLE and Aimbot_State.config.AIMBOT_ENABLED
        Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    end
end

local function isInFOV(target)
    local char = player.Character
    if not char or not target.Character then return false end
    
    local head = target.Character:FindFirstChild(_STR180)
    if not head then return false end
    
    local center = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    local screen = workspace.CurrentCamera:WorldToScreenPoint(head.Position)
    local dist = (Vector2.new(screen.X, screen.Y) - center).Magnitude
    
    return dist <= Aimbot_State.config.FOV_RADIUS
end

local function isVisible(char)
    if not char or not player.Character then return false end
    
    local head = char:FindFirstChild(_STR180)
    local root = player.Character:FindFirstChild(_STR2)
    if not head or not root then return false end
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {player.Character}
    
    local result = workspace:Raycast(root.Position, 
        (head.Position - root.Position).Unit * Aimbot_State.config.LOCK_DISTANCE, params)
    
    return result == nil or result.Instance:IsDescendantOf(char)
end

local function findTarget()
    local char = player.Character
    if not char then return nil end
    
    local root = char:FindFirstChild(_STR2)
    if not root then return nil end
    
    local closest = nil
    local shortest = Aimbot_State.config.LOCK_DISTANCE
    
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player and not Aimbot_State.config.WHITELIST[p.Name] then
            local pChar = p.Character
            local pRoot = pChar and pChar:FindFirstChild(_STR2)
            
            if pRoot then
                local dist = (pRoot.Position - root.Position).Magnitude
                if dist < shortest and isVisible(pChar) and isInFOV(p) then
                    closest = p
                    shortest = dist
                end
            end
        end
    end
    
    return closest
end

local function aimNormal(target)
    -- Clear any existing target and connection
    if Aimbot_State.currentTarget then
        Aimbot_State.currentTarget = nil
    end
    if Aimbot_State.aimConnection then
        Aimbot_State.aimConnection:Disconnect()
        Aimbot_State.aimConnection = nil
    end
    
    Aimbot_State.currentTarget = target
    
    Aimbot_State.aimConnection = game:GetService(_STR5).RenderStepped:Connect(function()
        if not Aimbot_State.config.AIMBOT_ENABLED or 
           not game:GetService(_STR6):IsKeyDown(Enum.KeyCode.LeftControl) or
           not Aimbot_State.currentTarget or not Aimbot_State.currentTarget.Character or
           not Aimbot_State.currentTarget.Character:FindFirstChild(_STR180) then
            
            if Aimbot_State.aimConnection then
                Aimbot_State.aimConnection:Disconnect()
                Aimbot_State.aimConnection = nil
            end
            Aimbot_State.currentTarget = nil
            return
        end
        
        workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, 
            Aimbot_State.currentTarget.Character.Head.Position + Vector3.new(0, Aimbot_State.config.CAMERA_HEIGHT_OFFSET, 0))
    end)
end

-- Initialize
createDrawings()

-- Luna UI Components
Aimbot:CreateToggle({
    Name = _STR352,
    Description = _STR353,
    CurrentValue = false,
    Callback = function(Value)
        Aimbot_State.config.AIMBOT_ENABLED = Value
        if not Value then 
            Aimbot_State.currentTarget = nil
            if Aimbot_State.aimConnection then
                Aimbot_State.aimConnection:Disconnect()
                Aimbot_State.aimConnection = nil
            end
        end
    end
}, _STR354)

Aimbot:CreateSlider({
    Name = _STR355,
    Range = {10, 1000},
    Increment = 10,
    CurrentValue = 200,
    Callback = function(Value)
        Aimbot_State.config.FOV_RADIUS = Value
        if Aimbot_State.fovCircle then Aimbot_State.fovCircle.Radius = Value end
    end
}, _STR356)

Aimbot:CreateToggle({
    Name = _STR357,
    Description = _STR358,
    CurrentValue = true,
    Callback = function(Value)
        Aimbot_State.config.SHOW_FOV_CIRCLE = Value
    end
}, _STR359)

Aimbot:CreateDropdown({
    Name = _STR360,
    Description = _STR361,
    Options = updatePlayerList(),
    CurrentOption = {},
    MultipleOptions = true,
    Callback = function(Options)
        Aimbot_State.config.WHITELIST = {}
        local opts = type(Options) == _STR362 and Options or {Options}
        for _, name in pairs(opts) do
            Aimbot_State.config.WHITELIST[name] = true
        end
        Aimbot_State.config.WHITELISTED_PLAYERS = Options
    end
}, _STR363)

-- Event Handlers
game.Players.PlayerAdded:Connect(function(p)
    wait(1)
    cleanWhitelist()
end)

game.Players.PlayerRemoving:Connect(function(p)
    if Aimbot_State.config.WHITELIST[p.Name] then
        Aimbot_State.config.WHITELIST[p.Name] = nil
    end
    if Aimbot_State.currentTarget == p then 
        Aimbot_State.currentTarget = nil
    end
    cleanWhitelist()
end)

-- Main Loop
game:GetService(_STR5).RenderStepped:Connect(function()
    local ctrl = game:GetService(_STR6):IsKeyDown(Enum.KeyCode.LeftControl)
    
    if Aimbot_State.config.AIMBOT_ENABLED then
        -- Check for left control activation
        if ctrl and not Aimbot_State.config.wasLeftControlDown then
            local target = findTarget()
            if target then
                aimNormal(target)
            end
        end
        
        Aimbot_State.config.wasLeftControlDown = ctrl
    end
    
    updateVisuals()
end)

-- FOV Toggle
game:GetService(_STR6).InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.O then
        Aimbot_State.config.SHOW_FOV_CIRCLE = not Aimbot_State.config.SHOW_FOV_CIRCLE
    end
end)
----------------------------------------------------------------------------------------------------------------------------
--COMBAT (Optimized)
----------------------------------------------------------------------------------------------------------------------------

-- Consolidated state management for combat
local Combat_State = {
    enabled = false,
    customRange = 50,
    originalAttributes = {},
    meleeWeapons = {
        [_STR364] = {speed = 1.4, range = 6.5},
        [_STR197] = {speed = 1.6, range = 7.5},
        [_STR198] = {speed = 1.6, range = 7.5},
        [_STR199] = {speed = 1.9, range = 6},
        [_STR201] = {speed = 1.5, range = 6.5},
        [_STR202] = {speed = 1.6, range = 6.5},
        [_STR203] = {speed = 1.6, range = 6},
        [_STR204] = {speed = 1.6, range = 6.5},
        [_STR365] = {speed = 1.6, range = 7},
        [_STR205] = {speed = 1.5, range = 6.5},
        [_STR206] = {speed = 1.7, range = 6.5},
        [_STR207] = {speed = 1.5, range = 6.5},
        [_STR366] = {speed = 1.75, range = 6},
        [_STR367] = {speed = 1.8, range = 7.25},
        [_STR208] = {speed = 1.6, range = 7.5},
        [_STR209] = {speed = 1.55, range = 6.5},
        [_STR368] = {speed = 1.5, range = 6.5},
        [_STR210] = {speed = 1.4, range = 6.5},
        [_STR211] = {speed = 1.7, range = 7.5},
        [_STR212] = {speed = 1.75, range = 6.5},
        [_STR213] = {speed = 1.2, range = 7},
        [_STR369] = {speed = 2, range = 5.5},
        [_STR370] = {speed = 1.2, range = 67.5},
        [_STR214] = {speed = 1.5, range = 6.5},
        [_STR215] = {speed = 1.1, range = 7.25},
        [_STR371] = {speed = 2, range = 5.5},
        [_STR216] = {speed = 1.75, range = 6.5},
        [_STR217] = {speed = 2.2, range = 5.75},
        [_STR218] = {speed = 2, range = 6.75},
        [_STR372] = {speed = 2, range = 5.25},
        [_STR219] = {speed = 1.6, range = 6.5},
        [_STR220] = {speed = 1.45, range = 6.5},
        [_STR373] = {speed = 1.5, range = 6},
        [_STR374] = {speed = 1, range = 5}
    }
}

-- Function to store original attributes of a tool
local function StoreOriginalAttributes(tool)
    if not tool or Combat_State.originalAttributes[tool] then return end
    
    local weaponData = Combat_State.meleeWeapons[tool.Name]
    if not weaponData then return end
    
    Combat_State.originalAttributes[tool] = {}
    
    for attrName, attrValue in pairs(tool:GetAttributes()) do
        if type(attrValue) == _STR179 then
            Combat_State.originalAttributes[tool][attrName] = attrValue
        end
    end
end

-- Function to modify or restore attributes for detected melee weapons
local function ModifyMeleeAttributes(tool, shouldModify)
    if not tool then return end
    
    -- Check if this tool is a known melee weapon
    local weaponData = Combat_State.meleeWeapons[tool.Name]
    if not weaponData then return end
    
    -- Wait a brief moment for tool to fully load
    wait(0.1)
    
    -- Store original attributes if not already stored
    StoreOriginalAttributes(tool)
    
    if shouldModify then
        -- Get all attributes
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == _STR179 then
                -- Check if this attribute matches the expected speed value
                if math.abs(attrValue - weaponData.speed) < 0.01 then
                    tool:SetAttribute(attrName, 0)  -- Set speed to 0
                end
                
                -- Check if this attribute matches the expected range value
                if math.abs(attrValue - weaponData.range) < 0.01 then
                    tool:SetAttribute(attrName, Combat_State.customRange)  -- Set range to custom value
                end
            end
        end
    else
        -- Restore original attributes
        if Combat_State.originalAttributes[tool] then
            for attrName, originalValue in pairs(Combat_State.originalAttributes[tool]) do
                tool:SetAttribute(attrName, originalValue)
            end
        end
    end
end

-- Function to modify/restore existing tools
local function ProcessExistingTools(shouldModify)
    if not player.Character then return end
    
    -- Check currently equipped tools
    for _, item in pairs(player.Character:GetChildren()) do
        if item:IsA(_STR271) then
            ModifyMeleeAttributes(item, shouldModify)
        end
    end
    
    -- Check all tools in backpack
    for _, item in pairs(player.Backpack:GetChildren()) do
        if item:IsA(_STR271) then
            ModifyMeleeAttributes(item, shouldModify)
        end
    end
end

-- Function to handle new tools being added
local function HandleNewTool(newItem)
    if newItem:IsA(_STR271) and Combat_State.enabled then
        ModifyMeleeAttributes(newItem, true)
    end
end

-- Set up automatic detection for NEW tools added to backpack
player.Backpack.ChildAdded:Connect(HandleNewTool)

-- Set up automatic detection for NEW tools equipped to character
player.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(HandleNewTool)
end)

-- Also set up monitoring for current character if it exists
if player.Character then
    player.Character.ChildAdded:Connect(HandleNewTool)
end

-- Luna Toggle Implementation
Combat:CreateToggle({
    Name = _STR375,
    Description = _STR376,
    CurrentValue = false,
    Callback = function(Value)
        Combat_State.enabled = Value
        
        if Combat_State.enabled then
            -- Enable: Modify all existing tools
            ProcessExistingTools(true)
        else
            -- Disable: Restore all existing tools to original values
            ProcessExistingTools(false)
        end
    end
}, _STR377)

-- Luna Slider Implementation for Range
Combat:CreateSlider({
    Name = _STR378,
    Range = {10, 50}, -- Range from 10 to 50
    Increment = 1, -- Change by 1 unit
    CurrentValue = 50, -- Starting value
    Callback = function(Value)
        Combat_State.customRange = Value
        
        -- If modifier is currently enabled, update all existing weapons with new range
        if Combat_State.enabled then
            ProcessExistingTools(true)
        end
    end
}, _STR379)
----------------------------------------------------------------------------------------------------------------------------
--AUTO FINISH (Optimized)
----------------------------------------------------------------------------------------------------------------------------

-- Consolidated state management for auto finish
local AutoFinish_State = {
    enabled = false,
    distance = 10,
    whitelist = {},
    running = false
}

-- Function to get current player names for dropdown
local function getPlayerNames()
    local names = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        if p ~= player then
            table.insert(names, p.Name)
        end
    end
    return names
end

-- Function to clean whitelist of players who left
local function cleanWhitelist()
    local currentPlayers = {}
    for _, p in pairs(game.Players:GetPlayers()) do
        currentPlayers[p.Name] = true
    end
    
    -- Remove players from whitelist who are no longer in game
    for playerName, _ in pairs(AutoFinish_State.whitelist) do
        if not currentPlayers[playerName] then
            AutoFinish_State.whitelist[playerName] = nil
        end
    end
end

-- Luna UI Components
Combat:CreateToggle({
    Name = _STR380,
    Description = _STR381,
    CurrentValue = false,
    Callback = function(v) 
        AutoFinish_State.enabled = v 
    end
}, _STR382)

Combat:CreateSlider({
    Name = _STR383,
    Range = {1, 20},
    Increment = 1,
    CurrentValue = 10,
    Callback = function(v) 
        AutoFinish_State.distance = v 
    end
}, _STR384)

Combat:CreateDropdown({
    Name = _STR360,
    Description = _STR385,
    Options = getPlayerNames(),
    CurrentOption = {},
    MultipleOptions = true,
    SpecialType = nil,
    Callback = function(Options)
        -- Clear current whitelist
        AutoFinish_State.whitelist = {}
        
        -- Add selected players to whitelist
        local selectedPlayers = type(Options) == _STR362 and Options or {Options}
        for _, playerName in pairs(selectedPlayers) do
            AutoFinish_State.whitelist[playerName] = true
        end
    end
}, _STR386)

-- Handle players leaving
game.Players.PlayerRemoving:Connect(function(leavingPlayer)
    -- Remove from whitelist if they leave
    if AutoFinish_State.whitelist[leavingPlayer.Name] then
        AutoFinish_State.whitelist[leavingPlayer.Name] = nil
    end
end)

-- Start the main loop if not already running
if not AutoFinish_State.running then
    AutoFinish_State.running = true
    spawn(function()
        while AutoFinish_State.running do
            -- Clean whitelist every 30 seconds to remove disconnected players
            if tick() % 30 < 0.1 then
                cleanWhitelist()
            end
            
            if AutoFinish_State.enabled then
                for _, v in ipairs(game.Players:GetPlayers()) do
                    -- Skip if player is whitelisted or is the local player
                    if v ~= player and not AutoFinish_State.whitelist[v.Name] then
                        local c = v.Character
                        if c then
                            local h = c:FindFirstChild(_STR2)
                            if h then
                                local p = h:FindFirstChild(_STR387)
                                if p and p:IsA(_STR116) then
                                    p.HoldDuration = 0
                                    p.MaxActivationDistance = AutoFinish_State.distance
                                    pcall(function()
                                        p:InputHoldBegin()
                                        p:InputHoldEnd()
                                    end)
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.1)
        end
    end)
end
