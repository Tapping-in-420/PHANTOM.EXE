-- Enhanced Phantom UI - CLEAN WORKING VERSION
local PhantomUI = {}

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Enhanced theme system
-- Find this section in your script and replace the Dark theme colors:

PhantomUI.Themes = {
    Dark = {
        Primary = Color3.fromRGB(138, 43, 226),        -- Purple (instead of teal)
        Background = Color3.fromRGB(15, 15, 15),       -- Keep dark background
        BackgroundTransparency = 0.1,
        HeaderBackground = Color3.fromRGB(10, 10, 10), -- Keep dark header
        HeaderTransparency = 0.05,
        Text = Color3.fromRGB(240, 240, 240),          -- Keep white text
        TextSecondary = Color3.fromRGB(180, 180, 180), -- Keep gray secondary text
        Success = Color3.fromRGB(75, 210, 115),        -- Keep green success
        Error = Color3.fromRGB(255, 75, 75),           -- Keep red error
        Warning = Color3.fromRGB(255, 195, 0),         -- Keep yellow warning
        ArrowColor = Color3.fromRGB(138, 43, 226),     -- Purple arrows
        Accent = Color3.fromRGB(147, 112, 219),        -- Light purple accent
        Border = Color3.fromRGB(40, 40, 40),           -- Keep dark border
        Hover = Color3.fromRGB(25, 25, 25)             -- Keep dark hover
    },
    Light = {
        Primary = Color3.fromRGB(138, 43, 226),        -- Purple for light theme too
        Background = Color3.fromRGB(255, 255, 255),
        BackgroundTransparency = 0.1,
        HeaderBackground = Color3.fromRGB(248, 248, 248),
        HeaderTransparency = 0.05,
        Text = Color3.fromRGB(50, 50, 50),
        TextSecondary = Color3.fromRGB(120, 120, 120),
        Success = Color3.fromRGB(40, 167, 69),
        Error = Color3.fromRGB(220, 53, 69),
        Warning = Color3.fromRGB(255, 193, 7),
        ArrowColor = Color3.fromRGB(138, 43, 226),     -- Purple arrows
        Accent = Color3.fromRGB(147, 112, 219),        -- Light purple accent
        Border = Color3.fromRGB(220, 220, 220),
        Hover = Color3.fromRGB(240, 240, 240)
    }
}

-- Current theme
PhantomUI.CurrentTheme = "Dark"
PhantomUI.Theme = PhantomUI.Themes[PhantomUI.CurrentTheme]

-- UI State Management
PhantomUI.State = {
    WindowOpen = true,
    CurrentCategory = nil,
    Categories = {}
}

-- Animation settings
PhantomUI.Animations = {
    Fast = 0.15,
    Normal = 0.25,
    EasingStyle = Enum.EasingStyle.Quart,
    EasingDirection = Enum.EasingDirection.Out
}

-- Helper function for tweening
function PhantomUI:Tween(object, properties, duration, easing, direction)
    local info = TweenInfo.new(
        duration or self.Animations.Normal,
        easing or self.Animations.EasingStyle,
        direction or self.Animations.EasingDirection
    )
    local tween = TweenService:Create(object, info, properties)
    tween:Play()
    return tween
end

-- Theme switching functionality
function PhantomUI:SetTheme(themeName)
    if not self.Themes[themeName] then return end
    
    self.CurrentTheme = themeName
    self.Theme = self.Themes[themeName]
    
    -- Update all UI elements with new theme
    self:UpdateTheme()
    self:Notify("Theme", "Switched to " .. themeName .. " theme", 2, "Success")
end

function PhantomUI:UpdateTheme()
    if not self.MainFrame then return end
    
    -- Update main frame
    self:Tween(self.MainFrame, {
        BackgroundColor3 = self.Theme.Background,
        BackgroundTransparency = self.Theme.BackgroundTransparency
    })
    
    -- Update header
    if self.Header then
        self:Tween(self.Header, {
            BackgroundColor3 = self.Theme.HeaderBackground,
            BackgroundTransparency = self.Theme.HeaderTransparency
        })
    end
    
    -- Update accent bar
    if self.AccentBar then
        self:Tween(self.AccentBar, {BackgroundColor3 = self.Theme.Primary})
    end
    
    -- Update title and version colors
    if self.Title then
        self:Tween(self.Title, {TextColor3 = self.Theme.Text})
    end
    if self.Version then
        self:Tween(self.Version, {TextColor3 = self.Theme.Primary})
    end
    
    -- Update border
    if self.BorderFrame then
        self:Tween(self.BorderFrame, {BackgroundColor3 = self.Theme.Border})
    end
    
    -- Update scrollbar
    if self.ContentFrame then
        self.ContentFrame.ScrollBarImageColor3 = self.Theme.Primary
    end
end

-- Initialize the UI
function PhantomUI:Init(config)
    config = config or {}
    
    -- Default configuration
    self.Config = {
        Title = config.Title or "Phantom Enhanced",
        Version = config.Version or "2.0.0",
        Size = config.Size or UDim2.new(0, 320, 0, 450),
        Position = config.Position or UDim2.new(0, 50, 0.5, -260)
    }
    
    -- Create ScreenGui with protection
    self.ScreenGui = Instance.new("ScreenGui")
    self.ScreenGui.Name = "PhantomUI_Enhanced"
    self.ScreenGui.ResetOnSpawn = false
    self.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Enhanced protection
    local success = pcall(function()
        if syn and syn.protect_gui then
            syn.protect_gui(self.ScreenGui)
            self.ScreenGui.Parent = game:GetService("CoreGui")
        elseif gethui then
            self.ScreenGui.Parent = gethui()
        else
            self.ScreenGui.Parent = game:GetService("CoreGui")
        end
    end)
    
    if not success or not self.ScreenGui.Parent then
        self.ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Create the main window
    self:CreateMainWindow()
    
    -- Initialize keybinds
    self:InitializeKeybinds()
    
    return self
end

-- Create main window
function PhantomUI:CreateMainWindow()
    -- Main frame with modern styling
    self.MainFrame = Instance.new("Frame")
    self.MainFrame.Name = "MainFrame"
    self.MainFrame.Size = self.Config.Size
    self.MainFrame.Position = self.Config.Position
    self.MainFrame.BackgroundColor3 = self.Theme.Background
    self.MainFrame.BackgroundTransparency = self.Theme.BackgroundTransparency
    self.MainFrame.BorderSizePixel = 0
    self.MainFrame.ClipsDescendants = true
    self.MainFrame.Parent = self.ScreenGui
    
    -- Modern corner radius
    local mainCorner = Instance.new("UICorner")
    mainCorner.CornerRadius = UDim.new(0, 8)
    mainCorner.Parent = self.MainFrame
    
    -- Enhanced border effect
    self.BorderFrame = Instance.new("Frame")
    self.BorderFrame.Name = "Border"
    self.BorderFrame.Size = UDim2.new(1, 2, 1, 2)
    self.BorderFrame.Position = UDim2.new(0, -1, 0, -1)
    self.BorderFrame.BackgroundColor3 = self.Theme.Border
    self.BorderFrame.BackgroundTransparency = 0.5
    self.BorderFrame.BorderSizePixel = 0
    self.BorderFrame.ZIndex = 0
    self.BorderFrame.Parent = self.MainFrame
    
    local borderCorner = Instance.new("UICorner")
    borderCorner.CornerRadius = UDim.new(0, 9)
    borderCorner.Parent = self.BorderFrame
    
    -- Left accent bar
    self.AccentBar = Instance.new("Frame")
    self.AccentBar.Name = "AccentBar"
    self.AccentBar.Size = UDim2.new(0, 3, 1, 0)
    self.AccentBar.Position = UDim2.new(0, 0, 0, 0)
    self.AccentBar.BackgroundColor3 = self.Theme.Primary
    self.AccentBar.BorderSizePixel = 0
    self.AccentBar.ZIndex = 2
    self.AccentBar.Parent = self.MainFrame
    
    local accentCorner = Instance.new("UICorner")
    accentCorner.CornerRadius = UDim.new(0, 8)
    accentCorner.Parent = self.AccentBar
    
    -- Create header
    self:CreateHeader()
    
    -- Create content area
    self:CreateContentArea()
    
    -- Make draggable
    self:MakeDraggable()
end

-- Create header
function PhantomUI:CreateHeader()
    self.Header = Instance.new("Frame")
    self.Header.Name = "Header"
    self.Header.Size = UDim2.new(1, 0, 0, 45)
    self.Header.BackgroundColor3 = self.Theme.HeaderBackground
    self.Header.BackgroundTransparency = self.Theme.HeaderTransparency
    self.Header.BorderSizePixel = 0
    self.Header.ZIndex = 3
    self.Header.Parent = self.MainFrame
    
    -- Header corners (only top)
    local headerCorner = Instance.new("UICorner")
    headerCorner.CornerRadius = UDim.new(0, 8)
    headerCorner.Parent = self.Header
    
    -- Fix bottom corners
    local headerFix = Instance.new("Frame")
    headerFix.Size = UDim2.new(1, 0, 0, 8)
    headerFix.Position = UDim2.new(0, 0, 1, -8)
    headerFix.BackgroundColor3 = self.Theme.HeaderBackground
    headerFix.BackgroundTransparency = self.Theme.HeaderTransparency
    headerFix.BorderSizePixel = 0
    headerFix.ZIndex = 3
    headerFix.Parent = self.Header
    
    -- Header separator
    local separator = Instance.new("Frame")
    separator.Name = "Separator"
    separator.Size = UDim2.new(1, -20, 0, 1)
    separator.Position = UDim2.new(0, 10, 1, -1)
    separator.BackgroundColor3 = self.Theme.Primary
    separator.BackgroundTransparency = 0.3
    separator.BorderSizePixel = 0
    separator.ZIndex = 4
    separator.Parent = self.Header
    
    -- Title
    self.Title = Instance.new("TextLabel")
    self.Title.Name = "Title"
    self.Title.Size = UDim2.new(1, -100, 1, 0)
    self.Title.Position = UDim2.new(0, 15, 0, 0)
    self.Title.BackgroundTransparency = 1
    self.Title.Text = self.Config.Title
    self.Title.TextColor3 = self.Theme.Text
    self.Title.TextSize = 18
    self.Title.Font = Enum.Font.SciFi
    self.Title.TextXAlignment = Enum.TextXAlignment.Left
    self.Title.ZIndex = 4
    self.Title.Parent = self.Header
    
    -- Version
    self.Version = Instance.new("TextLabel")
    self.Version.Name = "Version"
    self.Version.Size = UDim2.new(0, 60, 0, 16)
    self.Version.Position = UDim2.new(1, -70, 1, -20)
    self.Version.BackgroundTransparency = 1
    self.Version.Text = "v" .. self.Config.Version
    self.Version.TextColor3 = self.Theme.Primary
    self.Version.TextSize = 12
    self.Version.Font = Enum.Font.SourceSans
    self.Version.TextXAlignment = Enum.TextXAlignment.Right
    self.Version.ZIndex = 4
    self.Version.Parent = self.MainFrame
    
    -- Close button
    self:CreateCloseButton()
end

-- Create close button
function PhantomUI:CreateCloseButton()
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 25, 0, 25)
    closeButton.Position = UDim2.new(1, -30, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(138, 43, 226)
    closeButton.BackgroundTransparency = 0.8
    closeButton.BorderSizePixel = 0
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 12
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.ZIndex = 5
    closeButton.Parent = self.Header
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(1, 0)
    closeCorner.Parent = closeButton
    
    -- Hover effects
    closeButton.MouseEnter:Connect(function()
        self:Tween(closeButton, {BackgroundTransparency = 0.2}, self.Animations.Fast)
    end)
    
    closeButton.MouseLeave:Connect(function()
        self:Tween(closeButton, {BackgroundTransparency = 0.8}, self.Animations.Fast)
    end)
    
    closeButton.MouseButton1Click:Connect(function()
        self:Toggle()
    end)
end

-- Create content area
function PhantomUI:CreateContentArea()
    local contentContainer = Instance.new("Frame")
    contentContainer.Name = "ContentContainer"
    contentContainer.Size = UDim2.new(1, 0, 1, -55)
    contentContainer.Position = UDim2.new(0, 0, 0, 45)
    contentContainer.BackgroundTransparency = 1
    contentContainer.ClipsDescendants = true
    contentContainer.ZIndex = 2
    contentContainer.Parent = self.MainFrame
    
    -- Scrolling frame
    self.ContentFrame = Instance.new("ScrollingFrame")
    self.ContentFrame.Name = "ScrollFrame"
    self.ContentFrame.Size = UDim2.new(1, -10, 1, -10)
    self.ContentFrame.Position = UDim2.new(0, 5, 0, 5)
    self.ContentFrame.BackgroundTransparency = 1
    self.ContentFrame.BorderSizePixel = 0
    self.ContentFrame.ScrollBarThickness = 4
    self.ContentFrame.ScrollBarImageColor3 = self.Theme.Primary
    self.ContentFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    self.ContentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    self.ContentFrame.ZIndex = 2
    self.ContentFrame.Parent = contentContainer
    
    -- List layout
    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 5)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.Parent = self.ContentFrame
    
    -- Auto-update canvas size
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        self.ContentFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y + 20)
    end)
end

-- Make window draggable
function PhantomUI:MakeDraggable()
    local dragging = false
    local dragInput, dragStart, startPos
    
    self.Header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = self.MainFrame.Position
        end
    end)
    
    self.Header.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            self.MainFrame.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- Enhanced notification system
function PhantomUI:Notify(title, content, duration, type)
    duration = duration or 3
    type = type or "Info"
    
    -- Create notification container if needed
    if not self.NotificationContainer then
        self.NotificationContainer = Instance.new("Frame")
        self.NotificationContainer.Name = "NotificationContainer"
        self.NotificationContainer.Size = UDim2.new(0, 300, 1, 0)
        self.NotificationContainer.Position = UDim2.new(1, -310, 0, 0)
        self.NotificationContainer.BackgroundTransparency = 1
        self.NotificationContainer.ZIndex = 100
        self.NotificationContainer.Parent = self.ScreenGui
        
        local notifLayout = Instance.new("UIListLayout")
        notifLayout.Padding = UDim.new(0, 8)
        notifLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        notifLayout.VerticalAlignment = Enum.VerticalAlignment.Bottom
        notifLayout.SortOrder = Enum.SortOrder.LayoutOrder
        notifLayout.Parent = self.NotificationContainer
        
        local notifPadding = Instance.new("UIPadding")
        notifPadding.PaddingBottom = UDim.new(0, 15)
        notifPadding.Parent = self.NotificationContainer
    end
    
    -- Color based on type
    local notifColor = self.Theme.Primary
    if type == "Success" then notifColor = self.Theme.Success
    elseif type == "Error" then notifColor = self.Theme.Error
    elseif type == "Warning" then notifColor = self.Theme.Warning
    end
    
    -- Create notification
    local notification = Instance.new("Frame")
    notification.Name = "Notification"
    notification.Size = UDim2.new(1, -20, 0, 70)
    notification.BackgroundColor3 = self.Theme.Background
    notification.BackgroundTransparency = 0.1
    notification.BorderSizePixel = 0
    notification.ZIndex = 101
    notification.Parent = self.NotificationContainer
    
    local notifCorner = Instance.new("UICorner")
    notifCorner.CornerRadius = UDim.new(0, 6)
    notifCorner.Parent = notification
    
    -- Color bar
    local colorBar = Instance.new("Frame")
    colorBar.Size = UDim2.new(0, 4, 1, 0)
    colorBar.BackgroundColor3 = notifColor
    colorBar.BorderSizePixel = 0
    colorBar.ZIndex = 102
    colorBar.Parent = notification
    
    local barCorner = Instance.new("UICorner")
    barCorner.CornerRadius = UDim.new(0, 6)
    barCorner.Parent = colorBar
    
    -- Title
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, -55, 0, 22)
    titleLabel.Position = UDim2.new(0, 15, 0, 8)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = notifColor
    titleLabel.TextSize = 14
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    titleLabel.ZIndex = 103
    titleLabel.Parent = notification
    
    -- Content
    local contentLabel = Instance.new("TextLabel")
    contentLabel.Size = UDim2.new(1, -25, 0, 35)
    contentLabel.Position = UDim2.new(0, 15, 0, 30)
    contentLabel.BackgroundTransparency = 1
    contentLabel.Text = content
    contentLabel.TextColor3 = self.Theme.TextSecondary
    contentLabel.TextSize = 12
    contentLabel.Font = Enum.Font.SourceSans
    contentLabel.TextXAlignment = Enum.TextXAlignment.Left
    contentLabel.TextYAlignment = Enum.TextYAlignment.Top
    contentLabel.TextWrapped = true
    contentLabel.ZIndex = 102
    contentLabel.Parent = notification
    
    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 20, 0, 20)
    closeButton.Position = UDim2.new(1, -25, 0, 5)
    closeButton.BackgroundTransparency = 1
    closeButton.Text = "✕"
    closeButton.TextColor3 = self.Theme.TextSecondary
    closeButton.TextSize = 12
    closeButton.Font = Enum.Font.SourceSansBold
    closeButton.ZIndex = 103
    closeButton.Parent = notification
    
    -- Animate in
    notification.Position = UDim2.new(1, 0, 0, 0)
    self:Tween(notification, {Position = UDim2.new(0, 0, 0, 0)}, self.Animations.Normal)
    
    -- Close function
    local function closeNotif()
        self:Tween(notification, {
            Position = UDim2.new(1, 0, 0, 0),
            BackgroundTransparency = 1
        }, self.Animations.Fast)
        
        spawn(function()
            wait(self.Animations.Fast)
            notification:Destroy()
        end)
    end
    
    closeButton.MouseButton1Click:Connect(closeNotif)
    
    -- Auto close
    if duration > 0 then
        spawn(function()
            wait(duration)
            closeNotif()
        end)
    end
end

-- Add category function with ALL components
function PhantomUI:AddCategory(name)
    local category = {
        Name = name,
        Items = {},
        IsOpen = false,
        Frame = nil,
        ContentFrame = nil
    }
    
    -- Category frame
    local categoryFrame = Instance.new("Frame")
    categoryFrame.Name = name .. "Category"
    categoryFrame.Size = UDim2.new(1, -10, 0, 40)
    categoryFrame.BackgroundColor3 = self.Theme.Background
    categoryFrame.BackgroundTransparency = 0.3
    categoryFrame.BorderSizePixel = 0
    categoryFrame.ZIndex = 3
    categoryFrame.LayoutOrder = #self.State.Categories + 1
    categoryFrame.Parent = self.ContentFrame
    
    local categoryCorner = Instance.new("UICorner")
    categoryCorner.CornerRadius = UDim.new(0, 6)
    categoryCorner.Parent = categoryFrame
    
    -- Category text
    local categoryText = Instance.new("TextLabel")
    categoryText.Size = UDim2.new(1, -40, 1, 0)
    categoryText.Position = UDim2.new(0, 15, 0, 0)
    categoryText.BackgroundTransparency = 1
    categoryText.Text = name
    categoryText.TextColor3 = self.Theme.Text
    categoryText.TextSize = 16
    categoryText.Font = Enum.Font.SourceSansSemibold
    categoryText.TextXAlignment = Enum.TextXAlignment.Left
    categoryText.ZIndex = 4
    categoryText.Parent = categoryFrame
    
    -- Arrow
    local arrow = Instance.new("TextLabel")
    arrow.Size = UDim2.new(0, 20, 0, 20)
    arrow.Position = UDim2.new(1, -30, 0.5, -10)
    arrow.BackgroundTransparency = 1
    arrow.Text = ">"
    arrow.TextColor3 = self.Theme.Primary
    arrow.TextSize = 14
    arrow.Font = Enum.Font.SourceSansBold
    arrow.ZIndex = 4
    arrow.Parent = categoryFrame
    
    -- Button
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 1, 0)
    button.BackgroundTransparency = 1
    button.Text = ""
    button.ZIndex = 5
    button.Parent = categoryFrame
    
    -- Content frame
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = name .. "Content"
    contentFrame.Size = UDim2.new(1, -10, 0, 0)
    contentFrame.BackgroundTransparency = 1
    contentFrame.Visible = false
    contentFrame.ZIndex = 3
    contentFrame.LayoutOrder = #self.State.Categories + 2
    contentFrame.Parent = self.ContentFrame
    
    local contentLayout = Instance.new("UIListLayout")
    contentLayout.Padding = UDim.new(0, 2)
    contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
    contentLayout.Parent = contentFrame
    
    -- Update content size
    contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        if category.IsOpen then
            contentFrame.Size = UDim2.new(1, -10, 0, contentLayout.AbsoluteContentSize.Y)
        end
    end)
    
    -- Category functions
    category.Frame = categoryFrame
    category.ContentFrame = contentFrame
    category.Arrow = arrow
    
    -- Button click handler
    button.MouseButton1Click:Connect(function()
        category.IsOpen = not category.IsOpen
        
        if category.IsOpen then
            contentFrame.Visible = true
            self:Tween(arrow, {Rotation = 90}, self.Animations.Fast)
            self:Tween(contentFrame, {Size = UDim2.new(1, -10, 0, contentLayout.AbsoluteContentSize.Y)}, self.Animations.Normal)
        else
            self:Tween(arrow, {Rotation = 0}, self.Animations.Fast)
            self:Tween(contentFrame, {Size = UDim2.new(1, -10, 0, 0)}, self.Animations.Normal)
            spawn(function()
                wait(self.Animations.Normal)
                if not category.IsOpen then
                    contentFrame.Visible = false
                end
            end)
        end
    end)
    
    -- Hover effects
    button.MouseEnter:Connect(function()
        self:Tween(categoryFrame, {BackgroundTransparency = 0.1}, self.Animations.Fast)
    end)
    
    button.MouseLeave:Connect(function()
        self:Tween(categoryFrame, {BackgroundTransparency = 0.3}, self.Animations.Fast)
    end)
    
    -- =============================================================================
    -- ALL COMPONENT FUNCTIONS - BUTTON, TOGGLE, SLIDER, DROPDOWN, TEXTINPUT
    -- =============================================================================
    
    -- Add button function
    function category:AddButton(text, callback)
        local buttonFrame = Instance.new("Frame")
        buttonFrame.Name = text .. "Button"
        buttonFrame.Size = UDim2.new(1, 0, 0, 30)
        buttonFrame.BackgroundColor3 = PhantomUI.Theme.Background
        buttonFrame.BackgroundTransparency = 0.5
        buttonFrame.BorderSizePixel = 0
        buttonFrame.ZIndex = 4
        buttonFrame.Parent = self.ContentFrame
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 4)
        buttonCorner.Parent = buttonFrame
        
        local buttonText = Instance.new("TextLabel")
        buttonText.Size = UDim2.new(1, -20, 1, 0)
        buttonText.Position = UDim2.new(0, 20, 0, 0)
        buttonText.BackgroundTransparency = 1
        buttonText.Text = text
        buttonText.TextColor3 = PhantomUI.Theme.Text
        buttonText.TextSize = 14
        buttonText.Font = Enum.Font.SourceSans
        buttonText.TextXAlignment = Enum.TextXAlignment.Left
        buttonText.ZIndex = 5
        buttonText.Parent = buttonFrame
        
        local clickButton = Instance.new("TextButton")
        clickButton.Size = UDim2.new(1, 0, 1, 0)
        clickButton.BackgroundTransparency = 1
        clickButton.Text = ""
        clickButton.ZIndex = 6
        clickButton.Parent = buttonFrame
        
        -- Hover effects
        clickButton.MouseEnter:Connect(function()
            PhantomUI:Tween(buttonFrame, {BackgroundTransparency = 0.2}, PhantomUI.Animations.Fast)
        end)
        
        clickButton.MouseLeave:Connect(function()
            PhantomUI:Tween(buttonFrame, {BackgroundTransparency = 0.5}, PhantomUI.Animations.Fast)
        end)
        
        clickButton.MouseButton1Click:Connect(callback)
        
        table.insert(self.Items, buttonFrame)
        return buttonFrame
    end
    
    -- Add toggle function (ON/OFF switch)
    function category:AddToggle(text, default, callback)
        local toggleContainer = Instance.new("Frame")
        toggleContainer.Name = text .. "Toggle"
        toggleContainer.Size = UDim2.new(1, 0, 0, 35)
        toggleContainer.BackgroundColor3 = PhantomUI.Theme.Background
        toggleContainer.BackgroundTransparency = 0.3
        toggleContainer.BorderSizePixel = 0
        toggleContainer.ZIndex = 4
        toggleContainer.LayoutOrder = #self.Items + 1
        toggleContainer.Parent = self.ContentFrame
        
        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(0, 4)
        toggleCorner.Parent = toggleContainer
        
        local toggleText = Instance.new("TextLabel")
        toggleText.Size = UDim2.new(1, -60, 1, 0)
        toggleText.Position = UDim2.new(0, 15, 0, 0)
        toggleText.BackgroundTransparency = 1
        toggleText.Text = text
        toggleText.TextColor3 = PhantomUI.Theme.Text
        toggleText.TextSize = 14
        toggleText.Font = Enum.Font.SourceSans
        toggleText.TextXAlignment = Enum.TextXAlignment.Left
        toggleText.ZIndex = 5
        toggleText.Parent = toggleContainer
        
        -- Toggle switch background
        local toggleBg = Instance.new("Frame")
        toggleBg.Size = UDim2.new(0, 36, 0, 18)
        toggleBg.Position = UDim2.new(1, -45, 0.5, -9)
        toggleBg.BackgroundColor3 = default and PhantomUI.Theme.Primary or PhantomUI.Theme.Border
        toggleBg.BorderSizePixel = 0
        toggleBg.ZIndex = 5
        toggleBg.Parent = toggleContainer
        
        local bgCorner = Instance.new("UICorner")
        bgCorner.CornerRadius = UDim.new(0, 9)
        bgCorner.Parent = toggleBg
        
        -- Toggle circle
        local toggleCircle = Instance.new("Frame")
        toggleCircle.Size = UDim2.new(0, 14, 0, 14)
        toggleCircle.Position = UDim2.new(default and 1 or 0, default and -16 or 2, 0.5, -7)
        toggleCircle.BackgroundColor3 = PhantomUI.Theme.Text
        toggleCircle.BorderSizePixel = 0
        toggleCircle.ZIndex = 6
        toggleCircle.Parent = toggleBg
        
        local circleCorner = Instance.new("UICorner")
        circleCorner.CornerRadius = UDim.new(0, 7)
        circleCorner.Parent = toggleCircle
        
        -- Toggle button
        local toggleButton = Instance.new("TextButton")
        toggleButton.Size = UDim2.new(1, 0, 1, 0)
        toggleButton.BackgroundTransparency = 1
        toggleButton.Text = ""
        toggleButton.ZIndex = 7
        toggleButton.Parent = toggleContainer
        
        -- Toggle state
        local toggle = {
            Value = default or false,
            Set = function(self, value)
                self.Value = value
                updateToggle()
            end
        }
        
        local function updateToggle()
            PhantomUI:Tween(toggleBg, {
                BackgroundColor3 = toggle.Value and PhantomUI.Theme.Primary or PhantomUI.Theme.Border
            }, PhantomUI.Animations.Fast)
            
            PhantomUI:Tween(toggleCircle, {
                Position = UDim2.new(toggle.Value and 1 or 0, toggle.Value and -16 or 2, 0.5, -7)
            }, PhantomUI.Animations.Fast)
            
            callback(toggle.Value)
        end
        
        -- Click handler
        toggleButton.MouseButton1Click:Connect(function()
            toggle.Value = not toggle.Value
            updateToggle()
        end)
        
        -- Hover effects
        toggleButton.MouseEnter:Connect(function()
            PhantomUI:Tween(toggleContainer, {BackgroundTransparency = 0.1}, PhantomUI.Animations.Fast)
        end)
        
        toggleButton.MouseLeave:Connect(function()
            PhantomUI:Tween(toggleContainer, {BackgroundTransparency = 0.3}, PhantomUI.Animations.Fast)
        end)
        
        table.insert(self.Items, toggleContainer)
        return toggle
    end

    -- Add dropdown function (select from list)
    function category:AddDropdown(text, options, callback)
        local dropdownContainer = Instance.new("Frame")
        dropdownContainer.Name = text .. "Dropdown"
        dropdownContainer.Size = UDim2.new(1, 0, 0, 35)
        dropdownContainer.BackgroundColor3 = PhantomUI.Theme.Background
        dropdownContainer.BackgroundTransparency = 0.3
        dropdownContainer.BorderSizePixel = 0
        dropdownContainer.ZIndex = 4
        dropdownContainer.LayoutOrder = #self.Items + 1
        dropdownContainer.Parent = self.ContentFrame
        
        local dropdownCorner = Instance.new("UICorner")
        dropdownCorner.CornerRadius = UDim.new(0, 4)
        dropdownCorner.Parent = dropdownContainer
        
        local dropdownText = Instance.new("TextLabel")
        dropdownText.Size = UDim2.new(0.6, 0, 1, 0)
        dropdownText.Position = UDim2.new(0, 15, 0, 0)
        dropdownText.BackgroundTransparency = 1
        dropdownText.Text = text
        dropdownText.TextColor3 = PhantomUI.Theme.Text
        dropdownText.TextSize = 14
        dropdownText.Font = Enum.Font.SourceSans
        dropdownText.TextXAlignment = Enum.TextXAlignment.Left
        dropdownText.ZIndex = 5
        dropdownText.Parent = dropdownContainer
        
        local selectedText = Instance.new("TextLabel")
        selectedText.Size = UDim2.new(0.35, -25, 1, 0)
        selectedText.Position = UDim2.new(0.65, 0, 0, 0)
        selectedText.BackgroundTransparency = 1
        selectedText.Text = options[1] or "None"
        selectedText.TextColor3 = PhantomUI.Theme.Primary
        selectedText.TextSize = 12
        selectedText.Font = Enum.Font.SourceSans
        selectedText.TextXAlignment = Enum.TextXAlignment.Right
        selectedText.ZIndex = 5
        selectedText.Parent = dropdownContainer
        
        local dropdownButton = Instance.new("TextButton")
        dropdownButton.Size = UDim2.new(1, 0, 1, 0)
        dropdownButton.BackgroundTransparency = 1
        dropdownButton.Text = ""
        dropdownButton.ZIndex = 6
        dropdownButton.Parent = dropdownContainer
        
        local dropdown = {
            Value = options[1] or "",
            Set = function(self, value)
                self.Value = value
                selectedText.Text = value
                callback(value)
            end
        }
        
        -- Simple cycling through options (click to cycle)
        local currentIndex = 1
        dropdownButton.MouseButton1Click:Connect(function()
            currentIndex = currentIndex + 1
            if currentIndex > #options then
                currentIndex = 1
            end
            dropdown:Set(options[currentIndex])
        end)
        
        -- Hover effects
        dropdownButton.MouseEnter:Connect(function()
            PhantomUI:Tween(dropdownContainer, {BackgroundTransparency = 0.1}, PhantomUI.Animations.Fast)
        end)
        
        dropdownButton.MouseLeave:Connect(function()
            PhantomUI:Tween(dropdownContainer, {BackgroundTransparency = 0.3}, PhantomUI.Animations.Fast)
        end)
        
        table.insert(self.Items, dropdownContainer)
        return dropdown
    end
    
    table.insert(self.State.Categories, category)
    return category
end

-- Toggle window
function PhantomUI:Toggle()
    if not self.MainFrame then return end
    
    self.State.WindowOpen = not self.State.WindowOpen
    self.MainFrame.Visible = self.State.WindowOpen
    
    if self.State.WindowOpen then
        self:Notify("UI", "Window shown", 1, "Success")
    else
        self:Notify("UI", "Window hidden", 1, "Info")
    end
end

-- Initialize keybinds
function PhantomUI:InitializeKeybinds()
    UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        
        if input.KeyCode == Enum.KeyCode.Insert then
            self:Toggle()
        end
    end)
end

-- =============================================================================
-- INITIALIZE AND CREATE THE UI
-- =============================================================================

-- Create the UI instance
local UI = PhantomUI:Init({
    Title = "Phantom.exe",
    Version = "2.0.0"
})

-- Show initial notification
UI:Notify("Phantom Enhanced", "UI loaded successfully! Press INSERT to toggle.", 5, "Success")

-- =============================================================================
-- CREATE YOUR CATEGORIES
-- =============================================================================

local PlayerCategory = UI:AddCategory("Player")
local AimbotCategory = UI:AddCategory("Aimbot")
local VisualsCategory = UI:AddCategory("Visuals")
local WeaponsCategory = UI:AddCategory("Weapons")
local CombateCategory = UI:AddCategory("Combat")
local VehiclesCategory = UI:AddCategory("Vehicles")
local AutoFarmCategory = UI:AddCategory("Auto Farm") 
local SettingsCategory = UI:AddCategory("Settings")
-- =============================================================================
-- AUTO FARM SCRIPTS - UPDATED QUICK-11 SCRIPT
-- =============================================================================

-- ===== UPDATED QUICK-11 AUTO FARM SCRIPT =====
do -- Wrap in do-end block to keep variables local
    local player = LocalPlayer
    
    -- Consolidated state management
    local JobAutoFarm_State = {
        running = false,
        connections = {},
        currentTween = nil,
        location = Vector3.new(134.032, 255.467, 208.614)
    }

    -- Function to get current character references
    local function getCharacterReferences()
        local char = player.Character
        if not char then return nil, nil, nil end
        
        return char, char:FindFirstChild("Humanoid"), char:FindFirstChild("HumanoidRootPart")
    end

    -- Function to wait for character to load
    local function waitForCharacter()
        local char = player.Character or player.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid", 10)
        local root = char:WaitForChild("HumanoidRootPart", 10)
        
        if not hum or not root then
            warn("Failed to get character references")
            return nil, nil, nil
        end
        
        return char, hum, root
    end

    -- Function to clean up all connections and tweens
    local function cleanup()
        print("Cleaning up auto farm script...")
        
        -- Cancel any active tween
        if JobAutoFarm_State.currentTween then
            JobAutoFarm_State.currentTween:Cancel()
            JobAutoFarm_State.currentTween = nil
        end
        
        -- Disconnect all connections
        for _, connection in pairs(JobAutoFarm_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        JobAutoFarm_State.connections = {}
        
        print("Auto farm script stopped and cleaned up.")
    end

    -- Function to handle character death
    local function onCharacterDied()
        print("Character died. Waiting for respawn...")
        
        -- Don't stop the script, just wait for respawn
        if JobAutoFarm_State.running then
            print("Waiting for character to respawn...")
            local char, hum, root = waitForCharacter()
            
            if char and hum and root and JobAutoFarm_State.running then
                print("Character respawned! Continuing auto farm...")
                -- The main loop will continue automatically
            end
        end
    end

    -- Function to tween to a position with fixed Y at 255
    local function tweenToPosition(position)
        if not JobAutoFarm_State.running then return false end
        
        local char, hum, root = getCharacterReferences()
        if not root then
            print("No character found, waiting for respawn...")
            char, hum, root = waitForCharacter()
            if not root or not JobAutoFarm_State.running then return false end
        end
        
        -- Keep Y fixed at 255
        local fixedPosition = Vector3.new(position.X, 255, position.Z)
        local distance = (root.Position - fixedPosition).Magnitude
        
        JobAutoFarm_State.currentTween = TweenService:Create(
            root, 
            TweenInfo.new(distance / 17, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
            {CFrame = CFrame.new(fixedPosition)}
        )
        JobAutoFarm_State.currentTween:Play()
        
        -- Create a connection to check if script is still running
        local completed = false
        local connection = JobAutoFarm_State.currentTween.Completed:Connect(function()
            completed = true
        end)
        
        -- Wait for tween to complete or script to stop
        local startTime = tick()
        local timeout = distance / 17 + 5 -- Add 5 seconds buffer
        
        while not completed and JobAutoFarm_State.running and (tick() - startTime) < timeout do
            wait(0.1)
        end
        
        connection:Disconnect()
        
        if not JobAutoFarm_State.running then
            if JobAutoFarm_State.currentTween then
                JobAutoFarm_State.currentTween:Cancel()
            end
            return false
        end
        
        JobAutoFarm_State.currentTween = nil
        return true
    end

    -- Function to follow path to a target position
    local function followPathTo(targetPosition)
        if not JobAutoFarm_State.running then return false end
        
        local char, hum, root = getCharacterReferences()
        if not root then
            print("No character found, waiting for respawn...")
            char, hum, root = waitForCharacter()
            if not root or not JobAutoFarm_State.running then return false end
        end
        
        -- First set Y position to 255
        root.CFrame = CFrame.new(root.Position.X, 255.3, root.Position.Z)
        wait(0.1)
        
        if not JobAutoFarm_State.running then return false end
        
        -- Create and compute path
        local path = game:GetService("PathfindingService"):CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true
        })
        
        local success, errorMessage = pcall(function()
            path:ComputeAsync(root.Position, targetPosition)
        end)
        
        if success and path.Status == Enum.PathStatus.Success and JobAutoFarm_State.running then
            for i, waypoint in ipairs(path:GetWaypoints()) do
                if not JobAutoFarm_State.running then return false end
                
                -- Move to each waypoint with fixed Y
                if not tweenToPosition(waypoint.Position) then return false end
                
                -- If we've reached the final waypoint
                if i == #path:GetWaypoints() and JobAutoFarm_State.running then
                    print("Reached destination!")
                end
            end
        else
            if not JobAutoFarm_State.running then return false end
            
            warn("Path computation failed:", errorMessage)
            
            -- If path computation fails, just tween directly to target with fixed Y
            print("Using direct tween to target instead...")
            if not tweenToPosition(targetPosition) then return false end
        end
        
        if not JobAutoFarm_State.running then return false end
        
        -- Make sure we're at the exact target position with Y=255
        local char, hum, root = getCharacterReferences()
        if root then
            root.CFrame = CFrame.new(targetPosition.X, 255, targetPosition.Z)
        end
        return true
    end

    -- Function to trigger the job UI initially
    local function applyForJob()
        if not JobAutoFarm_State.running then return false end
        
        local char, hum, root = getCharacterReferences()
        if not root then
            print("No character found, waiting for respawn...")
            char, hum, root = waitForCharacter()
            if not root or not JobAutoFarm_State.running then return false end
        end
        
        print("Triggering job application UI...")
        local touchPart = workspace.Map.Tiles.GasStationTile.Quick11.Interior.Quick11Beacon.TouchPart
        firetouchinterest(root, touchPart, 0)
        wait(0.1)
        firetouchinterest(root, touchPart, 1)
        print("Job UI triggered! Please click the Apply button manually.")
        
        -- Wait for you to manually click Apply
        print("Waiting for you to click the Apply button...")
        local waitStart = tick()
        while JobAutoFarm_State.running and (tick() - waitStart) < 8 do
            wait(0.1)
        end
        
        if not JobAutoFarm_State.running then return false end
        
        print("Continuing with shelf stocking work...")
        return true
    end

    -- Function to pick up a box
    local function pickUpBox()
        if not JobAutoFarm_State.running then return false end
        
        print("Now firing proximity prompt for shelf stocking box...")
        
        -- Fire the proximity prompt
        fireproximityprompt(workspace.Map.Tiles.GasStationTile.Quick11.Interior.ShelfStockingJob.NormalBox.ProximityPrompt)
        print("Fired proximity prompt for the shelf stocking box!")
        
        -- Wait a moment for the box to be picked up
        local waitStart = tick()
        while JobAutoFarm_State.running and (tick() - waitStart) < 2 do
            wait(0.1)
        end
        
        return JobAutoFarm_State.running
    end

    -- Function to move to beacon and wait for delivery
    local function moveToBeaconAndDeliver()
        if not JobAutoFarm_State.running then return false end
        
        print("Searching for beacon.base...")
        
        -- Find the beacon base
        local success, beaconBase = pcall(function()
            return workspace.Beacon.Base
        end)
        
        if not JobAutoFarm_State.running then return false end
        
        if not success or not beaconBase then
            print("Beacon.Base not found! Box may have already been delivered or there's an issue.")
            return false
        end
        
        print("Found Beacon.Base, moving to it now...")
        
        -- Move to the beacon position
        if not followPathTo(beaconBase.Position) then return false end
        
        print("Reached the beacon!")
        
        if not JobAutoFarm_State.running then return false end
        
        -- Wait for delivery to complete - beacon should disappear
        local waitStart = tick()
        while JobAutoFarm_State.running and (tick() - waitStart) < 10 do
            -- Check if beacon still exists
            local beaconStillExists = pcall(function()
                return workspace.Beacon.Base ~= nil
            end)
            
            if not beaconStillExists then
                print("Box successfully delivered! Beacon no longer exists.")
                return true
            end
            
            wait(0.5)
        end
        
        return JobAutoFarm_State.running
    end

    -- Main farming function
    local function startAutoFarm()
        while JobAutoFarm_State.running do
            -- Wait for character if needed
            local char, hum, root = getCharacterReferences()
            if not char or not hum or not root then
                print("Waiting for character...")
                char, hum, root = waitForCharacter()
                if not char or not hum or not root or not JobAutoFarm_State.running then
                    break
                end
            end
            
            -- Set up death detection for current character
            table.insert(JobAutoFarm_State.connections, hum.Died:Connect(onCharacterDied))
            
            -- First apply for the job
            if not followPathTo(JobAutoFarm_State.location) then 
                if JobAutoFarm_State.running then
                    print("Failed to reach job location, retrying...")
                    wait(2)
                    continue
                else
                    break
                end
            end
            
            if not applyForJob() then 
                if JobAutoFarm_State.running then
                    print("Failed to apply for job, retrying...")
                    wait(2)
                    continue
                else
                    break
                end
            end
            
            -- Now start the box stocking loop
            local boxCount = 0
            
            while JobAutoFarm_State.running do
                -- Check if character still exists
                local currentChar, currentHum, currentRoot = getCharacterReferences()
                if not currentChar or not currentHum or not currentRoot then
                    print("Character lost, waiting for respawn...")
                    break -- Break inner loop to restart with new character
                end
                
                print("--- Starting box #" .. (boxCount + 1) .. " ---")
                
                -- Go to job location to pick up a box
                print("Moving to box pickup location...")
                if not followPathTo(JobAutoFarm_State.location) then 
                    if JobAutoFarm_State.running then
                        print("Failed to move to pickup location, retrying...")
                        wait(2)
                        continue
                    else
                        break
                    end
                end
                
                -- Pick up a box
                if pickUpBox() then
                    boxCount = boxCount + 1
                    print("Box #" .. boxCount .. " picked up successfully")
                    
                    -- Move to beacon and deliver
                    if moveToBeaconAndDeliver() then
                        print("Box #" .. boxCount .. " delivered successfully!")
                    else
                        if not JobAutoFarm_State.running then break end
                        print("Issue with delivery for box #" .. boxCount .. ", continuing anyway...")
                    end
                    
                    -- Short wait before getting the next box
                    if not JobAutoFarm_State.running then break end
                    wait(1)
                else
                    if not JobAutoFarm_State.running then break end
                    print("Failed to pick up box, retrying...")
                    wait(2)
                end
                
                if not JobAutoFarm_State.running then break end
                print("--- Completed cycle #" .. boxCount .. " ---")
            end
            
            -- If we get here and script is still running, character probably died
            if JobAutoFarm_State.running then
                print("Restarting due to character issue...")
                wait(1) -- Short wait before restarting
            end
        end
        
        print("Auto farm execution terminated.")
        cleanup()
    end

    -- Add the Quick-11 Auto Farm toggle to the UI
    local Quick11Toggle = AutoFarmCategory:AddToggle("Quick-11 Auto Farm", false, function(Value)
        JobAutoFarm_State.running = Value
        
        if JobAutoFarm_State.running then
            UI:Notify("Auto Farm", "Quick-11 farm started!", 3, "Success")
            print("Quick-11 auto farm started!")
            -- Run the farm in a separate thread so it doesn't block
            spawn(function()
                startAutoFarm()
            end)
        else
            UI:Notify("Auto Farm", "Quick-11 farm stopped!", 2, "Info")
            print("Quick-11 auto farm stopped!")
            cleanup()
        end
    end)
end

-- ===== STEAKHOUSE AUTO FARM SCRIPT =====
do -- Wrap in do-end block to keep variables local
    -- Optimized Steakhouse Auto Farm Script
    -- Consolidated state management for maximum efficiency

    -- Consolidated state management for steakhouse
    local SteakhouseFarm_State = {
        enabled = false,
        autoMovement = false,
        steaksCookedCounter = 0,
        isRunning = false,
        connections = {},
        config = {
            tweenSpeed = 28,
            waitBetweenActions = 0.0,
            steakhouseBeacon = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.SteakHouseBeacon.TouchPart,
            fridgeArea = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge.Area,
            fridge = workspace.Map.Tiles.ShoppingTile.SteakHouse.Interior.Fridge
        }
    }

    -- Initialize player references and Net module
    local player = LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")

    -- Net module detection (exact from working script)
    local Net = nil
    if _G.NetBypass and _G.NetBypass.Net then
        Net = _G.NetBypass.Net
    elseif _G.Net then
        Net = _G.Net
    else
        local success, netModule = pcall(function()
            return require(game.ReplicatedStorage.Modules.Core.Net)
        end)
        if success and netModule then
            Net = netModule
        end
    end

    -- Precise timing function (exact from working script)
    local function isPerfectMoment(barAmount, cookedPerfectly)
        local currentPosition = barAmount.Size.X.Scale
        local perfectStart = cookedPerfectly.Position.X.Scale
        local perfectEnd = perfectStart + cookedPerfectly.Size.X.Scale
        
        return currentPosition >= (perfectStart + 0.01) and 
               currentPosition <= (perfectEnd - 0.01)
    end

    -- Enhanced Auto Cook Function with Stealth Net Bypass (exact from working script)
    local function autoCookSteak()
        -- Find current grill
        local currentGrill = nil
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("Model") and obj:FindFirstChild("GrillArea") then
                currentGrill = obj
                break
            end
        end
        
        -- Find progress bar frame
        local progressBarFrame = nil
        for _, gui in pairs(player.PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") then
                local found = gui:FindFirstChild("ProgressBarFrame")
                if found and found.Visible then
                    progressBarFrame = found
                    break
                end
            end
        end
        
        if not progressBarFrame or not currentGrill then 
            return false 
        end
        
        local mainFrame = progressBarFrame:FindFirstChild("MainFrame")
        local inputFrame = progressBarFrame:FindFirstChild("InputFrame")
        
        if not mainFrame or not inputFrame then 
            return false 
        end
        
        local barAmount = mainFrame:FindFirstChild("BarAmount")
        local cookedPerfectly = mainFrame:FindFirstChild("CookedPerfectly")
        
        if not barAmount or not cookedPerfectly then 
            return false 
        end
        
        -- Check if in perfect moment
        if isPerfectMoment(barAmount, cookedPerfectly) then
            -- STEALTH METHOD: Use Net bypass with proper filtering check
            if Net and _G.NetBypass then
                local stealthEvents = {"cooking_complete", "finish_cooking", "job_task_complete"}
                
                for _, eventName in pairs(stealthEvents) do
                    if _G.NetBypass.allowEvent then
                        _G.NetBypass.allowEvent(eventName)
                    end
                end
                
                pcall(function()
                    wait(math.random(50, 150) / 1000)
                    Net.send("cooking_complete", {
                        perfect = true,
                        grill = currentGrill,
                        timestamp = tick()
                    })
                    
                    wait(math.random(30, 80) / 1000)
                    Net.send("job_task_complete", "steakhouse_cook", {
                        result = "perfect",
                        completion_time = tick()
                    })
                end)
            end
            
            -- Complete the visual/client-side
            wait(math.random(100, 200) / 1000)
            
            local completionMethods = {
                function()
                    local cookModule = require(game.ReplicatedStorage.Modules.Game.Cooking)
                    if cookModule and cookModule.force_complete then
                        pcall(function()
                            cookModule.force_complete(currentGrill)
                        end)
                    end
                end,
                function()
                    local finishBar = inputFrame:FindFirstChild("FinishBar")
                    if finishBar then
                        for _, connection in pairs(getconnections(finishBar.MouseButton1Click)) do
                            pcall(function() 
                                connection:Fire() 
                            end)
                        end
                    end
                end
            }
            
            for i, method in ipairs(completionMethods) do
                pcall(method)
            end
            
            SteakhouseFarm_State.steaksCookedCounter = SteakhouseFarm_State.steaksCookedCounter + 1
            wait(math.random(500, 1000) / 1000)
            return true
        end
        
        return false
    end

    -- Helper function to wait for character respawn
    local function waitForRespawn()
        if not character or not character:FindFirstChild("Humanoid") then
            character = player.CharacterAdded:Wait()
            humanoid = character:WaitForChild("Humanoid")
            hrp = character:WaitForChild("HumanoidRootPart")
        end
    end

    -- Movement function
    local function moveToPosition(targetPosition)
        waitForRespawn()
        
        local path = game:GetService("PathfindingService"):CreatePath({
            AgentCanJump = true,
            AgentHeight = 5,
            AgentRadius = 2,
            WaypointSpacing = 4
        })
        
        local success, errorMessage = pcall(function()
            local fixedYPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
            path:ComputeAsync(hrp.Position, fixedYPosition)
        end)
        
        if success and path.Status == Enum.PathStatus.Success then
            local waypoints = path:GetWaypoints()
            
            for i, waypoint in ipairs(waypoints) do
                if not SteakhouseFarm_State.autoMovement then return false end
                
                waitForRespawn()
                
                local waypointPosition = Vector3.new(waypoint.Position.X, 255, waypoint.Position.Z)
                
                local tweenInfo = TweenInfo.new(
                    (Vector3.new(hrp.Position.X, 0, hrp.Position.Z) - 
                    Vector3.new(waypointPosition.X, 0, waypointPosition.Z)).Magnitude / SteakhouseFarm_State.config.tweenSpeed,
                    Enum.EasingStyle.Linear
                )
                
                local tween = game:GetService("TweenService"):Create(hrp, tweenInfo, {
                    CFrame = CFrame.new(waypointPosition)
                })
                
                tween:Play()
                
                local connection
                connection = game:GetService("RunService").Heartbeat:Connect(function()
                    if not SteakhouseFarm_State.autoMovement then
                        tween:Cancel()
                        connection:Disconnect()
                    end
                end)
                
                tween.Completed:Wait()
                connection:Disconnect()
                
                if not SteakhouseFarm_State.autoMovement then return false end
                wait(0.1)
            end
            return true
        else
            warn("Path computation failed:", errorMessage)
            local fixedPosition = Vector3.new(targetPosition.X, 255, targetPosition.Z)
            humanoid:MoveTo(fixedPosition)
            
            local reachedDestination = false
            local startTime = tick()
            while not reachedDestination and SteakhouseFarm_State.autoMovement and (tick() - startTime) < 10 do
                if (hrp.Position - fixedPosition).Magnitude < 5 then
                    reachedDestination = true
                end
                wait(0.1)
            end
            
            return reachedDestination and SteakhouseFarm_State.autoMovement
        end
    end

    -- Fridge interaction function
    local function interactWithFridge()
        waitForRespawn()
        
        local fridgeAreaPosition = SteakhouseFarm_State.config.fridgeArea.Position
        local targetPosition = Vector3.new(fridgeAreaPosition.X, 255, fridgeAreaPosition.Z)
        local moveSuccess = moveToPosition(targetPosition)
        
        if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
        
        wait(1)
        if not SteakhouseFarm_State.autoMovement then return false end
        
        hrp.CFrame = CFrame.new(hrp.Position, 
            Vector3.new(fridgeAreaPosition.X, hrp.Position.Y, fridgeAreaPosition.Z))
        
        wait(1.5)
        if not SteakhouseFarm_State.autoMovement then return false end
        
        local maxAttempts = 5
        for attempt = 1, maxAttempts do
            if not SteakhouseFarm_State.autoMovement then return false end
            
            local proximityPrompt = nil
            
            for i, child in pairs(SteakhouseFarm_State.config.fridge:GetChildren()) do
                if i == 4 and child:FindFirstChild("Attachment") then
                    proximityPrompt = child.Attachment:FindFirstChild("ProximityPrompt")
                    if proximityPrompt then break end
                end
            end
            
            if not proximityPrompt then
                for _, child in pairs(SteakhouseFarm_State.config.fridge:GetDescendants()) do
                    if child:IsA("ProximityPrompt") then
                        proximityPrompt = child
                        break
                    end
                end
            end
            
            if proximityPrompt then
                local promptParent = proximityPrompt.Parent
                if promptParent and promptParent:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(promptParent.Position + Vector3.new(0, 2, 0))
                elseif promptParent and promptParent:IsA("Attachment") and promptParent.Parent:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(promptParent.Parent.Position + Vector3.new(0, 2, 0))
                end
                
                if not SteakhouseFarm_State.autoMovement then return false end
                
                fireproximityprompt(proximityPrompt)
                
                local waitTime = 3
                local startTime = tick()
                while SteakhouseFarm_State.autoMovement and (tick() - startTime) < waitTime do
                    wait(0.1)
                end
                
                if not SteakhouseFarm_State.autoMovement then return false end
                
                return true
            end
            
            if attempt < maxAttempts and SteakhouseFarm_State.autoMovement then
                local offsetPosition = targetPosition + Vector3.new(math.random(-1, 1), 0, math.random(-1, 1))
                hrp.CFrame = CFrame.new(offsetPosition)
                if not SteakhouseFarm_State.autoMovement then return false end
                wait(1)
            end
        end
        
        return false
    end

    -- Beacon finding and movement function
    local function findAndMoveToBeacon()
        waitForRespawn()
        
        local startTime = tick()
        local timeout = 10
        local beaconFound = false
        local targetBeacon = nil
        
        while not beaconFound and SteakhouseFarm_State.autoMovement and (tick() - startTime) < timeout do
            if workspace:FindFirstChild("Beacon") and workspace.Beacon:FindFirstChild("Base") then
                targetBeacon = workspace.Beacon.Base
                beaconFound = true
                break
            end
            wait(0.5)
        end
        
        if not beaconFound or not targetBeacon then
            return false
        end
        
        if not SteakhouseFarm_State.autoMovement then return false end
        
        local beaconPosition = targetBeacon.Position
        
        local moveSuccess = moveToPosition(beaconPosition)
        
        if not moveSuccess or not SteakhouseFarm_State.autoMovement then return false end
        
        return true
    end

    -- Main auto farm cleanup function
    local function steakhouseCleanup()
        SteakhouseFarm_State.enabled = false
        SteakhouseFarm_State.autoMovement = false
        
        for _, connection in pairs(SteakhouseFarm_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        SteakhouseFarm_State.connections = {}
    end

    -- Add the Steakhouse Auto Farm toggle to the UI
    local SteakhouseToggle = AutoFarmCategory:AddToggle("Steakhouse Auto Farm", false, function(Value)
        SteakhouseFarm_State.enabled = Value
        SteakhouseFarm_State.autoMovement = Value
        
        if Value then
            UI:Notify("Auto Farm", "Steakhouse farm started!", 3, "Success")
            print("Steakhouse auto farm started!")
            
            if not SteakhouseFarm_State.isRunning then
                SteakhouseFarm_State.isRunning = true
                
                -- Movement loop
                spawn(function()
                    while SteakhouseFarm_State.isRunning do
                        if SteakhouseFarm_State.autoMovement then
                            pcall(function()
                                local fridgeSuccess = interactWithFridge()
                                
                                if not fridgeSuccess or not SteakhouseFarm_State.autoMovement then
                                    wait(3)
                                    return
                                end
                                
                                if not SteakhouseFarm_State.autoMovement then return end
                                wait(SteakhouseFarm_State.config.waitBetweenActions)
                                
                                local beaconSuccess = findAndMoveToBeacon()
                                
                                if not beaconSuccess or not SteakhouseFarm_State.autoMovement then
                                    wait(3)
                                    return
                                end
                                
                                if not SteakhouseFarm_State.autoMovement then return end
                                
                                local cookingStart = tick()
                                local cookingTimeout = 20
                                local cookingCompleted = false
                                
                                while SteakhouseFarm_State.autoMovement and (tick() - cookingStart) < cookingTimeout do
                                    local progressBarFrame = nil
                                    for _, gui in pairs(player.PlayerGui:GetChildren()) do
                                        if gui:IsA("ScreenGui") then
                                            local found = gui:FindFirstChild("ProgressBarFrame")
                                            if found and found.Visible then
                                                progressBarFrame = found
                                                break
                                            end
                                        end
                                    end
                                    
                                    if progressBarFrame then
                                        while progressBarFrame and progressBarFrame.Visible and SteakhouseFarm_State.autoMovement do
                                            wait(0.1)
                                        end
                                        cookingCompleted = true
                                        break
                                    end
                                    
                                    wait(0.5)
                                end
                                
                                if cookingCompleted then
                                    wait(2)
                                else
                                    wait(5)
                                end
                            end)
                        end
                        
                        wait(1)
                    end
                end)
                
                -- Auto-cook loop (exact from working script)
                spawn(function()
                    while SteakhouseFarm_State.isRunning do
                        wait(0.01)
                        
                        if SteakhouseFarm_State.enabled then
                            local success, result = pcall(autoCookSteak)
                            if not success then
                                warn("Error in auto cooking: " .. tostring(result))
                            end
                        end
                    end
                end)
            end
        else
            UI:Notify("Auto Farm", "Steakhouse farm stopped!", 2, "Info")
            print("Steakhouse auto farm stopped!")
            steakhouseCleanup()
        end
    end)
end

-- ===== BURGER PLACE JANITOR AUTO FARM SCRIPT =====
do -- Wrap in do-end block to keep variables local
    -- Consolidated state management for janitor
    local JanitorFarm_State = {
        running = false,
        connections = {},
        currentTween = nil,
        yPositionMaintenance = false,
        targetPart = workspace.BurgePlaceBeacon.TouchPart,
        config = {
            fixedYPosition = 255.4,
            tweenSpeed = 0.3,
            waitTimePerPuddle = 5,
            loopWaitTime = 0
        }
    }

    -- Function to get current character references for janitor
    local function getJanitorCharacterReferences()
        local char = LocalPlayer.Character
        if not char then return nil, nil, nil end
        
        return char, char:FindFirstChild("Humanoid"), char:FindFirstChild("HumanoidRootPart")
    end

    -- Function to wait for character to load for janitor
    local function waitForJanitorCharacter()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local hum = char:WaitForChild("Humanoid", 10)
        local root = char:WaitForChild("HumanoidRootPart", 10)
        
        if not hum or not root then
            warn("Failed to get janitor character references")
            return nil, nil, nil
        end
        
        return char, hum, root
    end

    -- Function to clean up janitor connections and tweens
    local function janitorCleanup()
        print("Cleaning up janitor farm script...")
        
        -- Cancel any active tween
        if JanitorFarm_State.currentTween then
            JanitorFarm_State.currentTween:Cancel()
            JanitorFarm_State.currentTween = nil
        end
        
        -- Stop Y position maintenance
        JanitorFarm_State.yPositionMaintenance = false
        
        -- Disconnect all connections
        for _, connection in pairs(JanitorFarm_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        JanitorFarm_State.connections = {}
        
        print("Janitor farm script stopped and cleaned up.")
    end

    -- Function to handle character death for janitor
    local function onJanitorCharacterDied()
        print("Character died. Waiting for respawn...")
        
        -- Don't stop the script, just wait for respawn
        if JanitorFarm_State.running then
            print("Waiting for character to respawn...")
            local char, hum, root = waitForJanitorCharacter()
            
            if char and hum and root and JanitorFarm_State.running then
                print("Character respawned! Continuing janitor farm...")
                -- The main loop will continue automatically
            end
        end
    end

    -- Function to find path and tween to location for janitor
    local function moveToJanitorLocation(target)
        if not JanitorFarm_State.running then return false end
        
        local char, hum, root = getJanitorCharacterReferences()
        if not root then
            print("No character found, waiting for respawn...")
            char, hum, root = waitForJanitorCharacter()
            if not root or not JanitorFarm_State.running then return false end
        end
        
        -- Create path
        local path = game:GetService("PathfindingService"):CreatePath({
            AgentRadius = 2,
            AgentHeight = 5,
            AgentCanJump = true
        })
        
        -- Get target position
        local targetPosition = typeof(target) == "Vector3" and target or target.Position
        
        -- Compute the path
        local success, errorMessage = pcall(function()
            path:ComputeAsync(root.Position, targetPosition)
        end)
        
        if not success then
            print("Failed to compute path:", errorMessage)
            return false
        end
        
        -- Move through each waypoint using tweens
        for i, waypoint in ipairs(path:GetWaypoints()) do
            if not JanitorFarm_State.running then return false end
            
            -- Check character references again
            local currentChar, currentHum, currentRoot = getJanitorCharacterReferences()
            if not currentRoot then
                print("Character lost during movement, waiting for respawn...")
                currentChar, currentHum, currentRoot = waitForJanitorCharacter()
                if not currentRoot or not JanitorFarm_State.running then return false end
            end
            
            -- Keep y-position fixed at specified height
            JanitorFarm_State.currentTween = TweenService:Create(
                currentRoot,
                TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
                {CFrame = CFrame.new(Vector3.new(waypoint.Position.X, JanitorFarm_State.config.fixedYPosition, waypoint.Position.Z))}
            )
            JanitorFarm_State.currentTween:Play()
            
            -- Wait for completion or script stop
            local completed = false
            local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
                completed = true
            end)
            
            while not completed and JanitorFarm_State.running do
                wait(0.1)
            end
            
            connection:Disconnect()
            
            if not JanitorFarm_State.running then
                if JanitorFarm_State.currentTween then
                    JanitorFarm_State.currentTween:Cancel()
                end
                return false
            end
        end
        
        if not JanitorFarm_State.running then return false end
        
        -- Get character references for final movement
        local char, hum, root = getJanitorCharacterReferences()
        if not root then
            print("Character lost during final movement, waiting for respawn...")
            char, hum, root = waitForJanitorCharacter()
            if not root or not JanitorFarm_State.running then return false end
        end
        
        -- Final tween to exact position (but still keeping y fixed)
        JanitorFarm_State.currentTween = TweenService:Create(
            root,
            TweenInfo.new(JanitorFarm_State.config.tweenSpeed, Enum.EasingStyle.Linear),
            {CFrame = CFrame.new(Vector3.new(targetPosition.X, JanitorFarm_State.config.fixedYPosition, targetPosition.Z))}
        )
        JanitorFarm_State.currentTween:Play()
        
        local completed = false
        local connection = JanitorFarm_State.currentTween.Completed:Connect(function()
            completed = true
        end)
        
        while not completed and JanitorFarm_State.running do
            wait(0.1)
        end
        
        connection:Disconnect()
        
        if not JanitorFarm_State.running then
            if JanitorFarm_State.currentTween then
                JanitorFarm_State.currentTween:Cancel()
            end
            return false
        end
        
        JanitorFarm_State.currentTween = nil
        print("Reached destination")
        return true
    end

    -- Function to fire touch transmitters for janitor
    local function fireJanitorTouch()
        if not JanitorFarm_State.running then return false end
        
        local char, hum, root = getJanitorCharacterReferences()
        if not root then
            print("No character found for touch interaction, waiting for respawn...")
            char, hum, root = waitForJanitorCharacter()
            if not root or not JanitorFarm_State.running then return false end
        end
        
        local touchInterest = JanitorFarm_State.targetPart:FindFirstChild("TouchInterest")
        if touchInterest then
            firetouchinterest(root, JanitorFarm_State.targetPart, 0) -- Begin touch
            wait(0.1)
            firetouchinterest(root, JanitorFarm_State.targetPart, 1) -- End touch
            print("Fired touch event")
            return true
        else
            print("TouchInterest not found")
            return false
        end
    end

    -- Function to click the green Apply button for janitor
    local function clickJanitorApplyButton()
        if not JanitorFarm_State.running then return false end
        
        print("Looking for Apply button...")
        wait(1) -- Wait for dialog to appear
        
        if not JanitorFarm_State.running then return false end
        
        -- Find all TextLabels with "Apply to Janitor job" text
        for _, gui in pairs(LocalPlayer.PlayerGui:GetChildren()) do
            if gui:IsA("ScreenGui") then
                -- Search for the text "Apply to Janitor job?"
                for _, desc in pairs(gui:GetDescendants()) do
                    if desc:IsA("TextLabel") and string.find(desc.Text, "Apply to Janitor") then
                        print("Found job dialog with text: " .. desc.Text)
                        
                        -- Look for the green Apply button (should be a TextButton with "Apply" text)
                        for _, buttonDesc in pairs(desc.Parent:GetDescendants()) do
                            if buttonDesc:IsA("TextButton") and buttonDesc.Text == "Apply" then
                                print("Found Apply button!")
                                
                                -- Try multiple methods to click the button
                                local clicked = false
                                
                                -- Method 1: Fire MouseButton1Click directly
                                pcall(function()
                                    buttonDesc.MouseButton1Click:Fire()
                                    clicked = true
                                    print("Method 1: Direct MouseButton1Click fire succeeded")
                                end)
                                
                                wait(0.2)
                                
                                -- Method 2: Using getconnections
                                if not clicked then
                                    pcall(function()
                                        for _, connection in pairs(getconnections(buttonDesc.MouseButton1Click)) do
                                            connection:Fire()
                                            clicked = true
                                            print("Method 2: getconnections fire succeeded")
                                            break
                                        end
                                    end)
                                end
                                
                                if clicked then
                                    print("Successfully clicked Apply button!")
                                    return true
                                end
                            end
                        end
                        break
                    end
                end
            end
        end
        
        print("Could not find Apply button in any GUI")
        return false
    end

    -- Function to maintain Y position for janitor
    local function maintainJanitorYPosition()
        JanitorFarm_State.yPositionMaintenance = true
        
        -- Create a loop that constantly sets the Y position
        spawn(function()
            while JanitorFarm_State.yPositionMaintenance and JanitorFarm_State.running do
                local char, hum, root = getJanitorCharacterReferences()
                if root then
                    local currentPos = root.Position
                    if currentPos.Y ~= JanitorFarm_State.config.fixedYPosition then
                        root.CFrame = CFrame.new(currentPos.X, JanitorFarm_State.config.fixedYPosition, currentPos.Z)
                    end
                end
                wait(0.1)
            end
        end)
    end

    -- Function to get all puddle locations and sort them by distance
    local function getPuddlesInOrder()
        if not JanitorFarm_State.running then return {} end
        
        local char, hum, root = getJanitorCharacterReferences()
        if not root then return {} end
        
        -- Find all puddles in the container
        local puddlesContainer = workspace.Map.Tiles.BurgerPlaceTile.BurgerPlace.Interior.Puddles
        
        print("Searching for small puddles only...")
        
        -- Create a table to hold small puddles
        local puddles = {}
        
        -- Add the specifically named SmallPuddle if it exists
        local smallPuddle = puddlesContainer:FindFirstChild("SmallPuddle")
        if smallPuddle then
            table.insert(puddles, smallPuddle)
            print("Found named SmallPuddle")
        end
        
        -- Look through all puddles and find any with "Small" in the name
        for _, puddle in pairs(puddlesContainer:GetChildren()) do
            -- Check if the puddle has "Small" in its name and isn't already in our list
            if puddle and puddle.Name:find("Small") and puddle ~= smallPuddle then
                table.insert(puddles, puddle)
                print("Found puddle with Small in name: " .. puddle.Name)
            end
        end
        
        -- Filter out nil entries and explicitly exclude puddles at indices 4 and 5
        local validPuddles = {}
        for _, puddle in pairs(puddles) do
            if puddle then
                -- Check if this puddle is one of the ones we want to exclude
                local isExcluded = false
                local allChildren = puddlesContainer:GetChildren()
                for i, child in pairs(allChildren) do
                    if child == puddle and (i == 4 or i == 5) then
                        isExcluded = true
                        print("Excluding puddle at index " .. i)
                        break
                    end
                end
                
                -- Only add if not excluded
                if not isExcluded then
                    table.insert(validPuddles, puddle)
                end
            end
        end
        
        -- Sort by distance (closest first)
        table.sort(validPuddles, function(a, b)
            return (a.Position - root.Position).Magnitude < (b.Position - root.Position).Magnitude
        end)
        
        return validPuddles
    end

    -- Function to clean a puddle
    local function cleanPuddle(puddle)
        if not JanitorFarm_State.running then return false end
        
        local char, hum, root = getJanitorCharacterReferences()
        if not root then
            print("No character found for puddle cleaning, waiting for respawn...")
            char, hum, root = waitForJanitorCharacter()
            if not root or not JanitorFarm_State.running then return false end
        end
        
        print("Cleaning puddle: " .. puddle.Name)
        print("Cleaning a small puddle: " .. puddle.Name)
        
        -- Try to find TouchInterest in the puddle
        local touchInterest = puddle:FindFirstChild("TouchInterest")
        if touchInterest then
            print("Touching puddle to start cleaning...")
            firetouchinterest(root, puddle, 0) -- Begin touch
            
            -- Wait for cleaning to complete
            print("Waiting " .. JanitorFarm_State.config.waitTimePerPuddle .. " seconds to clean puddle...")
            local startTime = tick()
            while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
                wait(0.1)
            end
            
            if not JanitorFarm_State.running then return false end
            
            firetouchinterest(root, puddle, 1) -- End touch
            print("Puddle cleaning completed")
            return true
        else
            -- If no TouchInterest, try to find a ProximityPrompt or other interaction
            local proximityPrompt = puddle:FindFirstChild("ProximityPrompt")
            if proximityPrompt then
                print("Activating proximity prompt on puddle...")
                fireproximityprompt(proximityPrompt)
                
                -- Wait for cleaning to complete
                local startTime = tick()
                while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
                    wait(0.1)
                end
                
                if not JanitorFarm_State.running then return false end
                
                print("Puddle cleaning completed")
                return true
            else
                -- If no direct interaction method found, just wait at the puddle
                print("No direct interaction method found, waiting at puddle...")
                local startTime = tick()
                while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.waitTimePerPuddle do
                    wait(0.1)
                end
                
                if not JanitorFarm_State.running then return false end
                
                print("Puddle cleaning completed")
                return true
            end
        end
        
        return false
    end

    -- Function to visit all puddles in a continuous loop
    local function visitAllPuddlesLoop()
        print("Starting continuous puddle cleaning loop...")
        
        -- Run while script is enabled
        while JanitorFarm_State.running do
            -- Check character references
            local char, hum, root = getJanitorCharacterReferences()
            if not char or not hum or not root then
                print("Character lost during puddle loop, waiting for respawn...")
                char, hum, root = waitForJanitorCharacter()
                if not char or not hum or not root or not JanitorFarm_State.running then
                    break
                end
            end
            
            -- Get puddles sorted by distance (recalculated each loop)
            local sortedPuddles = getPuddlesInOrder()
            print("Found " .. #sortedPuddles .. " puddles to visit")
            
            -- If no puddles found, wait a bit and try again
            if #sortedPuddles == 0 then
                if not JanitorFarm_State.running then break end
                print("No puddles found, waiting before retrying...")
                local startTime = tick()
                while JanitorFarm_State.running and (tick() - startTime) < (JanitorFarm_State.config.loopWaitTime * 2) do
                    wait(0.1)
                end
            else
                -- Visit each puddle
                for i, puddle in ipairs(sortedPuddles) do
                    if not JanitorFarm_State.running then break end
                    
                    -- Check character references before each puddle
                    local currentChar, currentHum, currentRoot = getJanitorCharacterReferences()
                    if not currentChar or not currentHum or not currentRoot then
                        print("Character lost before puddle " .. i .. ", breaking loop...")
                        break
                    end
                    
                    print("Moving to puddle " .. i .. "/" .. #sortedPuddles .. " - " .. puddle.Name)
                    
                    -- Move to the puddle
                    if moveToJanitorLocation(puddle.Position) then
                        if not JanitorFarm_State.running then break end
                        
                        cleanPuddle(puddle)
                        
                        if not JanitorFarm_State.running then break end
                        
                        -- Short wait between puddles
                        local startTime = tick()
                        while JanitorFarm_State.running and (tick() - startTime) < 0.5 do
                            wait(0.1)
                        end
                    else
                        print("Failed to reach puddle " .. i)
                        -- If movement failed, might be character issue - break to restart
                        break
                    end
                end
                
                if not JanitorFarm_State.running then break end
                
                print("Completed one cleaning cycle, waiting before starting the next cycle...")
                local startTime = tick()
                while JanitorFarm_State.running and (tick() - startTime) < JanitorFarm_State.config.loopWaitTime do
                    wait(0.1)
                end
            end
        end
    end

    -- Main janitor farming function
    local function startJanitorFarm()
        while JanitorFarm_State.running do
            -- Wait for character if needed
            local char, hum, root = getJanitorCharacterReferences()
            if not char or not hum or not root then
                print("Waiting for character...")
                char, hum, root = waitForJanitorCharacter()
                if not char or not hum or not root or not JanitorFarm_State.running then
                    break
                end
            end
            
            -- Set up death detection for current character
            table.insert(JanitorFarm_State.connections, hum.Died:Connect(onJanitorCharacterDied))
            
            print("Starting janitor job application sequence")
            print("- Fixed Y position: " .. JanitorFarm_State.config.fixedYPosition)
            print("- Tween speed: " .. JanitorFarm_State.config.tweenSpeed .. " (lower = faster)")
            print("- Base wait time per puddle: " .. JanitorFarm_State.config.waitTimePerPuddle .. " seconds")
            print("- Loop wait time: " .. JanitorFarm_State.config.loopWaitTime .. " seconds")
            print("- CLEANING SMALL PUDDLES ONLY")
            
            -- Start the Y position maintenance
            maintainJanitorYPosition()
            
            -- Step 1: Move to the target location
            if moveToJanitorLocation(JanitorFarm_State.targetPart) and JanitorFarm_State.running then
                -- Step 2: Fire touch transmitters
                if fireJanitorTouch() and JanitorFarm_State.running then
                    -- Wait a moment for the dialog to appear
                    local startTime = tick()
                    while JanitorFarm_State.running and (tick() - startTime) < 1.5 do
                        wait(0.1)
                    end
                    
                    if not JanitorFarm_State.running then break end
                    
                    -- Step 3: Click Apply button
                    if clickJanitorApplyButton() and JanitorFarm_State.running then
                        print("Successfully applied for janitor job!")
                        
                        -- Wait a moment for job to be applied
                        local startTime = tick()
                        while JanitorFarm_State.running and (tick() - startTime) < 2 do
                            wait(0.1)
                        end
                        
                        if not JanitorFarm_State.running then break end
                        
                        -- Step 4: Start continuous puddle cleaning loop
                        visitAllPuddlesLoop()
                    else
                        if not JanitorFarm_State.running then break end
                        
                        print("Failed to click Apply button. Trying to start puddle cleaning anyway...")
                        
                        -- Wait and try to start puddle cleaning loop anyway
                        local startTime = tick()
                        while JanitorFarm_State.running and (tick() - startTime) < 2 do
                            wait(0.1)
                        end
                        
                        if JanitorFarm_State.running then
                            visitAllPuddlesLoop()
                        end
                    end
                else
                    print("Failed to interact with the TouchPart, retrying...")
                    if JanitorFarm_State.running then
                        wait(2)
                        continue
                    end
                end
            else
                print("Failed to reach target location, retrying...")
                if JanitorFarm_State.running then
                    wait(2)
                    continue
                end
            end
            
            -- If we get here and script is still running, character probably died
            if JanitorFarm_State.running then
                print("Restarting due to character issue...")
                wait(1) -- Short wait before restarting
            end
        end
        
        janitorCleanup()
    end

    -- Add the Burger Place Janitor Auto Farm toggle using your GUI's toggle system
    local JanitorToggle = AutoFarmCategory:AddToggle("Burger Place Janitor", false, function(Value)
        JanitorFarm_State.running = Value
        
        if JanitorFarm_State.running then
            UI:Notify("Auto Farm", "Burger Place Janitor started!", 3, "Success")
            print("Janitor farm started!")
            -- Run the farm in a separate thread so it doesn't block
            spawn(function()
                startJanitorFarm()
            end)
        else
            UI:Notify("Auto Farm", "Burger Place Janitor stopped!", 2, "Info")
            print("Janitor farm stopped!")
            janitorCleanup()
        end
    end)
end

-- ===== ATM HACK AUTO-WIN SCRIPT =====
do -- Wrap in do-end block to keep variables local
    -- Consolidated state management for ATM hack
    local ATMHack_State = {
        running = false,
        loop = nil,
        SliderMinigame = require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame)
    }

    -- Override the needle position calculation
    local function modifiedNeedlePositionCalculation()
        -- Increase speed multiplier (from 0.65 to 2)
        local v23 = tick() * 2 % 3;
        
        -- Expand range from [0, 1] to [-0.5, 1.5]
        if v23 > 1.5 then
            v23 = 3 - v23;
        elseif v23 < -0.5 then
            v23 = -v23 - 0.5;
        end
        
        ATMHack_State.SliderMinigame.needle_pos.set(v23)
    end

    -- Function to check if needle is in target zone
    local function isNeedleInTargetZone()
        local needlePos = ATMHack_State.SliderMinigame.needle_pos.get()
        local targetPos = ATMHack_State.SliderMinigame.target_pos.get()
        local targetSize = ATMHack_State.SliderMinigame.target_size.get()
        
        -- Expand target zone slightly for more success
        local lowerBound = targetPos - (targetSize / 2) - 0.1
        local upperBound = targetPos + (targetSize / 2) + 0.1
        
        -- Check if needle is within the expanded target zone
        return needlePos >= lowerBound and needlePos <= upperBound
    end

    -- Function to simulate a click when in target zone
    local function autoClickIfInTargetZone()
        if isNeedleInTargetZone() then
            -- Simulate clicking
            local currentLevel = ATMHack_State.SliderMinigame.level.get()
            ATMHack_State.SliderMinigame.level.set(currentLevel + 1)
            
            -- Minimal audio feedback
            require(game:GetService("ReplicatedStorage").Modules.Game.Minigames.SliderMinigame.play_audio)(
                "3450794184", 
                0.1, 
                (math.min(2, 1.25 + 0.25 * currentLevel))
            )
        end
    end

    -- Main auto-win loop
    local function autoWinATMHack()
        -- Ensure the minigame is enabled
        if not ATMHack_State.SliderMinigame.enabled.get() then return end
        
        -- Modify needle position calculation
        modifiedNeedlePositionCalculation()
        
        -- Try to click in target zone multiple times
        for _ = 1, 3 do
            autoClickIfInTargetZone()
        end
        
        -- Check if we've reached target levels
        if ATMHack_State.SliderMinigame.level.get() >= ATMHack_State.SliderMinigame.levels.get() then
            ATMHack_State.SliderMinigame.win:Fire(true)
        end
    end

    -- ATM Hack cleanup function
    local function atmHackCleanup()
        print("Cleaning up ATM hack script...")
        ATMHack_State.running = false
        if ATMHack_State.loop then
            ATMHack_State.loop = nil
        end
        print("ATM hack script stopped and cleaned up.")
    end

    -- Start ATM hack function
    local function startATMHack()
        print("ATM Hack started! The script will automatically win ATM minigames.")
        
        -- Main loop
        ATMHack_State.loop = task.spawn(function()
            while ATMHack_State.running do
                -- Minimal wait time
                task.wait(0.01)
                
                -- Auto-win logic
                local success, err = pcall(autoWinATMHack)
                if not success then
                    warn("Auto-win error: " .. tostring(err))
                end
            end
        end)
    end

    -- Add the ATM Hack Auto-Win toggle using your GUI's toggle system
    local ATMHackToggle = AutoFarmCategory:AddToggle("ATM Hack Auto-Win", false, function(Value)
        ATMHack_State.running = Value
        
        if ATMHack_State.running then
            UI:Notify("Miscellaneous", "ATM Hack Auto-Win started!", 3, "Success")
            print("ATM Hack started!")
            -- Run the hack in a separate thread so it doesn't block
            spawn(function()
                startATMHack()
            end)
        else
            UI:Notify("Miscellaneous", "ATM Hack Auto-Win stopped!", 2, "Info")
            print("ATM Hack stopped!")
            atmHackCleanup()
        end
    end)
end

do
    ---------------------------------------------------------------------------------------------
    -- ESP SYSTEM SCRIPT (GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    local LocalPlayer = game.Players.LocalPlayer
    local runService = game:GetService("RunService")
    
    -- Consolidated state management for ESP system
    local ESP_State = {
        objects2D = {},
        objects3D = {},
        currentMode = "2D Box",
        enabled = false,
        connections = {},
        config2D = {
            BoxThickness = 2,
            BoxTransparency = 1,
            HealthColorGradient = {
                {Threshold = 25, Color = Color3.fromRGB(255, 0, 0)},     -- Red at low health
                {Threshold = 50, Color = Color3.fromRGB(255, 165, 0)},   -- Orange at medium-low health
                {Threshold = 75, Color = Color3.fromRGB(255, 255, 0)},   -- Yellow at medium health
                {Threshold = 100, Color = Color3.fromRGB(0, 255, 0)}     -- Green at full health
            },
            MaxDisplayDistance = 1000,
            BoxSizeX = 2,
            BoxSizeY = 3,
            RefreshRate = 5,
        },
        config3D = {
            Box_Color = Color3.fromRGB(255, 0, 0),
            Box_Thickness = 2,
            Box_Transparency = 1,
            Autothickness = true
        }
    }
    
    -- Functions for health color (2D ESP)
    local function GetHealthColor2D(health)
        for _, colorInfo in ipairs(ESP_State.config2D.HealthColorGradient) do
            if health <= colorInfo.Threshold then
                return colorInfo.Color
            end
        end
        return Color3.fromRGB(0, 255, 0)
    end
    
    -- Functions for health color (3D ESP)
    local function GetHealthColor3D(currentHealth, maxHealth)
        return Color3.fromRGB(227, 52, 52):Lerp(Color3.fromRGB(88, 217, 24), currentHealth / maxHealth)
    end
    
    -- Create 2D ESP objects for a player
    local function CreateESP2DForPlayer(espPlayer)
        if espPlayer == LocalPlayer then return end
        if ESP_State.objects2D[espPlayer] then return ESP_State.objects2D[espPlayer] end
        
        ESP_State.objects2D[espPlayer] = {
            Top = Drawing.new("Line"),
            Bottom = Drawing.new("Line"),
            Left = Drawing.new("Line"),
            Right = Drawing.new("Line"),
            LastUpdate = tick()
        }
        
        for _, line in pairs(ESP_State.objects2D[espPlayer]) do
            if type(line) ~= "number" then
                line.Visible = false
                line.Thickness = ESP_State.config2D.BoxThickness
                line.Transparency = ESP_State.config2D.BoxTransparency
                line.Color = ESP_State.config2D.HealthColorGradient[1].Color
                line.From = Vector2.new(0, 0)
                line.To = Vector2.new(0, 0)
            end
        end
        
        return ESP_State.objects2D[espPlayer]
    end
    
    -- Create 3D ESP objects for a player
    local function CreateESP3DForPlayer(espPlayer)
        if espPlayer == LocalPlayer then return end
        if ESP_State.objects3D[espPlayer] then return ESP_State.objects3D[espPlayer] end
        
        ESP_State.objects3D[espPlayer] = {
            lines = {},
            connection = nil
        }
        
        for i = 1, 12 do
            ESP_State.objects3D[espPlayer].lines[i] = Drawing.new("Line")
            ESP_State.objects3D[espPlayer].lines[i].Visible = false
            ESP_State.objects3D[espPlayer].lines[i].Color = ESP_State.config3D.Box_Color
            ESP_State.objects3D[espPlayer].lines[i].Thickness = ESP_State.config3D.Box_Thickness
            ESP_State.objects3D[espPlayer].lines[i].Transparency = ESP_State.config3D.Box_Transparency
        end
        
        return ESP_State.objects3D[espPlayer]
    end
    
    -- Remove ESP objects for a player
    local function RemoveESPForPlayer(espPlayer)
        -- Remove 2D ESP
        if ESP_State.objects2D[espPlayer] then
            for _, line in pairs(ESP_State.objects2D[espPlayer]) do
                if type(line) ~= "number" then
                    line:Remove()
                end
            end
            ESP_State.objects2D[espPlayer] = nil
        end
        
        -- Remove 3D ESP
        if ESP_State.objects3D[espPlayer] then
            if ESP_State.objects3D[espPlayer].connection then
                ESP_State.objects3D[espPlayer].connection:Disconnect()
            end
            for _, line in pairs(ESP_State.objects3D[espPlayer].lines) do
                line:Remove()
            end
            ESP_State.objects3D[espPlayer] = nil
        end
    end
    
    -- Update 2D ESP for all players
    local function Update2DESP()
        for _, espPlayer in ipairs(game.Players:GetPlayers()) do
            if espPlayer ~= LocalPlayer then
                local espObj = CreateESP2DForPlayer(espPlayer)
                
                if ESP_State.enabled and ESP_State.currentMode == "2D Box" and espPlayer.Character and 
                   espPlayer.Character:FindFirstChild("HumanoidRootPart") and 
                   espPlayer.Character:FindFirstChild("Humanoid") then
                    
                    if tick() - espObj.LastUpdate > ESP_State.config2D.RefreshRate then
                        RemoveESPForPlayer(espPlayer)
                        espObj = CreateESP2DForPlayer(espPlayer)
                        espObj.LastUpdate = tick()
                    end
                    
                    local hrp = espPlayer.Character.HumanoidRootPart
                    local humanoid = espPlayer.Character.Humanoid
                    local head = espPlayer.Character:FindFirstChild("Head")
                    
                    local distance = (workspace.CurrentCamera.CFrame.Position - hrp.Position).Magnitude
                    if distance > ESP_State.config2D.MaxDisplayDistance then
                        for _, line in pairs(espObj) do
                            if type(line) ~= "number" then
                                line.Visible = false
                            end
                        end
                    else
                        local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(hrp.Position)
                        
                        if onScreen then
                            local scaleFactor = math.clamp(1 - (distance / ESP_State.config2D.MaxDisplayDistance), 0.3, 1)
                            local scale = (head and head.Size.Y/2 or 0.5)
                            local size = Vector3.new(ESP_State.config2D.BoxSizeX, ESP_State.config2D.BoxSizeY, 0) * (scale * 2 * scaleFactor)
                            
                            local TL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, size.Y, 0)).Position)
                            local TR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, size.Y, 0)).Position)
                            local BL = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(size.X, -size.Y, 0)).Position)
                            local BR = workspace.CurrentCamera:WorldToViewportPoint((hrp.CFrame * CFrame.new(-size.X, -size.Y, 0)).Position)
                            
                            espObj.Top.From = Vector2.new(TL.X, TL.Y)
                            espObj.Top.To = Vector2.new(TR.X, TR.Y)
                            espObj.Left.From = Vector2.new(TL.X, TL.Y)
                            espObj.Left.To = Vector2.new(BL.X, BL.Y)
                            espObj.Right.From = Vector2.new(TR.X, TR.Y)
                            espObj.Right.To = Vector2.new(BR.X, BR.Y)
                            espObj.Bottom.From = Vector2.new(BL.X, BL.Y)
                            espObj.Bottom.To = Vector2.new(BR.X, BR.Y)
                            
                            local healthPercentage = (humanoid.Health / humanoid.MaxHealth) * 100
                            
                            for _, line in pairs(espObj) do
                                if type(line) ~= "number" then
                                    line.Color = GetHealthColor2D(healthPercentage)
                                    line.Transparency = ESP_State.config2D.BoxTransparency * scaleFactor
                                    line.Visible = true
                                end
                            end
                        else
                            for _, line in pairs(espObj) do
                                if type(line) ~= "number" then
                                    line.Visible = false
                                end
                            end
                        end
                    end
                else
                    for _, line in pairs(espObj) do
                        if type(line) ~= "number" then
                            line.Visible = false
                        end
                    end
                end
            end
        end
    end
    
    -- Create 3D ESP for a specific player
    local function Create3DESPForPlayer(espPlayer)
        if espPlayer == LocalPlayer then return end
        
        local esp3DObj = CreateESP3DForPlayer(espPlayer)
        
        local function Update3DESP()
            if ESP_State.enabled and ESP_State.currentMode == "3D Box" and espPlayer.Character and 
               espPlayer.Character:FindFirstChild("Humanoid") and 
               espPlayer.Character:FindFirstChild("HumanoidRootPart") and 
               espPlayer.Character.Humanoid.Health > 0 then
                
                local pos, vis = workspace.CurrentCamera:WorldToViewportPoint(espPlayer.Character.HumanoidRootPart.Position)
                if vis then
                    local Scale = espPlayer.Character.Head.Size.Y/2
                    local Size = Vector3.new(2, 3, 1.5) * (Scale * 2)

                    local Top1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, -Size.Z)).p)
                    local Top2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, Size.Y, Size.Z)).p)
                    local Top3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, Size.Z)).p)
                    local Top4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, Size.Y, -Size.Z)).p)

                    local Bottom1 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, -Size.Z)).p)
                    local Bottom2 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(-Size.X, -Size.Y, Size.Z)).p)
                    local Bottom3 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, Size.Z)).p)
                    local Bottom4 = workspace.CurrentCamera:WorldToViewportPoint((espPlayer.Character.HumanoidRootPart.CFrame * CFrame.new(Size.X, -Size.Y, -Size.Z)).p)

                    local lines = esp3DObj.lines
                    
                    -- Top face
                    lines[1].From = Vector2.new(Top1.X, Top1.Y); lines[1].To = Vector2.new(Top2.X, Top2.Y)
                    lines[2].From = Vector2.new(Top2.X, Top2.Y); lines[2].To = Vector2.new(Top3.X, Top3.Y)
                    lines[3].From = Vector2.new(Top3.X, Top3.Y); lines[3].To = Vector2.new(Top4.X, Top4.Y)
                    lines[4].From = Vector2.new(Top4.X, Top4.Y); lines[4].To = Vector2.new(Top1.X, Top1.Y)
                    
                    -- Bottom face
                    lines[5].From = Vector2.new(Bottom1.X, Bottom1.Y); lines[5].To = Vector2.new(Bottom2.X, Bottom2.Y)
                    lines[6].From = Vector2.new(Bottom2.X, Bottom2.Y); lines[6].To = Vector2.new(Bottom3.X, Bottom3.Y)
                    lines[7].From = Vector2.new(Bottom3.X, Bottom3.Y); lines[7].To = Vector2.new(Bottom4.X, Bottom4.Y)
                    lines[8].From = Vector2.new(Bottom4.X, Bottom4.Y); lines[8].To = Vector2.new(Bottom1.X, Bottom1.Y)
                    
                    -- Vertical lines
                    lines[9].From = Vector2.new(Top1.X, Top1.Y); lines[9].To = Vector2.new(Bottom1.X, Bottom1.Y)
                    lines[10].From = Vector2.new(Top2.X, Top2.Y); lines[10].To = Vector2.new(Bottom2.X, Bottom2.Y)
                    lines[11].From = Vector2.new(Top3.X, Top3.Y); lines[11].To = Vector2.new(Bottom3.X, Bottom3.Y)
                    lines[12].From = Vector2.new(Top4.X, Top4.Y); lines[12].To = Vector2.new(Bottom4.X, Bottom4.Y)

                    -- Health-based color and thickness
                    local healthColor = GetHealthColor3D(espPlayer.Character.Humanoid.Health, espPlayer.Character.Humanoid.MaxHealth)
                    local thickness = ESP_State.config3D.Box_Thickness
                    if ESP_State.config3D.Autothickness then
                        thickness = math.clamp(1/(LocalPlayer.Character.HumanoidRootPart.Position - espPlayer.Character.HumanoidRootPart.Position).magnitude*100, 0.1, 4)
                    end
                    
                    for _, line in pairs(lines) do
                        line.Color = healthColor
                        line.Thickness = thickness
                        line.Visible = true
                    end
                else
                    for _, line in pairs(esp3DObj.lines) do
                        line.Visible = false
                    end
                end
            else
                for _, line in pairs(esp3DObj.lines) do
                    line.Visible = false
                end
                if not game.Players:FindFirstChild(espPlayer.Name) then
                    if esp3DObj.connection then
                        esp3DObj.connection:Disconnect()
                    end
                end
            end
        end
        
        esp3DObj.connection = runService.RenderStepped:Connect(Update3DESP)
    end
    
    -- Initialize 3D ESP for all players
    local function Initialize3DESP()
        for _, espPlayer in ipairs(game.Players:GetPlayers()) do
            if espPlayer ~= LocalPlayer then
                Create3DESPForPlayer(espPlayer)
            end
        end
    end
    
    -- Clean up all ESP
    local function CleanupAllESP()
        for espPlayer, _ in pairs(ESP_State.objects2D) do
            RemoveESPForPlayer(espPlayer)
        end
        for espPlayer, _ in pairs(ESP_State.objects3D) do
            RemoveESPForPlayer(espPlayer)
        end
        
        -- Disconnect all connections
        for _, connection in pairs(ESP_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        ESP_State.connections = {}
    end
    
    -- Update ESP based on current mode
    local function UpdateESPSystem()
        if not ESP_State.enabled then
            CleanupAllESP()
            return
        end
        
        if ESP_State.currentMode == "2D Box" then
            -- Clean up 3D ESP
            for espPlayer, esp3DObj in pairs(ESP_State.objects3D) do
                if esp3DObj.connection then
                    esp3DObj.connection:Disconnect()
                end
                for _, line in pairs(esp3DObj.lines) do
                    line.Visible = false
                end
            end
        elseif ESP_State.currentMode == "3D Box" then
            -- Clean up 2D ESP
            for espPlayer, espObj in pairs(ESP_State.objects2D) do
                for _, line in pairs(espObj) do
                    if type(line) ~= "number" then
                        line.Visible = false
                    end
                end
            end
            Initialize3DESP()
        end
    end
    
    -- ESP Type Dropdown
    local ESPTypeDropdown = VisualsCategory:AddDropdown("ESP Type", {"2D Box", "3D Box"}, function(Value)
        UI:Notify("Visuals", "ESP Type: " .. Value, 2, "Info")
        ESP_State.currentMode = Value
        UpdateESPSystem()
    end)
    
    -- ESP Toggle
    local ESPToggle = VisualsCategory:AddToggle("Box ESP", false, function(Value)
        ESP_State.enabled = Value
        if Value then
            UI:Notify("Visuals", "ESP started!", 3, "Success")
            -- Start ESP system
            UpdateESPSystem()
            
            -- Main render loop for 2D ESP
            ESP_State.connections.renderLoop = runService.RenderStepped:Connect(function()
                if ESP_State.enabled and ESP_State.currentMode == "2D Box" then
                    Update2DESP()
                end
            end)
            
            -- Handle new players joining
            ESP_State.connections.playerAdded = game.Players.PlayerAdded:Connect(function(newPlayer)
                if ESP_State.currentMode == "3D Box" and ESP_State.enabled then
                    spawn(function()
                        wait(1) -- Wait for character to load
                        Create3DESPForPlayer(newPlayer)
                    end)
                end
            end)
            
            -- Handle players leaving
            ESP_State.connections.playerRemoving = game.Players.PlayerRemoving:Connect(function(espPlayer)
                RemoveESPForPlayer(espPlayer)
            end)
            
        else
            UI:Notify("Visuals", "ESP stopped!", 2, "Info")
            -- Stop ESP system
            CleanupAllESP()
        end
    end)
    
end

do
    ---------------------------------------------------------------------------------------------
    -- NAME TAGS SYSTEM SCRIPT (GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    local LocalPlayer = game.Players.LocalPlayer
    local runService = game:GetService("RunService")
    
    -- Consolidated state management for name tags
    local NameTags_State = {
        enabled = false,
        connection = nil
    }
    
    local function createNameTag(namePlayer)
        if namePlayer == LocalPlayer then return end
        
        local character = namePlayer.Character
        if not character then return end
        
        local head = character:FindFirstChild("Head")
        if not head then return end
        
        local existingTag = head:FindFirstChild("NameTag")
        if existingTag then return end -- Don't create if already exists
        
        local billboardGui = Instance.new("BillboardGui")
        billboardGui.Name = "NameTag"
        billboardGui.Parent = head
        billboardGui.Size = UDim2.new(0, 100, 0, 20)
        billboardGui.StudsOffset = Vector3.new(0, 2, 0)
        billboardGui.AlwaysOnTop = true
        billboardGui.LightInfluence = 0
        billboardGui.SizeOffset = Vector2.new(0, 0)
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Parent = billboardGui
        nameLabel.Size = UDim2.new(1, 0, 1, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = namePlayer.Name
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.TextSize = 12
        nameLabel.Font = Enum.Font.SourceSansBold
        nameLabel.TextStrokeTransparency = 0
        nameLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    end
    
    local function removeAllNameTags()
        for _, namePlayer in pairs(game.Players:GetPlayers()) do
            if namePlayer.Character then
                local head = namePlayer.Character:FindFirstChild("Head")
                if head then
                    local nameTag = head:FindFirstChild("NameTag")
                    if nameTag then
                        nameTag:Destroy()
                    end
                end
            end
        end
    end
    
    -- Name tags cleanup function
    local function nameTagsCleanup()
        -- Stop the connection
        if NameTags_State.connection then
            NameTags_State.connection:Disconnect()
            NameTags_State.connection = nil
        end
        
        -- Remove all existing name tags
        removeAllNameTags()
    end
    
    -- Start name tags function
    local function startNameTags()
        -- Start the name tag system
        NameTags_State.connection = runService.Heartbeat:Connect(function()
            if NameTags_State.enabled then
                for _, namePlayer in pairs(game.Players:GetPlayers()) do
                    if namePlayer ~= LocalPlayer and namePlayer.Character then
                        createNameTag(namePlayer)
                    end
                end
            end
        end)
    end
    
    -- Name Tags Toggle
    local NameTagsToggle = VisualsCategory:AddToggle("Name ESP", false, function(Value)
        NameTags_State.enabled = Value
        
        if Value then
            UI:Notify("Visuals", "Name ESP started!", 3, "Success")
            -- Run the name tags in a separate thread so it doesn't block
            spawn(function()
                startNameTags()
            end)
        else
            UI:Notify("Visuals", "Name ESP stopped!", 2, "Info")
            nameTagsCleanup()
        end
    end)
    
end

do
    ---------------------------------------------------------------------------------------------
    -- WEAPON ESP SYSTEM SCRIPT (GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    local LocalPlayer = game.Players.LocalPlayer
    local runService = game:GetService("RunService")
    
    -- Move weapon data to global scope to avoid local variable limits
    getgenv().WeaponESPData = getgenv().WeaponESPData or {}

    -- Weapon signatures for identification
    getgenv().WeaponESPData.signatures = {
        -- Firearms
        AK47 = {accuracy = 0.85, automatic = true, fire_rate = 600, MagSize = 30, range = 300, Recoil = 0.4, reload_time = 2.2, damage = 27, Durability = 720, KnockbackForce = 100, RagdollChance = 0.1, RarityName = "Legendary", RarityPrice = 70000},
        Anaconda = {accuracy = 0.95, automatic = false, fire_rate = 80, MagSize = 6, range = 120, Recoil = 0.8, reload_time = 2, damage = 70, Durability = 120, KnockbackForce = 350, RagdollChance = 0.3, RarityName = "Omega", RarityPrice = 420000},
        C9 = {accuracy = 0.7, automatic = false, fire_rate = 300, MagSize = 8, range = 80, Recoil = 0.2, reload_time = 2, damage = 11, Durability = 120, RagdollChance = 0, RarityName = "Uncommon", RarityPrice = 700},
        Crossbow = {accuracy = 0.95, automatic = false, fire_rate = 100, MagSize = 1, range = 500, Recoil = 0.3, reload_time = 2, damage = 90, Durability = 120, KnockbackForce = 100, RagdollChance = 0.3, RarityName = "Legendary", RarityPrice = 60000},
        ["Double Barrel"] = {accuracy = 0.5, automatic = false, fire_rate = 100, MagSize = 2, range = 50, Recoil = 2, reload_time = 3, damage = 16, Durability = 84, KnockbackForce = 300, RagdollChance = 0.4, RarityName = "Epic", RarityPrice = 8000},
        Draco = {accuracy = 0.75, automatic = true, fire_rate = 900, MagSize = 25, range = 250, Recoil = 0.5, reload_time = 2.2, damage = 15, Durability = 600, RagdollChance = 0, RarityName = "Epic", RarityPrice = 19000},
        G3 = {accuracy = 0.65, automatic = false, fire_rate = 320, MagSize = 10, range = 80, Recoil = 0.2, reload_time = 2, damage = 13, Durability = 144, RagdollChance = 0, RarityName = "Uncommon", RarityPrice = 900},
        Glock = {accuracy = 0.8, automatic = false, fire_rate = 370, MagSize = 15, range = 80, Recoil = 0.2, reload_time = 2, damage = 19, Durability = 168, RagdollChance = 0, RarityName = "Rare", RarityPrice = 1800},
        ["Hunting Rifle"] = {accuracy = 0.93, automatic = false, fire_rate = 50, MagSize = 5, range = 500, Recoil = 0.8, reload_time = 2.2, damage = 35, Durability = 72, KnockbackForce = 200, RagdollChance = 0.2, RarityName = "Rare", RarityPrice = 5000},
        M24 = {accuracy = 0.97, automatic = false, fire_rate = 50, MagSize = 7, range = 500, Recoil = 0.8, reload_time = 2, damage = 50, Durability = 120, KnockbackForce = 200, RagdollChance = 0.2, RarityName = "Epic", RarityPrice = 25000},
        MP5 = {accuracy = 0.85, automatic = true, fire_rate = 800, MagSize = 30, range = 200, Recoil = 0.35, reload_time = 2, damage = 19, Durability = 720, RagdollChance = 0, RarityName = "Legendary", RarityPrice = 38000},
        P226 = {accuracy = 0.75, automatic = false, fire_rate = 370, MagSize = 7, range = 80, Recoil = 0.25, reload_time = 2, damage = 22, Durability = 180, RagdollChance = 0, RarityName = "Rare", RarityPrice = 2200},
        RPG = {accuracy = 0.9, automatic = false, fire_rate = 100, MagSize = 1, range = 600, Recoil = 2, reload_time = 2.6, explode_damage = 1000, Durability = 96, ExplodeKnockback = 300, ExplodeRadius = 12, RarityName = "Legendary", RarityPrice = 90000},
        Remington = {accuracy = 0.6, automatic = false, fire_rate = 80, MagSize = 5, range = 80, Recoil = 1.5, reload_time = 2, damage = 19, Durability = 300, KnockbackForce = 300, RagdollChance = 0.4, RarityName = "Legendary", RarityPrice = 45000},
        Sawnoff = {accuracy = 0.4, automatic = false, fire_rate = 150, MagSize = 2, range = 30, Recoil = 3, reload_time = 3, damage = 18, Durability = 240, KnockbackForce = 450, RagdollChance = 0.5, RarityName = "Rare", RarityPrice = 3500},
        Uzi = {accuracy = 0.7, automatic = true, fire_rate = 1200, MagSize = 20, range = 150, Recoil = 0.3, reload_time = 1.7, damage = 8, Durability = 480, RagdollChance = 0, RarityName = "Rare", RarityPrice = 3000},
        -- Melee Weapons
        Axe = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 34, destructive = 1.6, Durability = 80, knockback_force = 250, ragdoll_chance = 0.2, RarityName = "Rare", RarityPrice = 3200},
        ["Barbed Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 43, destructive = 1.2, Durability = 100, knockback_force = 300, ragdoll_chance = 0.2, RarityName = "Epic", RarityPrice = 16000},
        ["Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 26, destructive = 1.2, Durability = 80, knockback_force = 300, ragdoll_chance = 0.2, RarityName = "Uncommon", RarityPrice = 900},
        ["Bike Lock"] = {speed = 1.9, range = 6, cone_angle = 70, damage = 17, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Common", RarityPrice = 90},
        ["Bronze Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 20, MopSpeedPercentageIncrease = 10, RarityName = "Common", RarityPrice = 100},
        ["Chair Leg"] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 21, destructive = 1, Durability = 50, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Common", RarityPrice = 300},
        ["Butcher Knife"] = {speed = 1.6, range = 6, cone_angle = 75, damage = 30, destructive = 0.9, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = "Rare", RarityPrice = 1500},
        ["Combat Axe"] = {speed = 1.6, range = 6.5, cone_angle = 75, damage = 40, destructive = 1.6, Durability = 90, knockback_force = 200, ragdoll_chance = 0.15, RarityName = "Epic", RarityPrice = 14000},
        Crowbar = {speed = 1.6, range = 7, cone_angle = 80, damage = 31, destructive = 2, Durability = 100, knockback_force = 250, ragdoll_chance = 0.15, RarityName = "Rare", RarityPrice = 3000},
        ["Diamond Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 100, MopSpeedPercentageIncrease = 40, RarityName = "Rare", RarityPrice = 1500},
        ["Frying Pan"] = {speed = 1.7, range = 6.5, cone_angle = 90, damage = 28, destructive = 1, Durability = 60, knockback_force = 400, ragdoll_chance = 0.3, RarityName = "Rare", RarityPrice = 2400},
        ["Gold Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 70, MopSpeedPercentageIncrease = 30, RarityName = "Uncommon", RarityPrice = 800},
        Hammer = {speed = 1.75, range = 6, cone_angle = 70, damage = 23, destructive = 1.5, Durability = 70, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 400},
        Machette = {speed = 1.8, range = 7.25, cone_angle = 85, damage = 38, destructive = 0.9, Durability = 90, knockback_force = 100, ragdoll_chance = 0.15, RarityName = "Epic", RarityPrice = 14000},
        ["Metal Baseball Bat"] = {speed = 1.6, range = 7.5, cone_angle = 90, damage = 35, destructive = 1.4, Durability = 110, knockback_force = 350, ragdoll_chance = 0.2, RarityName = "Rare", RarityPrice = 4000},
        ["Metal Pipe"] = {speed = 1.55, range = 6.5, cone_angle = 75, damage = 20, destructive = 1.5, Durability = 60, knockback_force = 150, ragdoll_chance = 0.3, RarityName = "Common", RarityPrice = 150},
        Mop = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 0, MopSpeedPercentageIncrease = 0, RarityName = "Common", RarityPrice = 0},
        ["Nailed Wooden Board"] = {speed = 1.4, range = 6.5, cone_angle = 80, damage = 23, destructive = 1, Durability = 40, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 350},
        ["Pool Cue"] = {speed = 1.7, range = 7.5, cone_angle = 80, damage = 15, destructive = 1, Durability = 30, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 70},
        ["Rolling Pin"] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 16, destructive = 1, Durability = 30, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 70},
        ["Rusty Shovel"] = {speed = 1.2, range = 7, cone_angle = 75, damage = 25, destructive = 1.3, Durability = 50, knockback_force = 250, ragdoll_chance = 0.15, RarityName = "Uncommon", RarityPrice = 600},
        Shank = {speed = 2, range = 5.5, cone_angle = 60, damage = 20, destructive = 0.7, Durability = 40, knockback_force = 50, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 300},
        Shovel = {speed = 1.2, range = 7.5, cone_angle = 75, damage = 41, destructive = 1.4, Durability = 80, knockback_force = 300, ragdoll_chance = 0.3, RarityName = "Epic", RarityPrice = 9000},
        ["Silver Mop"] = {speed = 1.5, range = 6.5, cone_angle = 70, damage = 12, Durability = 30, MopCashPercentageIncrease = 45, MopSpeedPercentageIncrease = 20, RarityName = "Common", RarityPrice = 300},
        ["Sledge Hammer"] = {speed = 1.1, range = 7.25, cone_angle = 80, damage = 47, destructive = 3, Durability = 110, knockback_force = 550, ragdoll_chance = 0.5, RarityName = "Epic", RarityPrice = 25000},
        Switchblade = {speed = 2, range = 5.5, cone_angle = 60, damage = 29, destructive = 0.7, Durability = 60, knockback_force = 80, ragdoll_chance = 0.1, RarityName = "Rare", RarityPrice = 2200},
        ["Tactical Axe"] = {speed = 1.75, range = 6.5, cone_angle = 75, damage = 65, destructive = 1.5, Durability = 120, knockback_force = 250, ragdoll_chance = 0.2, RarityName = "Legendary", RarityPrice = 40000},
        ["Tactical Knife"] = {speed = 2.2, range = 5.75, cone_angle = 75, damage = 50, destructive = 0.8, Durability = 110, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Legendary", RarityPrice = 30000},
        ["Tactical Shovel"] = {speed = 2, range = 6.75, cone_angle = 75, damage = 58, destructive = 1.4, Durability = 130, knockback_force = 150, ragdoll_chance = 0.15, RarityName = "Legendary", RarityPrice = 35000},
        Taser = {speed = 2, range = 5.25, cone_angle = 60, damage = 10, Durability = 40, knockback_force = 100, ragdoll_chance = 1, RarityName = "Common", RarityPrice = 120},
        ["Tire Iron"] = {speed = 1.6, range = 6.5, cone_angle = 80, damage = 24, destructive = 1.2, Durability = 70, knockback_force = 150, ragdoll_chance = 0.1, RarityName = "Uncommon", RarityPrice = 450},
        ["Wooden Board"] = {speed = 1.45, range = 6.5, cone_angle = 80, damage = 16, destructive = 1, Durability = 25, knockback_force = 100, ragdoll_chance = 0.1, RarityName = "Common", RarityPrice = 50},
        Wrench = {speed = 1.5, range = 6, cone_angle = 80, damage = 34, destructive = 1.8, Durability = 70, knockback_force = 200, ragdoll_chance = 0.15, RarityName = "Rare", RarityPrice = 2200}
    }

    -- Weapon images
    getgenv().WeaponESPData.weaponImages = {
        AK47 = "rbxassetid://124555430577178",
        Anaconda = "rbxassetid://132781174839844",
        C9 = "rbxassetid://79659079988022",
        Crossbow = "rbxassetid://89240642376715",
        ["Double Barrel"] = "rbxassetid://83625765638039",
        Draco = "rbxassetid://120937616266903",
        G3 = "rbxassetid://133411291398002",
        Glock = "rbxassetid://97846154366870",
        ["Hunting Rifle"] = "rbxassetid://81547704965153",
        M24 = "rbxassetid://73387965982603",
        MP5 = "rbxassetid://80501079489777",
        P226 = "rbxassetid://92521100297776",
        RPG = "rbxassetid://138426000142807",
        Remington = "rbxassetid://101271375930409",
        Sawnoff = "rbxassetid://90588305892707",
        Uzi = "rbxassetid://109290695652338",
        Axe = "rbxassetid://101111222312507",
        ["Barbed Baseball Bat"] = "rbxassetid://124187547787390",
        ["Baseball Bat"] = "rbxassetid://70390201507839",
        ["Bike Lock"] = "rbxassetid://133060672669260",
        ["Bronze Mop"] = "rbxassetid://82833205175515",
        ["Butcher Knife"] = "rbxassetid://85388477314759",
        ["Chair Leg"] = "rbxassetid://114469903068875",
        ["Combat Axe"] = "rbxassetid://88977576372031",
        Crowbar = "rbxassetid://90424115101219",
        ["Diamond Mop"] = "rbxassetid://116898350978149",
        ["Frying Pan"] = "rbxassetid://89200286532524",
        ["Gold Mop"] = "rbxassetid://126972994127039",
        Hammer = "rbxassetid://78007467805546",
        Machette = "rbxassetid://137560461839499",
        ["Metal Baseball Bat"] = "rbxassetid://70685459891353",
        ["Metal Pipe"] = "rbxassetid://88009218092973",
        Mop = "rbxassetid://71489031926594",
        ["Nailed Wooden Board"] = "rbxassetid://133582084670866",
        ["Pool Cue"] = "rbxassetid://114421588409525",
        ["Rolling Pin"] = "rbxassetid://102775377780090",
        ["Rusty Shovel"] = "rbxassetid://92733711956764",
        Shank = "rbxassetid://73963170829473",
        Shovel = "rbxassetid://73431400264733",
        ["Silver Mop"] = "rbxassetid://80263199623205",
        ["Sledge Hammer"] = "rbxassetid://93546683073527",
        Switchblade = "rbxassetid://93060515735865",
        ["Tactical Axe"] = "rbxassetid://128521472487967",
        ["Tactical Knife"] = "rbxassetid://138188463918911",
        ["Tactical Shovel"] = "rbxassetid://92343057781870",
        Taser = "rbxassetid://125681892349691",
        ["Tire Iron"] = "rbxassetid://120450069729849",
        ["Wooden Board"] = "rbxassetid://73302633976873",
        Wrench = "rbxassetid://78671837243529"
    }

    -- Rarity colors for weapon boxes
    getgenv().WeaponESPData.rarityColors = {
        Common = Color3.fromRGB(169, 169, 169),
        Uncommon = Color3.fromRGB(128, 128, 128),
        Rare = Color3.fromRGB(0, 180, 0),
        Epic = Color3.fromRGB(163, 53, 238),
        Legendary = Color3.fromRGB(255, 165, 0),
        Omega = Color3.fromRGB(255, 0, 0)
    }

    -- Consolidated state management for weapon ESP
    local WeaponESP_State = {
        enabled = false,
        connection = nil,
        playerESPs = {},
        connections = {}
    }

    -- Utility functions
    local function getAttribute(obj, attr)
        local success, value = pcall(function() return obj:GetAttribute(attr) end)
        return success and value or nil
    end

    local function identifyWeapon(tool)
        for weaponName, signature in pairs(getgenv().WeaponESPData.signatures) do
            local matched, total = 0, 0
            for attrName, expectedValue in pairs(signature) do
                local toolValue = getAttribute(tool, attrName)
                if toolValue ~= nil then
                    total = total + 1
                    if type(expectedValue) == "number" then
                        if math.abs(toolValue - expectedValue) <= 0.01 then matched = matched + 1 end
                    elseif toolValue == expectedValue then matched = matched + 1 end
                end
            end
            if total > 0 and matched / total >= 0.7 then
                return {name = weaponName, rarity = signature.RarityName, price = signature.RarityPrice}
            end
        end
        return nil
    end

    local function createPlayerESP(targetPlayer)
        if targetPlayer == LocalPlayer or not WeaponESP_State.enabled then return end
        
        local targetCharacter = targetPlayer.Character
        if not targetCharacter then return end
        
        local existingESP = targetCharacter:FindFirstChild("WeaponESPAdornment")
        if existingESP then existingESP:Destroy() end
        
        local weapons = {}
        local function collectWeapons(container)
            for _, tool in ipairs(container:GetChildren()) do
                if tool:IsA("Tool") then
                    local weaponInfo = identifyWeapon(tool)
                    if weaponInfo then table.insert(weapons, weaponInfo) end
                end
            end
        end
        
        local backpack = targetPlayer:FindFirstChild("Backpack")
        if backpack then collectWeapons(backpack) end
        collectWeapons(targetCharacter)
        
        if #weapons > 0 then
            local billboard = Instance.new("BillboardGui")
            billboard.Name = "WeaponESPAdornment"
            billboard.Parent = targetCharacter
            billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
            billboard.StudsOffset = Vector3.new(0, -5, 0)
            billboard.AlwaysOnTop = true
            billboard.LightInfluence = 0
            billboard.Adornee = targetCharacter:FindFirstChild("HumanoidRootPart")
            billboard.ClipsDescendants = false
            billboard.ExtentsOffset = Vector3.new(0, 0, 0)
            billboard.ExtentsOffsetWorldSpace = Vector3.new(0, 0, 0)
            billboard.MaxDistance = math.huge
            billboard.StudsOffsetWorldSpace = Vector3.new(0, 0, 0)
            
            -- Force consistent size regardless of distance
            local connection = runService.Heartbeat:Connect(function()
                if billboard and billboard.Parent then
                    billboard.Size = UDim2.new(0, #weapons * 26, 0, 26)
                else
                    connection:Disconnect()
                end
            end)
            
            WeaponESP_State.playerESPs[targetPlayer] = {billboard = billboard, connection = connection}
            
            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(1, 0, 1, 0)
            frame.BackgroundTransparency = 1
            frame.Parent = billboard
            
            for i, weapon in ipairs(weapons) do
                -- Get rarity color for this weapon
                local rarityColor = getgenv().WeaponESPData.rarityColors[weapon.rarity] or Color3.fromRGB(255, 255, 255)
                
                -- Create individual box for each weapon
                local weaponBox = Instance.new("Frame")
                weaponBox.Size = UDim2.new(0, 22, 0, 22)
                weaponBox.Position = UDim2.new(0, (i-1) * 24, 0, 2)
                weaponBox.BackgroundColor3 = rarityColor
                weaponBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
                weaponBox.BorderSizePixel = 1
                weaponBox.Parent = frame
                
                -- Add corner rounding
                local corner = Instance.new("UICorner")
                corner.CornerRadius = UDim.new(0, 3)
                corner.Parent = weaponBox
                
                -- Add glossy gradient effect
                local gradient = Instance.new("UIGradient")
                gradient.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)),
                    ColorSequenceKeypoint.new(0.5, rarityColor),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 0))
                }
                gradient.Rotation = -45
                gradient.Parent = weaponBox
                
                -- Add subtle stroke for extra definition
                local stroke = Instance.new("UIStroke")
                stroke.Color = Color3.fromRGB(255, 255, 255)
                stroke.Transparency = 0.7
                stroke.Thickness = 1
                stroke.Parent = weaponBox
                
                -- Add weapon image inside the box
                local imageLabel = Instance.new("ImageLabel")
                imageLabel.Size = UDim2.new(0, 18, 0, 18)
                imageLabel.Position = UDim2.new(0, 2, 0, 2)
                imageLabel.BackgroundTransparency = 1
                imageLabel.Image = getgenv().WeaponESPData.weaponImages[weapon.name] or ""
                imageLabel.ScaleType = Enum.ScaleType.Fit
                imageLabel.Parent = weaponBox
            end
        end
    end

    local function removeAllESP()
        for targetPlayer, espData in pairs(WeaponESP_State.playerESPs) do
            if espData then
                if espData.billboard and espData.billboard.Parent then 
                    espData.billboard:Destroy() 
                end
                if espData.connection then
                    espData.connection:Disconnect()
                end
            end
        end
        WeaponESP_State.playerESPs = {}
        
        for _, targetPlayer in ipairs(game.Players:GetPlayers()) do
            if targetPlayer.Character then
                local existingESP = targetPlayer.Character:FindFirstChild("WeaponESPAdornment")
                if existingESP then existingESP:Destroy() end
            end
        end
        
        -- Disconnect all connections
        for _, connection in pairs(WeaponESP_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        WeaponESP_State.connections = {}
    end

    local function startESP()
        if WeaponESP_State.connection then return end
        
        for _, targetPlayer in ipairs(game.Players:GetPlayers()) do createPlayerESP(targetPlayer) end
        
        WeaponESP_State.connections.playerAdded = game.Players.PlayerAdded:Connect(createPlayerESP)
        
        WeaponESP_State.connections.playerRemoving = game.Players.PlayerRemoving:Connect(function(targetPlayer)
            if WeaponESP_State.playerESPs[targetPlayer] then
                if WeaponESP_State.playerESPs[targetPlayer].billboard then
                    WeaponESP_State.playerESPs[targetPlayer].billboard:Destroy()
                end
                if WeaponESP_State.playerESPs[targetPlayer].connection then
                    WeaponESP_State.playerESPs[targetPlayer].connection:Disconnect()
                end
                WeaponESP_State.playerESPs[targetPlayer] = nil
            end
        end)
        
        WeaponESP_State.connection = coroutine.create(function()
            while WeaponESP_State.enabled do
                wait(2)
                if WeaponESP_State.enabled then
                    for _, targetPlayer in ipairs(game.Players:GetPlayers()) do 
                        spawn(function()
                            createPlayerESP(targetPlayer)
                        end)
                    end
                end
            end
        end)
        
        coroutine.resume(WeaponESP_State.connection)
    end

    local function stopESP()
        WeaponESP_State.enabled = false
        removeAllESP()
        WeaponESP_State.connection = nil
    end

    -- Weapon ESP Toggle
    local WeaponESPToggle = VisualsCategory:AddToggle("Weapon ESP", false, function(Value)
        if Value then
            UI:Notify("Visuals", "Weapon ESP started!", 3, "Success")
            WeaponESP_State.enabled = true
            spawn(function()
                startESP()
            end)
        else
            UI:Notify("Visuals", "Weapon ESP stopped!", 2, "Info")
            stopESP()
        end
    end)
    
end

do
    ---------------------------------------------------------------------------------------------
    -- VEHICLE MODIFICATION SYSTEM SCRIPT (Custom Slider Implementation)
    ---------------------------------------------------------------------------------------------
    
    -- State management for vehicle modification
    local VehicleMod_State = {
        -- Current values
        values = {
            acceleration = 8,
            braking = 10,
            deceleration = 1,
            forwardMaxSpeed = 23,
            handBrakeTorque = 20000,
            maxSpeedTorque = 500,
            reverseMaxSpeed = 5
        },
        -- Default values to reset to
        defaults = {
            acceleration = 8,
            braking = 10,
            deceleration = 1,
            forwardMaxSpeed = 23,
            handBrakeTorque = 20000,
            maxSpeedTorque = 500,
            reverseMaxSpeed = 5
        },
        -- Value ranges for sliders [min, max]
        ranges = {
            acceleration = {1, 100},
            braking = {1, 100},
            deceleration = {0.1, 50},
            forwardMaxSpeed = {5, 100},
            handBrakeTorque = {1000, 50000},
            maxSpeedTorque = {100, 2000},
            reverseMaxSpeed = {1, 100}
        },
        -- Store slider references
        sliders = {},
        slidersCreated = false
    }

    -- Custom slider creation function that works with your GUI
    local function createCustomSlider(category, attributeName, minValue, maxValue, currentValue, callback)
        local displayName = attributeName:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
        
        -- Create the main container frame
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Name = attributeName .. "Slider"
        sliderContainer.Size = UDim2.new(1, 0, 0, 45)
        sliderContainer.BackgroundColor3 = UI.Theme.Background
        sliderContainer.BackgroundTransparency = 0.3
        sliderContainer.BorderSizePixel = 0
        sliderContainer.ZIndex = 4
        sliderContainer.LayoutOrder = #category.Items + 1
        sliderContainer.Parent = category.ContentFrame
        
        local sliderCorner = Instance.new("UICorner")
        sliderCorner.CornerRadius = UDim.new(0, 4)
        sliderCorner.Parent = sliderContainer
        
        -- Title label
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(0.6, 0, 0, 20)
        titleLabel.Position = UDim2.new(0, 15, 0, 2)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = displayName
        titleLabel.TextColor3 = UI.Theme.Text
        titleLabel.TextSize = 14
        titleLabel.Font = Enum.Font.SourceSans
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.ZIndex = 5
        titleLabel.Parent = sliderContainer
        
        -- Value display label
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0.35, 0, 0, 20)
        valueLabel.Position = UDim2.new(0.65, 0, 0, 2)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(currentValue)
        valueLabel.TextColor3 = UI.Theme.Primary
        valueLabel.TextSize = 12
        valueLabel.Font = Enum.Font.SourceSansBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.ZIndex = 5
        valueLabel.Parent = sliderContainer
        
        -- Slider track background
        local sliderTrack = Instance.new("Frame")
        sliderTrack.Size = UDim2.new(1, -30, 0, 6)
        sliderTrack.Position = UDim2.new(0, 15, 0, 30)
        sliderTrack.BackgroundColor3 = UI.Theme.Border
        sliderTrack.BorderSizePixel = 0
        sliderTrack.ZIndex = 5
        sliderTrack.Parent = sliderContainer
        
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(0, 3)
        trackCorner.Parent = sliderTrack
        
        -- Slider fill (shows current value)
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new(0, 0, 1, 0)
        sliderFill.Position = UDim2.new(0, 0, 0, 0)
        sliderFill.BackgroundColor3 = UI.Theme.Primary
        sliderFill.BorderSizePixel = 0
        sliderFill.ZIndex = 6
        sliderFill.Parent = sliderTrack
        
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(0, 3)
        fillCorner.Parent = sliderFill
        
        -- Slider handle (draggable circle)
        local sliderHandle = Instance.new("Frame")
        sliderHandle.Size = UDim2.new(0, 16, 0, 16)
        sliderHandle.Position = UDim2.new(0, -8, 0.5, -8)
        sliderHandle.BackgroundColor3 = UI.Theme.Text
        sliderHandle.BorderSizePixel = 0
        sliderHandle.ZIndex = 7
        sliderHandle.Parent = sliderTrack
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(1, 0)
        handleCorner.Parent = sliderHandle
        
        -- Invisible button for interaction
        local interactionButton = Instance.new("TextButton")
        interactionButton.Size = UDim2.new(1, 20, 1, 20)
        interactionButton.Position = UDim2.new(0, -10, 0, -10)
        interactionButton.BackgroundTransparency = 1
        interactionButton.Text = ""
        interactionButton.ZIndex = 8
        interactionButton.Parent = sliderTrack
        
        -- Slider state
        local slider = {
            container = sliderContainer,
            valueLabel = valueLabel,
            fill = sliderFill,
            handle = sliderHandle,
            track = sliderTrack,
            button = interactionButton,
            minValue = minValue,
            maxValue = maxValue,
            currentValue = currentValue,
            dragging = false
        }
        
        -- Function to update slider visual state
        local function updateSlider(value)
            value = math.clamp(value, minValue, maxValue)
            slider.currentValue = value
            
            -- Update value label
            if value >= 1000 then
                valueLabel.Text = string.format("%.0f", value)
            elseif value >= 10 then
                valueLabel.Text = string.format("%.1f", value)
            else
                valueLabel.Text = string.format("%.2f", value)
            end
            
            -- Calculate percentage for visual updates
            local percentage = (value - minValue) / (maxValue - minValue)
            
            -- Update fill width
            UI:Tween(sliderFill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.1)
            
            -- Update handle position
            UI:Tween(sliderHandle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.1)
            
            -- Call the callback
            callback(value)
        end
        
        -- Function to get value from mouse position
        local function getValueFromPosition(mouseX)
            local trackPosition = sliderTrack.AbsolutePosition.X
            local trackSize = sliderTrack.AbsoluteSize.X
            local relativeX = mouseX - trackPosition
            local percentage = math.clamp(relativeX / trackSize, 0, 1)
            return minValue + (maxValue - minValue) * percentage
        end
        
        -- Mouse interaction handlers
        local dragging = false
        
        interactionButton.MouseButton1Down:Connect(function()
            dragging = true
            slider.dragging = true
        end)
        
        interactionButton.MouseButton1Up:Connect(function()
            dragging = false
            slider.dragging = false
        end)
        
        -- Handle mouse movement
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local newValue = getValueFromPosition(input.Position.X)
                updateSlider(newValue)
            end
        end)
        
        -- Handle mouse release anywhere
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                slider.dragging = false
            end
        end)
        
        -- Click to set position
        interactionButton.MouseButton1Click:Connect(function()
            if not slider.dragging then
                local mouse = LocalPlayer:GetMouse()
                local newValue = getValueFromPosition(mouse.X)
                updateSlider(newValue)
            end
        end)
        
        -- Hover effects
        interactionButton.MouseEnter:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.1}, UI.Animations.Fast)
            UI:Tween(sliderHandle, {Size = UDim2.new(0, 18, 0, 18)}, UI.Animations.Fast)
        end)
        
        interactionButton.MouseLeave:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.3}, UI.Animations.Fast)
            if not slider.dragging then
                UI:Tween(sliderHandle, {Size = UDim2.new(0, 16, 0, 16)}, UI.Animations.Fast)
            end
        end)
        
        -- Set initial position
        updateSlider(currentValue)
        
        -- Add to category items
        table.insert(category.Items, sliderContainer)
        
        return slider
    end

    -- Function to create all vehicle sliders
    local function createVehicleSliders()
        if VehicleMod_State.slidersCreated then return end
        
        local attributeOrder = {"acceleration", "braking", "deceleration", "forwardMaxSpeed", "handBrakeTorque", "maxSpeedTorque", "reverseMaxSpeed"}
        
        for _, attributeName in ipairs(attributeOrder) do
            local range = VehicleMod_State.ranges[attributeName]
            local currentValue = VehicleMod_State.values[attributeName]
            
            local slider = createCustomSlider(
                VehiclesCategory,
                attributeName,
                range[1],
                range[2],
                currentValue,
                function(value)
                    VehicleMod_State.values[attributeName] = value
                    -- Optional: Show notification on value change
                    -- UI:Notify("Vehicle", attributeName .. ": " .. tostring(value), 0.5, "Info")
                end
            )
            
            VehicleMod_State.sliders[attributeName] = slider
        end
        
        VehicleMod_State.slidersCreated = true
    end

    -- Create the sliders
    createVehicleSliders()

    -- Reset All Values Button (positioned directly under sliders)
    VehiclesCategory:AddButton("Reset All to Defaults", function()
        for attributeName, defaultValue in pairs(VehicleMod_State.defaults) do
            VehicleMod_State.values[attributeName] = defaultValue
            
            -- Update the slider visual
            if VehicleMod_State.sliders[attributeName] then
                local slider = VehicleMod_State.sliders[attributeName]
                local percentage = (defaultValue - slider.minValue) / (slider.maxValue - slider.minValue)
                
                -- Update value label
                if defaultValue >= 1000 then
                    slider.valueLabel.Text = string.format("%.0f", defaultValue)
                elseif defaultValue >= 10 then
                    slider.valueLabel.Text = string.format("%.1f", defaultValue)
                else
                    slider.valueLabel.Text = string.format("%.2f", defaultValue)
                end
                
                -- Update fill and handle
                UI:Tween(slider.fill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.2)
                UI:Tween(slider.handle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.2)
            end
        end
        
        UI:Notify("Vehicle", "All values reset to defaults!", 2, "Success")
    end)

    -- Apply Changes Button (positioned directly under reset button)
    VehiclesCategory:AddButton("Apply Motor Changes", function()
        local vehiclesFolder = workspace:FindFirstChild("Vehicles")
        if not vehiclesFolder then
            UI:Notify("Vehicle", "No Vehicles folder found in workspace!", 3, "Error")
            return
        end
        
        local motorsChanged = 0
        
        -- Function to update a single object's attributes
        local function updateObjectAttributes(obj)
            for attributeName, value in pairs(VehicleMod_State.values) do
                if obj:GetAttribute(attributeName) ~= nil then
                    obj:SetAttribute(attributeName, value)
                    motorsChanged = motorsChanged + 1
                end
            end
        end
        
        -- Function to recursively process objects
        local function processObject(obj)
            updateObjectAttributes(obj)
            for _, child in pairs(obj:GetChildren()) do
                processObject(child)
            end
        end
        
        -- Process all vehicles
        for _, vehicle in pairs(vehiclesFolder:GetChildren()) do
            if vehicle:IsA("Model") or vehicle:IsA("Folder") then
                processObject(vehicle)
            end
        end
        
        -- Check for Motors folder (backward compatibility)
        local motorsFolder = vehiclesFolder:FindFirstChild("Motors")
        if motorsFolder then
            for _, motor in pairs(motorsFolder:GetChildren()) do
                updateObjectAttributes(motor)
            end
        end
        
        UI:Notify("Vehicle", "Motor changes applied! Updated " .. motorsChanged .. " attributes.", 3, "Success")
    end)
    
end

do
    ---------------------------------------------------------------------------------------------
    -- SPEED BOOST RUNNING SCRIPT (Phantom GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    -- Consolidated state management for speed boost
    local SpeedBoost_State = {
        enabled = false,
        connection = nil,
        spamConnection = nil
    }

    local function enableAutoSprint()
        if not LocalPlayer.Character then return end
        
        -- Wait for game systems to fully load
        wait(2)
        
        SpeedBoost_State.connection = game:GetService("RunService").Heartbeat:Connect(function()
            if not LocalPlayer.Character then
                if SpeedBoost_State.connection then
                    SpeedBoost_State.connection:Disconnect()
                    SpeedBoost_State.connection = nil
                end
                return
            end
            
            if SpeedBoost_State.enabled then
                -- Check if player is moving
                local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                    
                    -- Set speed multiplier for 21 speed (16 * 1.3125 = 21)
                    LocalPlayer:SetAttribute("SpeedMultiplier", 1.3125)
                    
                    -- Try to access the keybind system to simulate sprint key press
                    local success = pcall(function()
                        local keybindModule = require(game.ReplicatedStorage.Modules.Game.Keybinds)
                        
                        -- Simulate holding the sprint key
                        if keybindModule.hook_action then
                            -- Force the sprint action to be active
                            keybindModule.hook_action("sprint", function()
                                return true -- Always return true (sprint key pressed)
                            end)
                        end
                    end)
                    
                    -- Also try to maintain the sprint state directly
                    pcall(function()
                        local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                        if sprintModule.sprinting and sprintModule.sprinting.get() == false then
                            sprintModule.sprinting.set(true)
                        end
                        
                        -- Keep stamina topped up
                        if sprintModule.sprint_bar then
                            sprintModule.sprint_bar.set(1)
                        end
                    end)
                else
                    -- Reset speed multiplier when not moving
                    LocalPlayer:SetAttribute("SpeedMultiplier", 1)
                end
            end
        end)
    end

    local function startSprintSpam()
        -- The working shift spam exploit - every 0.5 seconds
        SpeedBoost_State.spamConnection = spawn(function()
            while SpeedBoost_State.enabled do
                wait(0.5) -- Every 0.5 seconds
                
                if SpeedBoost_State.enabled and LocalPlayer.Character then
                    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.MoveDirection.Magnitude > 0.1 then
                        pcall(function()
                            local sprintModule = require(game.ReplicatedStorage.Modules.Game.Sprint)
                            
                            -- Directly call the sprinting state toggle like the real shift key does
                            if sprintModule.sprinting then
                                -- Simulate a quick sprint toggle (like tapping shift)
                                sprintModule.sprinting.set(false) -- Turn off
                                wait(0.05) -- Brief pause
                                sprintModule.sprinting.set(true)  -- Turn back on
                            end
                        end)
                    end
                end
            end
        end)
    end

    local function stopAutoSprint()
        if SpeedBoost_State.connection then
            SpeedBoost_State.connection:Disconnect()
            SpeedBoost_State.connection = nil
        end
        -- spamConnection doesn't need to be disconnected since it's a spawn() thread
        SpeedBoost_State.spamConnection = nil
        -- Reset speed when disabled
        if LocalPlayer then
            LocalPlayer:SetAttribute("SpeedMultiplier", 1)
        end
    end

    -- Apply to current and future characters
    local function setupCharacter()
        if SpeedBoost_State.enabled then
            enableAutoSprint()
        end
    end

    if LocalPlayer.Character then
        setupCharacter()
    end

    LocalPlayer.CharacterAdded:Connect(function()
        wait(3)
        setupCharacter()
    end)

    -- Phantom GUI Integration
    local SuperSpeedToggle = PlayerCategory:AddToggle("Super Speed", false, function(Value)
        SpeedBoost_State.enabled = Value
        
        if SpeedBoost_State.enabled then
            UI:Notify("Player", "Super Speed enabled!", 3, "Success")
            -- Start the auto sprint system
            if LocalPlayer.Character then
                enableAutoSprint()
            end
            startSprintSpam()
        else
            UI:Notify("Player", "Super Speed disabled!", 2, "Info")
            -- Stop the auto sprint system
            stopAutoSprint()
        end
    end)
    
end

do
    ---------------------------------------------------------------------------------------------
    -- SUPER JUMP SCRIPT (Phantom GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    -- Consolidated state management for super jump
    local SuperJump_State = {
        enabled = false
    }

    local function updateJumpPower(character, enabled)
        local humanoid = character:WaitForChild("Humanoid", 10)
        if not humanoid then
            return
        end
        
        if enabled then
            -- Enable UseJumpPower (this makes JumpPower work instead of JumpHeight)
            humanoid.UseJumpPower = true
            
            -- Set JumpPower to 65
            humanoid.JumpPower = 65
        else
            -- Reset to default values
            humanoid.UseJumpPower = true -- Keep this true but reset power
            humanoid.JumpPower = 23 -- Default jump power (changed from 50 to 23)
        end
    end

    local function setupCharacter(character)
        updateJumpPower(character, SuperJump_State.enabled)
    end

    -- Apply to current character if it exists
    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end

    -- Apply to future characters when they spawn
    LocalPlayer.CharacterAdded:Connect(setupCharacter)

    -- Phantom GUI Integration
    local SuperJumpToggle = PlayerCategory:AddToggle("Super Jump", false, function(Value)
        SuperJump_State.enabled = Value
        
        if SuperJump_State.enabled then
            UI:Notify("Player", "Super Jump enabled! (Jump Power: 65)", 3, "Success")
        else
            UI:Notify("Player", "Super Jump disabled! (Jump Power: 23)", 2, "Info")
        end
        
        -- Apply to current character if it exists
        if LocalPlayer.Character then
            updateJumpPower(LocalPlayer.Character, SuperJump_State.enabled)
        end
    end)
    
end


do
    ---------------------------------------------------------------------------------------------
    -- WEAPON MODIFICATION SYSTEM SCRIPT (Sliders + Working Buttons)
    ---------------------------------------------------------------------------------------------
    
    -- Full state management with weapon configs
    local WeaponMod_State = {
        attributeMultipliers = {
            accuracy = 1,
            fireRate = 1,
            magSize = 1,
            range = 1,
            recoil = 1,
            reloadTime = 1
        },
        defaults = {
            accuracy = 1,
            fireRate = 1,
            magSize = 1,
            range = 1,
            recoil = 1,
            reloadTime = 1
        },
        ranges = {
            accuracy = {0.1, 1},
            fireRate = {1, 1000},
            magSize = {1, 1000},
            range = {1, 1000},
            recoil = {0, 2},
            reloadTime = {0, 2}
        },
        sliders = {},
        gunConfigs = {
            ["G3"] = {
                modifications = {
                    {original = 0.65, target = 1, type = "accuracy"},
                    {original = 320, target = 1000, type = "fireRate"},
                    {original = 10, target = 1000, type = "magSize"},
                    {original = 80, target = 1000, type = "range"},
                    {original = 0.2, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["AK47"] = {
                modifications = {
                    {original = 0.85, target = 1, type = "accuracy"},
                    {original = 600, target = 1000, type = "fireRate"},
                    {original = 30, target = 1000, type = "magSize"},
                    {original = 300, target = 1000, type = "range"},
                    {original = 0.4, target = 0, type = "recoil"},
                    {original = 2.2, target = 0, type = "reloadTime"}
                }
            },
            ["Anaconda"] = {
                modifications = {
                    {original = 0.95, target = 1, type = "accuracy"},
                    {original = 80, target = 1000, type = "fireRate"},
                    {original = 6, target = 1000, type = "magSize"},
                    {original = 120, target = 1000, type = "range"},
                    {original = 0.8, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["C9"] = {
                modifications = {
                    {original = 0.7, target = 1, type = "accuracy"},
                    {original = 300, target = 1000, type = "fireRate"},
                    {original = 8, target = 1000, type = "magSize"},
                    {original = 80, target = 1000, type = "range"},
                    {original = 0.2, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["Crossbow"] = {
                modifications = {
                    {original = 0.95, target = 1, type = "accuracy"},
                    {original = 100, target = 1000, type = "fireRate"},
                    {original = 1, target = 1000, type = "magSize"},
                    {original = 500, target = 1000, type = "range"},
                    {original = 0.3, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["Double Barrel"] = {
                modifications = {
                    {original = 0.5, target = 1, type = "accuracy"},
                    {original = 100, target = 1000, type = "fireRate"},
                    {original = 2, target = 1000, type = "magSize"},
                    {original = 50, target = 1000, type = "range"},
                    {original = 2, target = 0, type = "recoil"},
                    {original = 3, target = 0, type = "reloadTime"}
                }
            },
            ["Draco"] = {
                modifications = {
                    {original = 0.75, target = 1, type = "accuracy"},
                    {original = 900, target = 1000, type = "fireRate"},
                    {original = 25, target = 1000, type = "magSize"},
                    {original = 250, target = 1000, type = "range"},
                    {original = 0.5, target = 0, type = "recoil"},
                    {original = 2.2, target = 0, type = "reloadTime"}
                }
            },
            ["Firework Launcher"] = {
                modifications = {
                    {original = 0.8, target = 1, type = "accuracy"},
                    {original = 100, target = 1000, type = "fireRate"},
                    {original = 1, target = 1000, type = "magSize"},
                    {original = 500, target = 1000, type = "range"},
                    {original = 1, target = 0, type = "recoil"},
                    {original = 0.9, target = 0, type = "reloadTime"}
                }
            },
            ["Glock"] = {
                modifications = {
                    {original = 0.8, target = 1, type = "accuracy"},
                    {original = 370, target = 1000, type = "fireRate"},
                    {original = 15, target = 1000, type = "magSize"},
                    {original = 80, target = 1000, type = "range"},
                    {original = 0.2, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["Hunting Rifle"] = {
                modifications = {
                    {original = 0.93, target = 1, type = "accuracy"},
                    {original = 50, target = 1000, type = "fireRate"},
                    {original = 5, target = 1000, type = "magSize"},
                    {original = 500, target = 1000, type = "range"},
                    {original = 0.8, target = 0, type = "recoil"},
                    {original = 2.2, target = 0, type = "reloadTime"}
                }
            },
            ["M24"] = {
                modifications = {
                    {original = 0.97, target = 1, type = "accuracy"},
                    {original = 50, target = 1000, type = "fireRate"},
                    {original = 7, target = 1000, type = "magSize"},
                    {original = 500, target = 1000, type = "range"},
                    {original = 0.8, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["MP5"] = {
                modifications = {
                    {original = 0.85, target = 1, type = "accuracy"},
                    {original = 800, target = 1000, type = "fireRate"},
                    {original = 30, target = 1000, type = "magSize"},
                    {original = 200, target = 1000, type = "range"},
                    {original = 0.35, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["P226"] = {
                modifications = {
                    {original = 0.75, target = 1, type = "accuracy"},
                    {original = 370, target = 1000, type = "fireRate"},
                    {original = 7, target = 1000, type = "magSize"},
                    {original = 80, target = 1000, type = "range"},
                    {original = 0.25, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["RPG"] = {
                modifications = {
                    {original = 0.9, target = 1, type = "accuracy"},
                    {original = 100, target = 1000, type = "fireRate"},
                    {original = 1, target = 1000, type = "magSize"},
                    {original = 600, target = 1000, type = "range"},
                    {original = 2, target = 0, type = "recoil"},
                    {original = 2.6, target = 0, type = "reloadTime"}
                }
            },
            ["Remington"] = {
                modifications = {
                    {original = 0.6, target = 1, type = "accuracy"},
                    {original = 80, target = 1000, type = "fireRate"},
                    {original = 5, target = 1000, type = "magSize"},
                    {original = 80, target = 1000, type = "range"},
                    {original = 1.5, target = 0, type = "recoil"},
                    {original = 2, target = 0, type = "reloadTime"}
                }
            },
            ["Sawnoff"] = {
                modifications = {
                    {original = 0.4, target = 1, type = "accuracy"},
                    {original = 150, target = 1000, type = "fireRate"},
                    {original = 2, target = 1000, type = "magSize"},
                    {original = 30, target = 1000, type = "range"},
                    {original = 3, target = 0, type = "recoil"},
                    {original = 3, target = 0, type = "reloadTime"}
                }
            },
            ["Uzi"] = {
                modifications = {
                    {original = 0.7, target = 1, type = "accuracy"},
                    {original = 1200, target = 1000, type = "fireRate"},
                    {original = 20, target = 1000, type = "magSize"},
                    {original = 150, target = 1000, type = "range"},
                    {original = 0.3, target = 0, type = "recoil"},
                    {original = 1.7, target = 0, type = "reloadTime"}
                }
            }
        }
    }

    -- Weapon modification functions
    function ModifyGunAttributes(tool)
        if not tool then return end
        
        local gunConfig = WeaponMod_State.gunConfigs[tool.Name]
        if not gunConfig then return end
        
        wait(0.1)
        
        for _, modification in ipairs(gunConfig.modifications) do
            for attrName, attrValue in pairs(tool:GetAttributes()) do
                if type(attrValue) == "number" then
                    if math.abs(attrValue - modification.original) < 0.01 then
                        tool:SetAttribute(attrName, modification.target * WeaponMod_State.attributeMultipliers[modification.type])
                    end
                end
            end
        end
    end

    function ModifyExistingGuns()
        if not LocalPlayer.Character then return end
        
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                ModifyGunAttributes(item)
            end
        end
        
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") then
                ModifyGunAttributes(item)
            end
        end
    end

    -- Make functions global so buttons can access them
    getgenv().WeaponMod_State = WeaponMod_State
    getgenv().ModifyExistingGuns = ModifyExistingGuns

    -- Custom slider creation function (same as before)
    local function createCustomSlider(category, attributeName, minValue, maxValue, currentValue, callback)
        local displayName = attributeName:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
        
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Name = attributeName .. "Slider"
        sliderContainer.Size = UDim2.new(1, 0, 0, 45)
        sliderContainer.BackgroundColor3 = UI.Theme.Background
        sliderContainer.BackgroundTransparency = 0.3
        sliderContainer.BorderSizePixel = 0
        sliderContainer.ZIndex = 4
        sliderContainer.LayoutOrder = #category.Items + 1
        sliderContainer.Parent = category.ContentFrame
        
        local sliderCorner = Instance.new("UICorner")
        sliderCorner.CornerRadius = UDim.new(0, 4)
        sliderCorner.Parent = sliderContainer
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(0.6, 0, 0, 20)
        titleLabel.Position = UDim2.new(0, 15, 0, 2)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = displayName
        titleLabel.TextColor3 = UI.Theme.Text
        titleLabel.TextSize = 14
        titleLabel.Font = Enum.Font.SourceSans
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.ZIndex = 5
        titleLabel.Parent = sliderContainer
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0.35, 0, 0, 20)
        valueLabel.Position = UDim2.new(0.65, 0, 0, 2)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(currentValue)
        valueLabel.TextColor3 = UI.Theme.Primary
        valueLabel.TextSize = 12
        valueLabel.Font = Enum.Font.SourceSansBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.ZIndex = 5
        valueLabel.Parent = sliderContainer
        
        local sliderTrack = Instance.new("Frame")
        sliderTrack.Size = UDim2.new(1, -30, 0, 6)
        sliderTrack.Position = UDim2.new(0, 15, 0, 30)
        sliderTrack.BackgroundColor3 = UI.Theme.Border
        sliderTrack.BorderSizePixel = 0
        sliderTrack.ZIndex = 5
        sliderTrack.Parent = sliderContainer
        
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(0, 3)
        trackCorner.Parent = sliderTrack
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new(0, 0, 1, 0)
        sliderFill.Position = UDim2.new(0, 0, 0, 0)
        sliderFill.BackgroundColor3 = UI.Theme.Primary
        sliderFill.BorderSizePixel = 0
        sliderFill.ZIndex = 6
        sliderFill.Parent = sliderTrack
        
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(0, 3)
        fillCorner.Parent = sliderFill
        
        local sliderHandle = Instance.new("Frame")
        sliderHandle.Size = UDim2.new(0, 16, 0, 16)
        sliderHandle.Position = UDim2.new(0, -8, 0.5, -8)
        sliderHandle.BackgroundColor3 = UI.Theme.Text
        sliderHandle.BorderSizePixel = 0
        sliderHandle.ZIndex = 7
        sliderHandle.Parent = sliderTrack
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(1, 0)
        handleCorner.Parent = sliderHandle
        
        local interactionButton = Instance.new("TextButton")
        interactionButton.Size = UDim2.new(1, 20, 1, 20)
        interactionButton.Position = UDim2.new(0, -10, 0, -10)
        interactionButton.BackgroundTransparency = 1
        interactionButton.Text = ""
        interactionButton.ZIndex = 8
        interactionButton.Parent = sliderTrack
        
        local slider = {
            container = sliderContainer,
            valueLabel = valueLabel,
            fill = sliderFill,
            handle = sliderHandle,
            track = sliderTrack,
            button = interactionButton,
            minValue = minValue,
            maxValue = maxValue,
            currentValue = currentValue,
            dragging = false
        }
        
        local function updateSlider(value)
            value = math.clamp(value, minValue, maxValue)
            slider.currentValue = value
            
            if value >= 100 then
                valueLabel.Text = string.format("%.0f", value)
            elseif value >= 1 then
                valueLabel.Text = string.format("%.1f", value)
            else
                valueLabel.Text = string.format("%.2f", value)
            end
            
            local percentage = (value - minValue) / (maxValue - minValue)
            
            UI:Tween(sliderFill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.1)
            UI:Tween(sliderHandle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.1)
            
            callback(value)
        end
        
        local function getValueFromPosition(mouseX)
            local trackPosition = sliderTrack.AbsolutePosition.X
            local trackSize = sliderTrack.AbsoluteSize.X
            local relativeX = mouseX - trackPosition
            local percentage = math.clamp(relativeX / trackSize, 0, 1)
            return minValue + (maxValue - minValue) * percentage
        end
        
        local dragging = false
        
        interactionButton.MouseButton1Down:Connect(function()
            dragging = true
            slider.dragging = true
        end)
        
        interactionButton.MouseButton1Up:Connect(function()
            dragging = false
            slider.dragging = false
        end)
        
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local newValue = getValueFromPosition(input.Position.X)
                updateSlider(newValue)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                slider.dragging = false
            end
        end)
        
        interactionButton.MouseButton1Click:Connect(function()
            if not slider.dragging then
                local mouse = LocalPlayer:GetMouse()
                local newValue = getValueFromPosition(mouse.X)
                updateSlider(newValue)
            end
        end)
        
        interactionButton.MouseEnter:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.1}, UI.Animations.Fast)
            UI:Tween(sliderHandle, {Size = UDim2.new(0, 18, 0, 18)}, UI.Animations.Fast)
        end)
        
        interactionButton.MouseLeave:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.3}, UI.Animations.Fast)
            if not slider.dragging then
                UI:Tween(sliderHandle, {Size = UDim2.new(0, 16, 0, 16)}, UI.Animations.Fast)
            end
        end)
        
        updateSlider(currentValue)
        table.insert(category.Items, sliderContainer)
        
        return slider
    end

    -- Create sliders
    local attributeOrder = {"accuracy", "fireRate", "magSize", "range", "recoil", "reloadTime"}
    
    for _, attributeName in ipairs(attributeOrder) do
        local range = WeaponMod_State.ranges[attributeName]
        local currentValue = WeaponMod_State.attributeMultipliers[attributeName]
        
        local slider = createCustomSlider(
            WeaponsCategory,
            attributeName,
            range[1],
            range[2],
            currentValue,
            function(value)
                getgenv().WeaponMod_State.attributeMultipliers[attributeName] = value
            end
        )
        
        getgenv().WeaponMod_State.sliders[attributeName] = slider
    end
    

end

-- Create buttons OUTSIDE the do block with FULL functionality


-- Reset All Values Button
WeaponsCategory:AddButton("Reset All to Defaults", function()
    for attributeName, defaultValue in pairs(getgenv().WeaponMod_State.defaults) do
        getgenv().WeaponMod_State.attributeMultipliers[attributeName] = defaultValue
        
        -- Update the slider visual
        if getgenv().WeaponMod_State.sliders[attributeName] then
            local slider = getgenv().WeaponMod_State.sliders[attributeName]
            local percentage = (defaultValue - slider.minValue) / (slider.maxValue - slider.minValue)
            
            -- Update value label
            if defaultValue >= 100 then
                slider.valueLabel.Text = string.format("%.0f", defaultValue)
            elseif defaultValue >= 1 then
                slider.valueLabel.Text = string.format("%.1f", defaultValue)
            else
                slider.valueLabel.Text = string.format("%.2f", defaultValue)
            end
            
            -- Update fill and handle
            UI:Tween(slider.fill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.2)
            UI:Tween(slider.handle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.2)
        end
    end
    
    UI:Notify("Weapons", "All values reset to defaults!", 2, "Success")
end)

-- Apply Weapon Changes Button  
WeaponsCategory:AddButton("Apply Weapon Changes", function()
    local weaponsModified = 0
    
    -- Count and modify weapons in character
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and getgenv().WeaponMod_State.gunConfigs[item.Name] then
                getgenv().ModifyGunAttributes(item)
                weaponsModified = weaponsModified + 1
            end
        end
    end
    
    -- Count and modify weapons in backpack
    for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
        if item:IsA("Tool") and getgenv().WeaponMod_State.gunConfigs[item.Name] then
            getgenv().ModifyGunAttributes(item)
            weaponsModified = weaponsModified + 1
        end
    end
    
    UI:Notify("Weapons", "Weapon changes applied! Modified " .. weaponsModified .. " weapons.", 3, "Success")
end)


do
    ---------------------------------------------------------------------------------------------
    -- AUTO RESPAWN SYSTEM SCRIPT (Phantom GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    -- Consolidated state management for auto respawn
    local AutoRespawn_State = {
        enabled = false,
        isRespawning = false,
        connections = {}
    }

    -- Function to find and click the respawn button
    local function clickRespawnButton()
        if AutoRespawn_State.isRespawning or not AutoRespawn_State.enabled then return end
        AutoRespawn_State.isRespawning = true
        
        pcall(function()
            local playerGui = LocalPlayer.PlayerGui
            local deathScreen = playerGui:FindFirstChild("DeathScreen")
            
            if deathScreen then
                local deathScreenHolder = deathScreen:FindFirstChild("DeathScreenHolder")
                if deathScreenHolder then
                    local frame = deathScreenHolder:FindFirstChild("Frame")
                    if frame then
                        local respawnButtonFrame = frame:FindFirstChild("RespawnButtonFrame")
                        if respawnButtonFrame then
                            local respawnButton = respawnButtonFrame:FindFirstChild("RespawnButton")
                            if respawnButton and respawnButton.Visible and respawnButton.Parent.Visible then
                                -- Multiple click methods to ensure it works
                                
                                -- Method 1: Fire the click event
                                for _, connection in pairs(getconnections(respawnButton.MouseButton1Click)) do
                                    connection:Fire()
                                end
                                
                                -- Method 2: Use GuiService
                                game:GetService("GuiService"):FireClick(respawnButton)
                                
                                -- Method 3: Simulate mouse click
                                local VirtualInputManager = game:GetService("VirtualInputManager")
                                local buttonPos = respawnButton.AbsolutePosition
                                local buttonSize = respawnButton.AbsoluteSize
                                local centerX = buttonPos.X + buttonSize.X/2
                                local centerY = buttonPos.Y + buttonSize.Y/2
                                
                                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                                VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                                
                                return true
                            end
                        end
                    end
                end
            end
        end)
        
        AutoRespawn_State.isRespawning = false
        return false
    end

    -- Continuous monitoring function
    local function startAutoRespawn()
        if AutoRespawn_State.connections.heartbeat then 
            AutoRespawn_State.connections.heartbeat:Disconnect() 
        end
        
        AutoRespawn_State.connections.heartbeat = game:GetService("RunService").Heartbeat:Connect(function()
            if not AutoRespawn_State.enabled then return end
            
            if LocalPlayer.Character == nil or 
               (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Health <= 0) then
                
                if clickRespawnButton() then
                    wait(2) -- Wait before checking again
                end
            end
        end)
    end

    -- Monitor for death screen appearance
    local function monitorDeathScreen()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        
        if AutoRespawn_State.connections.deathScreen then 
            AutoRespawn_State.connections.deathScreen:Disconnect() 
        end
        
        -- Watch for DeathScreen being added
        AutoRespawn_State.connections.deathScreen = playerGui.ChildAdded:Connect(function(child)
            if child.Name == "DeathScreen" and AutoRespawn_State.enabled then
                wait(0.1) -- Small delay for GUI to load
                
                spawn(function()
                    for attempts = 1, 50 do -- Try for 5 seconds
                        if not (child.Parent and AutoRespawn_State.enabled) then break end
                        if clickRespawnButton() then break end
                        wait(0.1)
                    end
                end)
            end
        end)
    end

    -- Monitor humanoid death
    local function setupDeathMonitoring()
        local function connectCharacterDeath(character)
            table.insert(AutoRespawn_State.connections, character:WaitForChild("Humanoid").Died:Connect(function()
                if not AutoRespawn_State.enabled then return end
                wait(0.5) -- Wait for death screen
                
                -- Keep trying to click respawn button
                spawn(function()
                    for i = 1, 30 do -- Try for 3 seconds
                        if not AutoRespawn_State.enabled then break end
                        if clickRespawnButton() then break end
                        wait(0.1)
                    end
                end)
            end))
        end
        
        if AutoRespawn_State.connections.characterAdded then 
            AutoRespawn_State.connections.characterAdded:Disconnect() 
        end
        
        AutoRespawn_State.connections.characterAdded = LocalPlayer.CharacterAdded:Connect(connectCharacterDeath)
        
        -- Setup for current character if it exists
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            connectCharacterDeath(LocalPlayer.Character)
        end
    end

    -- Function to enable auto respawn
    local function enableAutoRespawn()
        AutoRespawn_State.enabled = true
        monitorDeathScreen()
        setupDeathMonitoring()
        startAutoRespawn()
    end

    -- Function to disable auto respawn
    local function disableAutoRespawn()
        AutoRespawn_State.enabled = false
        
        -- Disconnect all connections
        for _, connection in pairs(AutoRespawn_State.connections) do
            if connection and connection.Disconnect then
                connection:Disconnect()
            end
        end
        AutoRespawn_State.connections = {}
    end

    -- Make functions global so button can access them
    getgenv().AutoRespawn_State = AutoRespawn_State
    getgenv().enableAutoRespawn = enableAutoRespawn
    getgenv().disableAutoRespawn = disableAutoRespawn

end

-- Auto Respawn Toggle (positioned in Player category)
PlayerCategory:AddToggle("Auto Respawn", false, function(Value)
    if Value then
        getgenv().enableAutoRespawn()
        UI:Notify("Player", "Auto Respawn enabled! You will automatically respawn when you die.", 3, "Success")
    else
        getgenv().disableAutoRespawn()
        UI:Notify("Player", "Auto Respawn disabled!", 2, "Info")
    end
end)


do
    ---------------------------------------------------------------------------------------------
    -- AIMBOT SYSTEM SCRIPT (Phantom GUI Compatible)
    ---------------------------------------------------------------------------------------------
    
    -- Consolidated state management for aimbot
    local Aimbot_State = {
        config = {
            LOCK_DISTANCE = 10000,
            CAMERA_HEIGHT_OFFSET = 0.5,
            FOV_RADIUS = 200,
            SHOW_FOV_CIRCLE = true,
            WHITELIST = {},
            WHITELISTED_PLAYERS = {},
            AIMBOT_ENABLED = false,
            wasLeftControlDown = false
        },
        currentTarget = nil,
        fovCircle = nil,
        aimConnection = nil,
        sliders = {},
        slidersCreated = false
    }

    -- Core Functions
    local function updatePlayerList()
        local names = {}
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= LocalPlayer then table.insert(names, p.Name) end
        end
        return names
    end

    local function cleanWhitelist()
        local current = {}
        for _, p in pairs(game.Players:GetPlayers()) do current[p.Name] = true end
        for name, _ in pairs(Aimbot_State.config.WHITELIST) do
            if not current[name] then
                Aimbot_State.config.WHITELIST[name] = nil
            end
        end
    end

    local function createDrawings()
        if Aimbot_State.fovCircle then Aimbot_State.fovCircle:Destroy() end
        
        Aimbot_State.fovCircle = Drawing.new("Circle")
        Aimbot_State.fovCircle.Radius = Aimbot_State.config.FOV_RADIUS
        Aimbot_State.fovCircle.Color = Color3.new(1, 1, 1)
        Aimbot_State.fovCircle.Transparency = 0.5
        Aimbot_State.fovCircle.Visible = false
        Aimbot_State.fovCircle.Thickness = 2
        Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
    end

    local function updateVisuals()
        if Aimbot_State.fovCircle then
            Aimbot_State.fovCircle.Visible = Aimbot_State.config.SHOW_FOV_CIRCLE and Aimbot_State.config.AIMBOT_ENABLED
            Aimbot_State.fovCircle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        end
    end

    local function isInFOV(target)
        local char = LocalPlayer.Character
        if not char or not target.Character then return false end
        
        local head = target.Character:FindFirstChild("Head")
        if not head then return false end
        
        local center = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        local screen = workspace.CurrentCamera:WorldToScreenPoint(head.Position)
        local dist = (Vector2.new(screen.X, screen.Y) - center).Magnitude
        
        return dist <= Aimbot_State.config.FOV_RADIUS
    end

    local function isVisible(char)
        if not char or not LocalPlayer.Character then return false end
        
        local head = char:FindFirstChild("Head")
        local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not head or not root then return false end
        
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.FilterDescendantsInstances = {LocalPlayer.Character}
        
        local result = workspace:Raycast(root.Position, 
            (head.Position - root.Position).Unit * Aimbot_State.config.LOCK_DISTANCE, params)
        
        return result == nil or result.Instance:IsDescendantOf(char)
    end

    local function findTarget()
        local char = LocalPlayer.Character
        if not char then return nil end
        
        local root = char:FindFirstChild("HumanoidRootPart")
        if not root then return nil end
        
        local closest = nil
        local shortest = Aimbot_State.config.LOCK_DISTANCE
        
        for _, p in pairs(game.Players:GetPlayers()) do
            if p ~= LocalPlayer and not Aimbot_State.config.WHITELIST[p.Name] then
                local pChar = p.Character
                local pRoot = pChar and pChar:FindFirstChild("HumanoidRootPart")
                
                if pRoot then
                    local dist = (pRoot.Position - root.Position).Magnitude
                    if dist < shortest and isVisible(pChar) and isInFOV(p) then
                        closest = p
                        shortest = dist
                    end
                end
            end
        end
        
        return closest
    end

    local function aimNormal(target)
        -- Clear any existing target and connection
        if Aimbot_State.currentTarget then
            Aimbot_State.currentTarget = nil
        end
        if Aimbot_State.aimConnection then
            Aimbot_State.aimConnection:Disconnect()
            Aimbot_State.aimConnection = nil
        end
        
        Aimbot_State.currentTarget = target
        
        Aimbot_State.aimConnection = game:GetService("RunService").RenderStepped:Connect(function()
            if not Aimbot_State.config.AIMBOT_ENABLED or 
               not game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftControl) or
               not Aimbot_State.currentTarget or not Aimbot_State.currentTarget.Character or
               not Aimbot_State.currentTarget.Character:FindFirstChild("Head") then
                
                if Aimbot_State.aimConnection then
                    Aimbot_State.aimConnection:Disconnect()
                    Aimbot_State.aimConnection = nil
                end
                Aimbot_State.currentTarget = nil
                return
            end
            
            workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.CFrame.Position, 
                Aimbot_State.currentTarget.Character.Head.Position + Vector3.new(0, Aimbot_State.config.CAMERA_HEIGHT_OFFSET, 0))
        end)
    end

    -- Custom slider creation function
    local function createCustomSlider(category, attributeName, minValue, maxValue, currentValue, callback)
        local displayName = attributeName:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
        
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Name = attributeName .. "Slider"
        sliderContainer.Size = UDim2.new(1, 0, 0, 45)
        sliderContainer.BackgroundColor3 = UI.Theme.Background
        sliderContainer.BackgroundTransparency = 0.3
        sliderContainer.BorderSizePixel = 0
        sliderContainer.ZIndex = 4
        sliderContainer.LayoutOrder = #category.Items + 1
        sliderContainer.Parent = category.ContentFrame
        
        local sliderCorner = Instance.new("UICorner")
        sliderCorner.CornerRadius = UDim.new(0, 4)
        sliderCorner.Parent = sliderContainer
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(0.6, 0, 0, 20)
        titleLabel.Position = UDim2.new(0, 15, 0, 2)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = displayName
        titleLabel.TextColor3 = UI.Theme.Text
        titleLabel.TextSize = 14
        titleLabel.Font = Enum.Font.SourceSans
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.ZIndex = 5
        titleLabel.Parent = sliderContainer
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0.35, 0, 0, 20)
        valueLabel.Position = UDim2.new(0.65, 0, 0, 2)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(currentValue)
        valueLabel.TextColor3 = UI.Theme.Primary
        valueLabel.TextSize = 12
        valueLabel.Font = Enum.Font.SourceSansBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.ZIndex = 5
        valueLabel.Parent = sliderContainer
        
        local sliderTrack = Instance.new("Frame")
        sliderTrack.Size = UDim2.new(1, -30, 0, 6)
        sliderTrack.Position = UDim2.new(0, 15, 0, 30)
        sliderTrack.BackgroundColor3 = UI.Theme.Border
        sliderTrack.BorderSizePixel = 0
        sliderTrack.ZIndex = 5
        sliderTrack.Parent = sliderContainer
        
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(0, 3)
        trackCorner.Parent = sliderTrack
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new(0, 0, 1, 0)
        sliderFill.Position = UDim2.new(0, 0, 0, 0)
        sliderFill.BackgroundColor3 = UI.Theme.Primary
        sliderFill.BorderSizePixel = 0
        sliderFill.ZIndex = 6
        sliderFill.Parent = sliderTrack
        
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(0, 3)
        fillCorner.Parent = sliderFill
        
        local sliderHandle = Instance.new("Frame")
        sliderHandle.Size = UDim2.new(0, 16, 0, 16)
        sliderHandle.Position = UDim2.new(0, -8, 0.5, -8)
        sliderHandle.BackgroundColor3 = UI.Theme.Text
        sliderHandle.BorderSizePixel = 0
        sliderHandle.ZIndex = 7
        sliderHandle.Parent = sliderTrack
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(1, 0)
        handleCorner.Parent = sliderHandle
        
        local interactionButton = Instance.new("TextButton")
        interactionButton.Size = UDim2.new(1, 20, 1, 20)
        interactionButton.Position = UDim2.new(0, -10, 0, -10)
        interactionButton.BackgroundTransparency = 1
        interactionButton.Text = ""
        interactionButton.ZIndex = 8
        interactionButton.Parent = sliderTrack
        
        local slider = {
            container = sliderContainer,
            valueLabel = valueLabel,
            fill = sliderFill,
            handle = sliderHandle,
            track = sliderTrack,
            button = interactionButton,
            minValue = minValue,
            maxValue = maxValue,
            currentValue = currentValue,
            dragging = false
        }
        
        local function updateSlider(value)
            value = math.clamp(value, minValue, maxValue)
            slider.currentValue = value
            
            if value >= 100 then
                valueLabel.Text = string.format("%.0f", value)
            elseif value >= 1 then
                valueLabel.Text = string.format("%.1f", value)
            else
                valueLabel.Text = string.format("%.2f", value)
            end
            
            local percentage = (value - minValue) / (maxValue - minValue)
            
            UI:Tween(sliderFill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.1)
            UI:Tween(sliderHandle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.1)
            
            callback(value)
        end
        
        local function getValueFromPosition(mouseX)
            local trackPosition = sliderTrack.AbsolutePosition.X
            local trackSize = sliderTrack.AbsoluteSize.X
            local relativeX = mouseX - trackPosition
            local percentage = math.clamp(relativeX / trackSize, 0, 1)
            return minValue + (maxValue - minValue) * percentage
        end
        
        local dragging = false
        
        interactionButton.MouseButton1Down:Connect(function()
            dragging = true
            slider.dragging = true
        end)
        
        interactionButton.MouseButton1Up:Connect(function()
            dragging = false
            slider.dragging = false
        end)
        
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local newValue = getValueFromPosition(input.Position.X)
                updateSlider(newValue)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                slider.dragging = false
            end
        end)
        
        interactionButton.MouseButton1Click:Connect(function()
            if not slider.dragging then
                local mouse = LocalPlayer:GetMouse()
                local newValue = getValueFromPosition(mouse.X)
                updateSlider(newValue)
            end
        end)
        
        interactionButton.MouseEnter:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.1}, UI.Animations.Fast)
            UI:Tween(sliderHandle, {Size = UDim2.new(0, 18, 0, 18)}, UI.Animations.Fast)
        end)
        
        interactionButton.MouseLeave:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.3}, UI.Animations.Fast)
            if not slider.dragging then
                UI:Tween(sliderHandle, {Size = UDim2.new(0, 16, 0, 16)}, UI.Animations.Fast)
            end
        end)
        
        updateSlider(currentValue)
        table.insert(category.Items, sliderContainer)
        
        return slider
    end

    -- Create sliders
    local function createAimbotSliders()
        if Aimbot_State.slidersCreated then return end
        
        -- FOV Radius Slider
        local fovSlider = createCustomSlider(
            AimbotCategory,
            "fovRadius",
            10,
            1000,
            200,
            function(value)
                Aimbot_State.config.FOV_RADIUS = value
                if Aimbot_State.fovCircle then 
                    Aimbot_State.fovCircle.Radius = value 
                end
            end
        )
        
        -- Camera Height Offset Slider
        local heightSlider = createCustomSlider(
            AimbotCategory,
            "cameraHeight",
            -2,
            2,
            0.5,
            function(value)
                Aimbot_State.config.CAMERA_HEIGHT_OFFSET = value
            end
        )
        
        -- Lock Distance Slider
        local distanceSlider = createCustomSlider(
            AimbotCategory,
            "lockDistance",
            100,
            20000,
            10000,
            function(value)
                Aimbot_State.config.LOCK_DISTANCE = value
            end
        )
        
        Aimbot_State.sliders.fov = fovSlider
        Aimbot_State.sliders.height = heightSlider
        Aimbot_State.sliders.distance = distanceSlider
        
        Aimbot_State.slidersCreated = true
    end

    -- Initialize
    createDrawings()
    createAimbotSliders()

    -- Event Handlers
    game.Players.PlayerAdded:Connect(function(p)
        wait(1)
        cleanWhitelist()
    end)

    game.Players.PlayerRemoving:Connect(function(p)
        if Aimbot_State.config.WHITELIST[p.Name] then
            Aimbot_State.config.WHITELIST[p.Name] = nil
        end
        if Aimbot_State.currentTarget == p then 
            Aimbot_State.currentTarget = nil
        end
        cleanWhitelist()
    end)

    -- Main Loop
    game:GetService("RunService").RenderStepped:Connect(function()
        local ctrl = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftControl)
        
        if Aimbot_State.config.AIMBOT_ENABLED then
            -- Check for left control activation
            if ctrl and not Aimbot_State.config.wasLeftControlDown then
                local target = findTarget()
                if target then
                    aimNormal(target)
                end
            end
            
            Aimbot_State.config.wasLeftControlDown = ctrl
        end
        
        updateVisuals()
    end)

    -- FOV Toggle (O key)
    game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
        if not processed and input.KeyCode == Enum.KeyCode.O then
            Aimbot_State.config.SHOW_FOV_CIRCLE = not Aimbot_State.config.SHOW_FOV_CIRCLE
        end
    end)

    -- Make state global for toggles
    getgenv().Aimbot_State = Aimbot_State

end

-- Create Aimbot controls


-- Enable Aimbot Toggle
AimbotCategory:AddToggle("Enable Aimbot", false, function(Value)
    getgenv().Aimbot_State.config.AIMBOT_ENABLED = Value
    if not Value then 
        getgenv().Aimbot_State.currentTarget = nil
        if getgenv().Aimbot_State.aimConnection then
            getgenv().Aimbot_State.aimConnection:Disconnect()
            getgenv().Aimbot_State.aimConnection = nil
        end
        UI:Notify("Aimbot", "Aimbot disabled!", 2, "Info")
    else
        UI:Notify("Aimbot", "Aimbot enabled! Hold Left Control to aim.", 3, "Success")
    end
end)

-- Show FOV Circle Toggle
AimbotCategory:AddToggle("Show FOV Circle", true, function(Value)
    getgenv().Aimbot_State.config.SHOW_FOV_CIRCLE = Value
    if Value then
        UI:Notify("Aimbot", "FOV Circle visible! Press O to toggle.", 2, "Info")
    else
        UI:Notify("Aimbot", "FOV Circle hidden!", 2, "Info")
    end
end)

----------------------------------------------------------------------------------------------------------------------------
--COMBAT (Working Slider Implementation)
----------------------------------------------------------------------------------------------------------------------------

do
    -- Get LocalPlayer reference
    local LocalPlayer = game:GetService("Players").LocalPlayer
    
    -- Consolidated state management for combat
    local Combat_State = {
        enabled = false,
        customRange = 50,
        originalAttributes = {},
        connections = {},
        sliders = {},
        slidersCreated = false,
        meleeWeapons = {
            ["Axe"] = {speed = 1.4, range = 6.5},
            ["Barbed Baseball Bat"] = {speed = 1.6, range = 7.5},
            ["Baseball Bat"] = {speed = 1.6, range = 7.5},
            ["Bike Lock"] = {speed = 1.9, range = 6},
            ["Bronze Mop"] = {speed = 1.5, range = 6.5},
            ["Chair Leg"] = {speed = 1.6, range = 6.5},
            ["Butcher Knife"] = {speed = 1.6, range = 6},
            ["Combat Axe"] = {speed = 1.6, range = 6.5},
            ["Crowbar"] = {speed = 1.6, range = 7},
            ["Diamond Mop"] = {speed = 1.5, range = 6.5},
            ["Frying Pan"] = {speed = 1.7, range = 6.5},
            ["Gold Mop"] = {speed = 1.5, range = 6.5},
            ["Hammer"] = {speed = 1.75, range = 6},
            ["Machette"] = {speed = 1.8, range = 7.25},
            ["Metal Baseball Bat"] = {speed = 1.6, range = 7.5},
            ["Metal Pipe"] = {speed = 1.55, range = 6.5},
            ["Mop"] = {speed = 1.5, range = 6.5},
            ["Nailed Wooden Board"] = {speed = 1.4, range = 6.5},
            ["Pool Cue"] = {speed = 1.7, range = 7.5},
            ["Rolling Pin"] = {speed = 1.75, range = 6.5},
            ["Rusty Shovel"] = {speed = 1.2, range = 7},
            ["Shank"] = {speed = 2, range = 5.5},
            ["Shovel"] = {speed = 1.2, range = 67.5},
            ["Silver Mop"] = {speed = 1.5, range = 6.5},
            ["Sledge Hammer"] = {speed = 1.1, range = 7.25},
            ["Switchblade"] = {speed = 2, range = 5.5},
            ["Tactical Axe"] = {speed = 1.75, range = 6.5},
            ["Tactical Knife"] = {speed = 2.2, range = 5.75},
            ["Tactical Shovel"] = {speed = 2, range = 6.75},
            ["Taser"] = {speed = 2, range = 5.25},
            ["Tire Iron"] = {speed = 1.6, range = 6.5},
            ["Wooden Board"] = {speed = 1.45, range = 6.5},
            ["Wrench"] = {speed = 1.5, range = 6},
            ["Fists"] = {speed = 1, range = 5}
        }
    }

    -- Custom slider creation function (copied from working aimbot script)
    local function createCustomSlider(category, attributeName, minValue, maxValue, currentValue, callback)
        local displayName = attributeName:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
        
        local sliderContainer = Instance.new("Frame")
        sliderContainer.Name = attributeName .. "Slider"
        sliderContainer.Size = UDim2.new(1, 0, 0, 45)
        sliderContainer.BackgroundColor3 = UI.Theme.Background
        sliderContainer.BackgroundTransparency = 0.3
        sliderContainer.BorderSizePixel = 0
        sliderContainer.ZIndex = 4
        sliderContainer.LayoutOrder = #category.Items + 1
        sliderContainer.Parent = category.ContentFrame
        
        local sliderCorner = Instance.new("UICorner")
        sliderCorner.CornerRadius = UDim.new(0, 4)
        sliderCorner.Parent = sliderContainer
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(0.6, 0, 0, 20)
        titleLabel.Position = UDim2.new(0, 15, 0, 2)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = displayName
        titleLabel.TextColor3 = UI.Theme.Text
        titleLabel.TextSize = 14
        titleLabel.Font = Enum.Font.SourceSans
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.ZIndex = 5
        titleLabel.Parent = sliderContainer
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0.35, 0, 0, 20)
        valueLabel.Position = UDim2.new(0.65, 0, 0, 2)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(currentValue)
        valueLabel.TextColor3 = UI.Theme.Primary
        valueLabel.TextSize = 12
        valueLabel.Font = Enum.Font.SourceSansBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.ZIndex = 5
        valueLabel.Parent = sliderContainer
        
        local sliderTrack = Instance.new("Frame")
        sliderTrack.Size = UDim2.new(1, -30, 0, 6)
        sliderTrack.Position = UDim2.new(0, 15, 0, 30)
        sliderTrack.BackgroundColor3 = UI.Theme.Border
        sliderTrack.BorderSizePixel = 0
        sliderTrack.ZIndex = 5
        sliderTrack.Parent = sliderContainer
        
        local trackCorner = Instance.new("UICorner")
        trackCorner.CornerRadius = UDim.new(0, 3)
        trackCorner.Parent = sliderTrack
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new(0, 0, 1, 0)
        sliderFill.Position = UDim2.new(0, 0, 0, 0)
        sliderFill.BackgroundColor3 = UI.Theme.Primary
        sliderFill.BorderSizePixel = 0
        sliderFill.ZIndex = 6
        sliderFill.Parent = sliderTrack
        
        local fillCorner = Instance.new("UICorner")
        fillCorner.CornerRadius = UDim.new(0, 3)
        fillCorner.Parent = sliderFill
        
        local sliderHandle = Instance.new("Frame")
        sliderHandle.Size = UDim2.new(0, 16, 0, 16)
        sliderHandle.Position = UDim2.new(0, -8, 0.5, -8)
        sliderHandle.BackgroundColor3 = UI.Theme.Text
        sliderHandle.BorderSizePixel = 0
        sliderHandle.ZIndex = 7
        sliderHandle.Parent = sliderTrack
        
        local handleCorner = Instance.new("UICorner")
        handleCorner.CornerRadius = UDim.new(1, 0)
        handleCorner.Parent = sliderHandle
        
        local interactionButton = Instance.new("TextButton")
        interactionButton.Size = UDim2.new(1, 20, 1, 20)
        interactionButton.Position = UDim2.new(0, -10, 0, -10)
        interactionButton.BackgroundTransparency = 1
        interactionButton.Text = ""
        interactionButton.ZIndex = 8
        interactionButton.Parent = sliderTrack
        
        local slider = {
            container = sliderContainer,
            valueLabel = valueLabel,
            fill = sliderFill,
            handle = sliderHandle,
            track = sliderTrack,
            button = interactionButton,
            minValue = minValue,
            maxValue = maxValue,
            currentValue = currentValue,
            dragging = false
        }
        
        local function updateSlider(value)
            value = math.clamp(value, minValue, maxValue)
            slider.currentValue = value
            
            if value >= 100 then
                valueLabel.Text = string.format("%.0f", value)
            elseif value >= 1 then
                valueLabel.Text = string.format("%.1f", value)
            else
                valueLabel.Text = string.format("%.2f", value)
            end
            
            local percentage = (value - minValue) / (maxValue - minValue)
            
            UI:Tween(sliderFill, {Size = UDim2.new(percentage, 0, 1, 0)}, 0.1)
            UI:Tween(sliderHandle, {Position = UDim2.new(percentage, -8, 0.5, -8)}, 0.1)
            
            callback(value)
        end
        
        local function getValueFromPosition(mouseX)
            local trackPosition = sliderTrack.AbsolutePosition.X
            local trackSize = sliderTrack.AbsoluteSize.X
            local relativeX = mouseX - trackPosition
            local percentage = math.clamp(relativeX / trackSize, 0, 1)
            return minValue + (maxValue - minValue) * percentage
        end
        
        local dragging = false
        
        interactionButton.MouseButton1Down:Connect(function()
            dragging = true
            slider.dragging = true
        end)
        
        interactionButton.MouseButton1Up:Connect(function()
            dragging = false
            slider.dragging = false
        end)
        
        local UserInputService = game:GetService("UserInputService")
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local newValue = getValueFromPosition(input.Position.X)
                updateSlider(newValue)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                slider.dragging = false
            end
        end)
        
        interactionButton.MouseButton1Click:Connect(function()
            if not slider.dragging then
                local mouse = LocalPlayer:GetMouse()
                local newValue = getValueFromPosition(mouse.X)
                updateSlider(newValue)
            end
        end)
        
        interactionButton.MouseEnter:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.1}, UI.Animations.Fast)
            UI:Tween(sliderHandle, {Size = UDim2.new(0, 18, 0, 18)}, UI.Animations.Fast)
        end)
        
        interactionButton.MouseLeave:Connect(function()
            UI:Tween(sliderContainer, {BackgroundTransparency = 0.3}, UI.Animations.Fast)
            if not slider.dragging then
                UI:Tween(sliderHandle, {Size = UDim2.new(0, 16, 0, 16)}, UI.Animations.Fast)
            end
        end)
        
        updateSlider(currentValue)
        table.insert(category.Items, sliderContainer)
        
        return slider
    end

    -- Function to store original attributes of a tool
    local function StoreOriginalAttributes(tool)
        if not tool or Combat_State.originalAttributes[tool] then return end
        
        local weaponData = Combat_State.meleeWeapons[tool.Name]
        if not weaponData then return end
        
        Combat_State.originalAttributes[tool] = {}
        
        for attrName, attrValue in pairs(tool:GetAttributes()) do
            if type(attrValue) == "number" then
                Combat_State.originalAttributes[tool][attrName] = attrValue
            end
        end
    end

    -- Function to modify or restore attributes for detected melee weapons
    local function ModifyMeleeAttributes(tool, shouldModify)
        if not tool then return end
        
        -- Check if this tool is a known melee weapon
        local weaponData = Combat_State.meleeWeapons[tool.Name]
        if not weaponData then return end
        
        -- Wait a brief moment for tool to fully load
        wait(0.1)
        
        -- Store original attributes if not already stored
        StoreOriginalAttributes(tool)
        
        if shouldModify then
            -- Get all attributes
            for attrName, attrValue in pairs(tool:GetAttributes()) do
                if type(attrValue) == "number" then
                    -- Check if this attribute matches the expected speed value
                    if math.abs(attrValue - weaponData.speed) < 0.01 then
                        tool:SetAttribute(attrName, 0)  -- Set speed to 0
                    end
                    
                    -- Check if this attribute matches the expected range value
                    if math.abs(attrValue - weaponData.range) < 0.01 then
                        tool:SetAttribute(attrName, Combat_State.customRange)  -- Set range to custom value
                    end
                end
            end
        else
            -- Restore original attributes
            if Combat_State.originalAttributes[tool] then
                for attrName, originalValue in pairs(Combat_State.originalAttributes[tool]) do
                    tool:SetAttribute(attrName, originalValue)
                end
            end
        end
    end

    -- Function to modify/restore existing tools
    local function ProcessExistingTools(shouldModify)
        if not LocalPlayer.Character then return end
        
        -- Check currently equipped tools
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                ModifyMeleeAttributes(item, shouldModify)
            end
        end
        
        -- Check all tools in backpack
        for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
            if item:IsA("Tool") then
                ModifyMeleeAttributes(item, shouldModify)
            end
        end
    end

    -- Function to handle new tools being added
    local function HandleNewTool(newItem)
        if newItem:IsA("Tool") and Combat_State.enabled then
            spawn(function()
                ModifyMeleeAttributes(newItem, true)
            end)
        end
    end

    -- Function to setup connections
    local function SetupConnections()
        -- Clean up existing connections
        for _, connection in pairs(Combat_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        Combat_State.connections = {}
        
        -- Set up automatic detection for NEW tools added to backpack
        Combat_State.connections[#Combat_State.connections + 1] = LocalPlayer.Backpack.ChildAdded:Connect(HandleNewTool)

        -- Set up automatic detection for NEW tools equipped to character
        Combat_State.connections[#Combat_State.connections + 1] = LocalPlayer.CharacterAdded:Connect(function(character)
            Combat_State.connections[#Combat_State.connections + 1] = character.ChildAdded:Connect(HandleNewTool)
        end)

        -- Also set up monitoring for current character if it exists
        if LocalPlayer.Character then
            Combat_State.connections[#Combat_State.connections + 1] = LocalPlayer.Character.ChildAdded:Connect(HandleNewTool)
        end
    end

    -- Function to cleanup everything
    local function CleanupCombat()
        -- Restore all weapons to original state
        if Combat_State.enabled then
            ProcessExistingTools(false)
        end
        
        -- Disconnect all connections
        for _, connection in pairs(Combat_State.connections) do
            if connection then
                connection:Disconnect()
            end
        end
        Combat_State.connections = {}
        
        -- Clear stored attributes
        Combat_State.originalAttributes = {}
        Combat_State.enabled = false
    end

    -- Create sliders
    local function createCombatSliders()
        if Combat_State.slidersCreated then return end
        
        -- Weapon Range Slider
        local rangeSlider = createCustomSlider(
            CombateCategory,
            "weaponRange",
            10,
            50,
            50,
            function(value)
                Combat_State.customRange = value
                
                -- If modifier is currently enabled, update all existing weapons with new range
                if Combat_State.enabled then
                    spawn(function()
                        ProcessExistingTools(true)
                    end)
                end
            end
        )
        
        Combat_State.sliders.range = rangeSlider
        Combat_State.slidersCreated = true
    end

    -- Initialize connections and sliders
    SetupConnections()
    createCombatSliders()

    -- Make state global for external access
    getgenv().Combat_State = Combat_State

end

-- Create Combat controls outside the main block

-- Main Combat Toggle
CombateCategory:AddToggle("Melee Weapon Modifier", false, function(Value)
    getgenv().Combat_State.enabled = Value
    
    if Value then
        UI:Notify("Combat", "Melee weapon modifier enabled!", 3, "Success")
        -- Enable: Modify all existing tools
        spawn(function()
            local LocalPlayer = game:GetService("Players").LocalPlayer
            if not LocalPlayer.Character then return end
            
            -- Check currently equipped tools
            for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                if item:IsA("Tool") then
                    local weaponData = getgenv().Combat_State.meleeWeapons[item.Name]
                    if weaponData then
                        wait(0.1)
                        for attrName, attrValue in pairs(item:GetAttributes()) do
                            if type(attrValue) == "number" then
                                if math.abs(attrValue - weaponData.speed) < 0.01 then
                                    item:SetAttribute(attrName, 0)
                                end
                                if math.abs(attrValue - weaponData.range) < 0.01 then
                                    item:SetAttribute(attrName, getgenv().Combat_State.customRange)
                                end
                            end
                        end
                    end
                end
            end
            
            -- Check all tools in backpack
            for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                if item:IsA("Tool") then
                    local weaponData = getgenv().Combat_State.meleeWeapons[item.Name]
                    if weaponData then
                        wait(0.1)
                        for attrName, attrValue in pairs(item:GetAttributes()) do
                            if type(attrValue) == "number" then
                                if math.abs(attrValue - weaponData.speed) < 0.01 then
                                    item:SetAttribute(attrName, 0)
                                end
                                if math.abs(attrValue - weaponData.range) < 0.01 then
                                    item:SetAttribute(attrName, getgenv().Combat_State.customRange)
                                end
                            end
                        end
                    end
                end
            end
        end)
    else
        UI:Notify("Combat", "Melee weapon modifier disabled!", 2, "Info")
        -- Disable: Restore all existing tools to original values
        spawn(function()
            local LocalPlayer = game:GetService("Players").LocalPlayer
            if not LocalPlayer.Character then return end
            
            -- Restore currently equipped tools
            for _, item in pairs(LocalPlayer.Character:GetChildren()) do
                if item:IsA("Tool") and getgenv().Combat_State.originalAttributes[item] then
                    for attrName, originalValue in pairs(getgenv().Combat_State.originalAttributes[item]) do
                        item:SetAttribute(attrName, originalValue)
                    end
                end
            end
            
            -- Restore all tools in backpack
            for _, item in pairs(LocalPlayer.Backpack:GetChildren()) do
                if item:IsA("Tool") and getgenv().Combat_State.originalAttributes[item] then
                    for attrName, originalValue in pairs(getgenv().Combat_State.originalAttributes[item]) do
                        item:SetAttribute(attrName, originalValue)
                    end
                end
            end
        end)
    end
end)

----------------------------------------------------------------------------------------------------------------------------
--NAME CHANGER (Simple Toggle Version)
----------------------------------------------------------------------------------------------------------------------------

do
    -- Your original script logic
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    local NameChanger_State = {
        enabled = false,
        originalName = nil
    }
    
    local function updateDisplayName(character)
        if not NameChanger_State.enabled then return end
        
        print("Attempting to update display name for:", character.Name)
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
        if not humanoidRootPart then
            print("Could not find HumanoidRootPart")
            return
        end
        
        -- Wait a moment for everything to load
        wait(1)
        
        -- Look for existing BillboardGui
        local billboardGui = humanoidRootPart:FindFirstChild("CharacterBillboardGui")
        
        if billboardGui then
            print("Found existing CharacterBillboardGui")
            -- Find the TextLabel inside it
            local textLabel = billboardGui:FindFirstChildOfClass("TextLabel")
            if textLabel then
                -- Store original name if we haven't already
                if not NameChanger_State.originalName then
                    NameChanger_State.originalName = textLabel.Text
                    print("Stored original name:", NameChanger_State.originalName)
                end
                print("Found TextLabel, changing text to Phantom.exe")
                textLabel.Text = "Phantom.exe"
            else
                print("No TextLabel found in existing BillboardGui")
                -- Create a new TextLabel
                local newTextLabel = Instance.new("TextLabel")
                newTextLabel.Size = UDim2.new(1, 0, 1, 0)
                newTextLabel.BackgroundTransparency = 1
                newTextLabel.Font = Enum.Font.SourceSansBold
                newTextLabel.TextSize = 14
                newTextLabel.TextColor3 = Color3.new(1, 1, 1)
                newTextLabel.Text = "Phantom.exe"
                newTextLabel.TextStrokeTransparency = 0.5
                newTextLabel.Parent = billboardGui
                print("Created new TextLabel with Phantom.exe text")
            end
        else
            print("No existing CharacterBillboardGui found, creating new one")
            -- Create completely new BillboardGui
            billboardGui = Instance.new("BillboardGui")
            billboardGui.Name = "CharacterBillboardGui"
            billboardGui.Size = UDim2.new(0, 170, 0, 50)  -- Made slightly wider for "Phantom.exe"
            billboardGui.StudsOffset = Vector3.new(0, 3, 0)
            billboardGui.Parent = humanoidRootPart
            
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.TextSize = 16
            textLabel.TextColor3 = Color3.new(1, 1, 1)
            textLabel.Text = "Phantom.exe"
            textLabel.TextStrokeTransparency = 0.5
            textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            textLabel.Parent = billboardGui
            
            print("Created new BillboardGui and TextLabel")
        end
    end
    
    -- Function to restore original name
    local function restoreOriginalName(character)
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        local billboardGui = humanoidRootPart:FindFirstChild("CharacterBillboardGui")
        if billboardGui then
            local textLabel = billboardGui:FindFirstChildOfClass("TextLabel")
            if textLabel and NameChanger_State.originalName then
                print("Restoring original name:", NameChanger_State.originalName)
                textLabel.Text = NameChanger_State.originalName
            end
        end
    end
    
    -- Handle when player spawns
    local function handleCharacterAdded(character)
        if NameChanger_State.enabled then
            updateDisplayName(character)
        end
    end
    
    -- Set up connections
    if LocalPlayer.Character then
        handleCharacterAdded(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(handleCharacterAdded)
    
    -- Make state global
    getgenv().NameChanger_State = NameChanger_State
    getgenv().updateDisplayName = updateDisplayName
    getgenv().restoreOriginalName = restoreOriginalName
    
    print("Script loaded successfully")
end

-- Simple toggle using your GUI system
PlayerCategory:AddToggle("Name Changer", false, function(Value)
    getgenv().NameChanger_State.enabled = Value
    
    if Value then
        UI:Notify("Player", "Name changer enabled!", 3, "Success")
        -- Apply to current character if it exists
        if game.Players.LocalPlayer.Character then
            spawn(function()
                getgenv().updateDisplayName(game.Players.LocalPlayer.Character)
            end)
        end
    else
        UI:Notify("Player", "Name changer disabled!", 2, "Info")
        -- Restore original name on current character
        if game.Players.LocalPlayer.Character then
            spawn(function()
                getgenv().restoreOriginalName(game.Players.LocalPlayer.Character)
            end)
        end
    end
end)

----------------------------------------------------------------------------------------------------------------------------
--LEVEL CHANGER (Simple Toggle Version)
----------------------------------------------------------------------------------------------------------------------------

do
    -- Your original script logic
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    
    local LevelChanger_State = {
        enabled = false,
        originalLevel = nil
    }
    
    local function updateLevel(character)
        if not LevelChanger_State.enabled then return end
        
        print("Attempting to update level for:", character.Name)
        
        local humanoidRootPart = character:WaitForChild("HumanoidRootPart", 10)
        if not humanoidRootPart then
            print("Could not find HumanoidRootPart")
            return
        end
        
        -- Wait for GUI to load
        wait(2)
        
        -- Navigate through the specific path you provided
        local billboardGui = humanoidRootPart:FindFirstChild("CharacterBillboardGui")
        if not billboardGui then
            print("CharacterBillboardGui not found")
            return
        end
        print("Found CharacterBillboardGui")
        
        local playerName = billboardGui:FindFirstChild("PlayerName")
        if not playerName then
            print("PlayerName not found")
            return
        end
        print("Found PlayerName")
        
        local levelImage = playerName:FindFirstChild("LevelImage")
        if not levelImage then
            print("LevelImage not found")
            return
        end
        print("Found LevelImage")
        
        local levelText = levelImage:FindFirstChild("LevelText")
        if not levelText then
            print("LevelText not found")
            return
        end
        print("Found LevelText")
        
        -- Store original level if we haven't already
        if not LevelChanger_State.originalLevel then
            LevelChanger_State.originalLevel = levelText.Text
            print("Stored original level:", LevelChanger_State.originalLevel)
        end
        
        -- Change the level to 99999
        levelText.Text = "99999"
        print("Successfully changed level to 99999!")
    end
    
    -- Function to restore original level
    local function restoreOriginalLevel(character)
        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart then return end
        
        local billboardGui = humanoidRootPart:FindFirstChild("CharacterBillboardGui")
        if not billboardGui then return end
        
        local playerName = billboardGui:FindFirstChild("PlayerName")
        if not playerName then return end
        
        local levelImage = playerName:FindFirstChild("LevelImage")
        if not levelImage then return end
        
        local levelText = levelImage:FindFirstChild("LevelText")
        if levelText and LevelChanger_State.originalLevel then
            print("Restoring original level:", LevelChanger_State.originalLevel)
            levelText.Text = LevelChanger_State.originalLevel
        end
    end
    
    -- Handle when player spawns
    local function handleCharacterAdded(character)
        if LevelChanger_State.enabled then
            updateLevel(character)
        end
    end
    
    -- Set up connections
    if LocalPlayer.Character then
        handleCharacterAdded(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(handleCharacterAdded)
    
    -- Make state global
    getgenv().LevelChanger_State = LevelChanger_State
    getgenv().updateLevel = updateLevel
    getgenv().restoreOriginalLevel = restoreOriginalLevel
    
    print("Level changer script loaded successfully")
end

-- Simple toggle using your GUI system
PlayerCategory:AddToggle("Level Changer", false, function(Value)
    getgenv().LevelChanger_State.enabled = Value
    
    if Value then
        UI:Notify("Player", "Level changer enabled!", 3, "Success")
        -- Apply to current character if it exists
        if game.Players.LocalPlayer.Character then
            spawn(function()
                getgenv().updateLevel(game.Players.LocalPlayer.Character)
            end)
        end
    else
        UI:Notify("Player", "Level changer disabled!", 2, "Info")
        -- Restore original level on current character
        if game.Players.LocalPlayer.Character then
            spawn(function()
                getgenv().restoreOriginalLevel(game.Players.LocalPlayer.Character)
            end)
        end
    end
end)

-- Add this to your Settings category (before the emergency stop keybind section):

-- Complete Script Unloader Button
SettingsCategory:AddButton("Emergency Unload", function()
    UI:Notify("System", "Unloading Phantom Enhanced...", 2, "Warning")
    
    spawn(function()
        wait(1) -- Small delay to show the notification
        
        -- Disable all active systems
        pcall(function()
            -- Auto Farm Systems
            if getgenv().JobAutoFarm_State then getgenv().JobAutoFarm_State.running = false end
            if getgenv().SteakhouseFarm_State then getgenv().SteakhouseFarm_State.enabled = false end
            if getgenv().JanitorFarm_State then getgenv().JanitorFarm_State.running = false end
            if getgenv().ATMHack_State then getgenv().ATMHack_State.running = false end
            
            -- Combat Systems
            if getgenv().Combat_State then getgenv().Combat_State.enabled = false end
            if getgenv().WeaponMod_State then 
                for attr, _ in pairs(getgenv().WeaponMod_State.attributeMultipliers) do
                    getgenv().WeaponMod_State.attributeMultipliers[attr] = 1
                end
            end
            
            -- Player Systems
            if getgenv().SpeedBoost_State then getgenv().SpeedBoost_State.enabled = false end
            if getgenv().SuperJump_State then getgenv().SuperJump_State.enabled = false end
            if getgenv().AutoRespawn_State then getgenv().disableAutoRespawn() end
            if getgenv().NameChanger_State then getgenv().NameChanger_State.enabled = false end
            if getgenv().LevelChanger_State then getgenv().LevelChanger_State.enabled = false end
            
            -- Aimbot System
            if getgenv().Aimbot_State then 
                getgenv().Aimbot_State.config.AIMBOT_ENABLED = false
                if getgenv().Aimbot_State.fovCircle then 
                    getgenv().Aimbot_State.fovCircle:Destroy() 
                end
            end
            
            -- ESP Systems
            if ESP_State then ESP_State.enabled = false end
            if NameTags_State then NameTags_State.enabled = false end
            if WeaponESP_State then WeaponESP_State.enabled = false end
            
            -- Vehicle Systems
            if VehicleMod_State then
                for attr, defaultVal in pairs(VehicleMod_State.defaults) do
                    VehicleMod_State.values[attr] = defaultVal
                end
            end
        end)
        
        -- Clean up global variables
        pcall(function()
            getgenv().JobAutoFarm_State = nil
            getgenv().SteakhouseFarm_State = nil
            getgenv().JanitorFarm_State = nil
            getgenv().ATMHack_State = nil
            getgenv().Combat_State = nil
            getgenv().WeaponMod_State = nil
            getgenv().ModifyExistingGuns = nil
            getgenv().SpeedBoost_State = nil
            getgenv().SuperJump_State = nil
            getgenv().AutoRespawn_State = nil
            getgenv().enableAutoRespawn = nil
            getgenv().disableAutoRespawn = nil
            getgenv().NameChanger_State = nil
            getgenv().updateDisplayName = nil
            getgenv().restoreOriginalName = nil
            getgenv().LevelChanger_State = nil
            getgenv().updateLevel = nil
            getgenv().restoreOriginalLevel = nil
            getgenv().Aimbot_State = nil
            getgenv().WeaponESPData = nil
        end)
        
        -- Reset player attributes
        pcall(function()
            if LocalPlayer then
                LocalPlayer:SetAttribute("SpeedMultiplier", 1)
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    local humanoid = LocalPlayer.Character.Humanoid
                    humanoid.UseJumpPower = true
                    humanoid.JumpPower = 23
                end
            end
        end)
        
        -- Destroy all ESP drawings
        pcall(function()
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character then
                    local head = player.Character:FindFirstChild("Head")
                    if head then
                        local nameTag = head:FindFirstChild("NameTag")
                        if nameTag then nameTag:Destroy() end
                    end
                    
                    local weaponESP = player.Character:FindFirstChild("WeaponESPAdornment")
                    if weaponESP then weaponESP:Destroy() end
                end
            end
        end)
        
        -- Remove custom billboards
        pcall(function()
            if LocalPlayer.Character then
                local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local phantomName = hrp:FindFirstChild("PhantomNameGui")
                    if phantomName then phantomName:Destroy() end
                end
            end
        end)
        
        -- Close and destroy UI
        pcall(function()
            if UI and UI.ScreenGui then
                UI.ScreenGui:Destroy()
            end
        end)
        
        -- Clear UI reference
        UI = nil
        PhantomUI = nil
    
        -- Collect garbage
        collectgarbage("collect")
    end)
end)

-- Emergency stop keybind
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    if input.KeyCode == Enum.KeyCode.X then
        UI:Notify("Emergency", "Emergency stop activated!", 2, "Warning")
        -- We'll add the stop variables here when the scripts are properly scoped
    end
end)

-- Return the UI
return UI
